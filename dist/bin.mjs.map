{"version":3,"file":"bin.mjs","names":[],"sources":["../src/utils/hints.ts","../src/utils/cli.ts","../src/utils/logger.ts","../src/utils/output.ts","../src/commands/categories.ts","../src/commands/series.ts","../src/commands/events.ts","../src/commands/markets.ts","../src/commands/trades.ts","../src/commands/search.ts","../src/utils/wallet.ts","../src/commands/wallet.ts","../src/utils/mintLabels.ts","../src/utils/mintDecimals.ts","../src/trading/signAndSend.ts","../src/commands/trade.ts","../src/api/positions.ts","../src/commands/positions.ts","../src/bin.ts"],"sourcesContent":["export interface DescribeSchema {\n  command: string;\n  defaults?: Record<string, unknown>;\n  filters: Record<\n    string,\n    { type: string; values?: string[]; default?: unknown; description?: string }\n  >;\n  discovery_flow?: string[];\n}\n\nexport interface OutputHints {\n  available_filters?: string[];\n  next?: string;\n  related?: string[];\n  notes?: string[];\n}\n\nexport function eventsDescribeSchema(): DescribeSchema {\n  return {\n    command: \"predictarena events list\",\n    defaults: { status: \"active\", limit: 20, sort: \"volume\" },\n    filters: {\n      status: {\n        type: \"enum\",\n        values: [\n          \"initialized\",\n          \"active\",\n          \"inactive\",\n          \"closed\",\n          \"determined\",\n          \"finalized\",\n        ],\n      },\n      sort: {\n        type: \"enum\",\n        values: [\"volume\", \"volume24h\", \"liquidity\", \"openInterest\", \"startDate\"],\n      },\n      order: { type: \"enum\", values: [\"asc\", \"desc\"], default: \"desc\" },\n      seriesTickers: {\n        type: \"string\",\n        description: \"Comma-separated series tickers (max 25).\",\n      },\n      isInitialized: {\n        type: \"boolean\",\n        description: \"Filter to events with market ledger.\",\n      },\n      withNestedMarkets: { type: \"boolean\", default: true },\n      limit: { type: \"number\", default: 20 },\n      cursor: { type: \"number\", description: \"Pagination offset.\" },\n    },\n    discovery_flow: [\n      \"predictarena categories        -- browse categories and tags\",\n      \"predictarena series --category Sports  -- get series tickers\",\n      \"predictarena events list --series <ticker> -- filter events\",\n    ],\n  };\n}\n\nexport function marketsDescribeSchema(): DescribeSchema {\n  return {\n    command: \"predictarena markets list\",\n    defaults: { status: \"active\", limit: 20, sort: \"volume\" },\n    filters: {\n      status: {\n        type: \"enum\",\n        values: [\n          \"initialized\",\n          \"active\",\n          \"inactive\",\n          \"closed\",\n          \"determined\",\n          \"finalized\",\n        ],\n      },\n      sort: {\n        type: \"enum\",\n        values: [\"volume\", \"volume24h\", \"liquidity\", \"openInterest\", \"startDate\"],\n      },\n      order: { type: \"enum\", values: [\"asc\", \"desc\"], default: \"desc\" },\n      isInitialized: {\n        type: \"boolean\",\n        description: \"Filter to markets with market ledger.\",\n      },\n      limit: { type: \"number\", default: 20 },\n      cursor: { type: \"number\", description: \"Pagination offset.\" },\n    },\n  };\n}\n\nexport function seriesDescribeSchema(): DescribeSchema {\n  return {\n    command: \"predictarena series\",\n    filters: {\n      category: { type: \"string\", description: \"Series category filter.\" },\n      tags: { type: \"string\", description: \"Comma-separated tags.\" },\n      status: {\n        type: \"enum\",\n        values: [\n          \"initialized\",\n          \"active\",\n          \"inactive\",\n          \"closed\",\n          \"determined\",\n          \"finalized\",\n        ],\n      },\n      isInitialized: {\n        type: \"boolean\",\n        description: \"Filter to series with market ledger.\",\n      },\n    },\n  };\n}\n\nexport function tradesDescribeSchema(): DescribeSchema {\n  return {\n    command: \"predictarena trades list\",\n    filters: {\n      ticker: { type: \"string\", description: \"Market ticker filter.\" },\n      minTs: { type: \"number\", description: \"Min unix timestamp.\" },\n      maxTs: { type: \"number\", description: \"Max unix timestamp.\" },\n      limit: { type: \"number\", description: \"Max trades (1-1000).\" },\n      cursor: { type: \"string\", description: \"Pagination cursor (trade ID).\" },\n    },\n  };\n}\n\nexport function searchDescribeSchema(): DescribeSchema {\n  return {\n    command: \"predictarena search\",\n    filters: {\n      q: { type: \"string\", description: \"Search query (required).\" },\n      sort: {\n        type: \"enum\",\n        values: [\"volume\", \"volume24h\", \"liquidity\", \"openInterest\", \"startDate\"],\n      },\n      order: { type: \"enum\", values: [\"asc\", \"desc\"], default: \"desc\" },\n      limit: { type: \"number\", description: \"Limit results.\" },\n      cursor: { type: \"number\", description: \"Pagination offset.\" },\n      withNestedMarkets: { type: \"boolean\" },\n      withMarketAccounts: { type: \"boolean\" },\n    },\n  };\n}\n\nexport function buildHints(hints: OutputHints): OutputHints {\n  return hints;\n}\n","import type { Command } from \"commander\";\n\nexport interface GlobalOptions {\n  json: boolean;\n  verbose: boolean;\n}\n\nexport function applyGlobalOptions(command: Command): void {\n  command.option(\"--json\", \"Output full JSON payloads\");\n  command.option(\"--verbose\", \"Enable verbose logging\");\n}\n\nexport function getGlobalOptions(command: Command): GlobalOptions {\n  const local = command.opts?.() ?? {};\n  let current: Command | null = command;\n  while (current?.parent) current = current.parent;\n  const opts = current?.opts?.() ?? {};\n  return {\n    json: Boolean(local.json ?? opts.json),\n    verbose: Boolean(local.verbose ?? opts.verbose),\n  };\n}\n","import chalk from \"chalk\";\n\nexport interface Logger {\n  info: (message: string) => void;\n  warn: (message: string) => void;\n  error: (message: string) => void;\n  debug: (message: string) => void;\n}\n\nexport function createLogger(opts?: { verbose?: boolean }): Logger {\n  const verbose = Boolean(opts?.verbose);\n\n  return {\n    info: (message) => console.log(message),\n    warn: (message) => console.warn(chalk.yellow(message)),\n    error: (message) => console.error(chalk.red(message)),\n    debug: (message) => {\n      if (verbose) console.log(chalk.gray(message));\n    },\n  };\n}\n","import type { OutputHints } from \"./hints\";\n\nexport type OutputFormat = \"json\" | \"plain\";\n\nexport interface OutputPayload<T> {\n  data: T;\n  pagination?: Record<string, unknown>;\n  hints?: OutputHints;\n}\n\nexport function printOutput<T>(\n  format: OutputFormat,\n  payload: OutputPayload<T>,\n): void {\n  if (format === \"json\") {\n    const out = {\n      data: payload.data,\n      pagination: payload.pagination ?? null,\n      _hints: payload.hints ?? null,\n    };\n    console.log(JSON.stringify(out, null, 2));\n    return;\n  }\n\n  const dataJson = JSON.stringify(payload.data, null, 2);\n  console.log(dataJson);\n  if (payload.pagination) {\n    console.log(\"\\nPagination:\");\n    console.log(JSON.stringify(payload.pagination, null, 2));\n  }\n  if (payload.hints) {\n    console.log(\"\\nHints:\");\n    console.log(renderHints(payload.hints));\n  }\n}\n\nfunction renderHints(hints: OutputHints): string {\n  const lines: string[] = [];\n  if (hints.available_filters?.length) {\n    lines.push(`Filters: ${hints.available_filters.join(\", \")}`);\n  }\n  if (hints.next) lines.push(`Next: ${hints.next}`);\n  if (hints.related?.length) {\n    lines.push(`Related: ${hints.related.join(\", \")}`);\n  }\n  if (hints.notes?.length) {\n    lines.push(`Notes: ${hints.notes.join(\" | \")}`);\n  }\n  return lines.join(\"\\n\");\n}\n","import type { Command } from \"commander\";\nimport { getTagsByCategories } from \"../api/metadata\";\nimport { buildHints } from \"../utils/hints\";\nimport { applyGlobalOptions, getGlobalOptions } from \"../utils/cli\";\nimport { createLogger } from \"../utils/logger\";\nimport { printOutput } from \"../utils/output\";\n\nexport function registerCategoriesCommand(program: Command): void {\n  const cmd = program\n    .command(\"categories\")\n    .description(\"List tags grouped by categories\")\n    .action(async (_options, command) => {\n      const globals = getGlobalOptions(command);\n      const format = globals.json ? \"json\" : \"plain\";\n      const logger = createLogger({ verbose: globals.verbose });\n\n      logger.debug(\"Fetching tags by categories...\");\n      const data = await getTagsByCategories();\n\n      printOutput(format, {\n        data,\n        hints: buildHints({\n          related: [\"predictarena series --category <category>\", \"predictarena events list\"],\n          notes: [\"Use categories + tags to discover series tickers.\"],\n        }),\n      });\n    });\n\n  applyGlobalOptions(cmd);\n}\n","import type { Command } from \"commander\";\nimport { getSeries, getSeriesByTicker } from \"../api/metadata\";\nimport { buildHints, seriesDescribeSchema } from \"../utils/hints\";\nimport { applyGlobalOptions, getGlobalOptions } from \"../utils/cli\";\nimport { createLogger } from \"../utils/logger\";\nimport { printOutput } from \"../utils/output\";\n\nexport function registerSeriesCommand(program: Command): void {\n  const series = program\n    .command(\"series\")\n    .description(\"List series templates\")\n    .option(\"--category <category>\", \"Filter by category\")\n    .option(\"--tags <tags>\", \"Filter by comma-separated tags\")\n    .option(\"--status <status>\", \"Filter by status\")\n    .option(\"--is-initialized\", \"Only series with market ledger\")\n    .action(async (options, command) => {\n      const globals = getGlobalOptions(command);\n      const format = globals.json ? \"json\" : \"plain\";\n      const logger = createLogger({ verbose: globals.verbose });\n\n      logger.debug(\"Fetching series...\");\n      const data = await getSeries({\n        category: options.category,\n        tags: options.tags,\n        status: options.status,\n        isInitialized: options.isInitialized ?? undefined,\n      });\n\n      printOutput(format, {\n        data,\n        hints: buildHints({\n          available_filters: [\"--category\", \"--tags\", \"--status\", \"--is-initialized\"],\n          related: [\"predictarena series get <ticker>\", \"predictarena events list\"],\n          notes: [\"Use series tickers with events list --seriesTickers.\"],\n        }),\n      });\n    });\n\n  const get = series\n    .command(\"get <ticker>\")\n    .description(\"Get a series by ticker\")\n    .action(async (ticker, _options, command) => {\n      const globals = getGlobalOptions(command);\n      const format = globals.json ? \"json\" : \"plain\";\n      const logger = createLogger({ verbose: globals.verbose });\n\n      logger.debug(`Fetching series ${ticker}...`);\n      const data = await getSeriesByTicker(ticker);\n\n      printOutput(format, {\n        data,\n        hints: buildHints({\n          related: [\"predictarena events list --seriesTickers <ticker>\"],\n        }),\n      });\n    });\n\n  const describe = series\n    .command(\"describe\")\n    .description(\"Describe series filters and schema\")\n    .action((_options, command) => {\n      const globals = getGlobalOptions(command);\n      const format = globals.json ? \"json\" : \"plain\";\n      const data = seriesDescribeSchema();\n      printOutput(format, { data });\n    });\n\n  applyGlobalOptions(series);\n  applyGlobalOptions(get);\n  applyGlobalOptions(describe);\n}\n","import type { Command } from \"commander\";\nimport { getEvent, getEvents } from \"../api/metadata\";\nimport { applyGlobalOptions, getGlobalOptions } from \"../utils/cli\";\nimport { buildHints, eventsDescribeSchema } from \"../utils/hints\";\nimport { createLogger } from \"../utils/logger\";\nimport { printOutput } from \"../utils/output\";\n\nexport function registerEventsCommand(program: Command): void {\n  const events = program.command(\"events\").description(\"Discover events\");\n\n  const list = events\n    .command(\"list\")\n    .description(\"List events with filters\")\n    .option(\"--status <status>\", \"Event status (default: active)\")\n    .option(\"--sort <sort>\", \"Sort field (default: volume)\")\n    .option(\"--order <order>\", \"Sort order (default: desc)\")\n    .option(\"--series-tickers <tickers>\", \"Comma-separated series tickers (max 25)\")\n    .option(\"--limit <limit>\", \"Max results\")\n    .option(\"--cursor <cursor>\", \"Pagination offset\")\n    .option(\"--is-initialized\", \"Only events with market ledger\")\n    .option(\"--with-nested-markets\", \"Include nested markets\")\n    .action(async (options, command) => {\n      const globals = getGlobalOptions(command);\n      const format = globals.json ? \"json\" : \"plain\";\n      const logger = createLogger({ verbose: globals.verbose });\n\n      const status = options.status ?? \"active\";\n      const sort = options.sort ?? \"volume\";\n      const order = options.order ?? \"desc\";\n      const withNestedMarkets =\n        options.withNestedMarkets === undefined ? true : options.withNestedMarkets;\n\n      logger.debug(\"Fetching events...\");\n      const data = await getEvents({\n        status,\n        sort,\n        order,\n        limit: options.limit ? Number(options.limit) : undefined,\n        cursor: options.cursor ? Number(options.cursor) : undefined,\n        seriesTickers: options.seriesTickers,\n        isInitialized: options.isInitialized ?? undefined,\n        withNestedMarkets,\n      });\n\n      const next =\n        data.cursor !== null && data.cursor !== undefined\n          ? `predictarena events list --cursor ${data.cursor}`\n          : undefined;\n\n      printOutput(format, {\n        data,\n        pagination: { cursor: data.cursor },\n        hints: buildHints({\n          available_filters: [\n            \"--status\",\n            \"--sort\",\n            \"--order\",\n            \"--series-tickers\",\n            \"--limit\",\n            \"--cursor\",\n            \"--is-initialized\",\n            \"--with-nested-markets\",\n          ],\n          next,\n          related: [\"predictarena categories\", \"predictarena series\"],\n        }),\n      });\n    });\n\n  const get = events\n    .command(\"get <ticker>\")\n    .description(\"Get a single event by ticker\")\n    .option(\"--with-nested-markets\", \"Include nested markets\")\n    .action(async (ticker, options, command) => {\n      const globals = getGlobalOptions(command);\n      const format = globals.json ? \"json\" : \"plain\";\n      const logger = createLogger({ verbose: globals.verbose });\n\n      const withNestedMarkets =\n        options.withNestedMarkets === undefined ? true : options.withNestedMarkets;\n\n      logger.debug(`Fetching event ${ticker}...`);\n      const data = await getEvent(ticker, { withNestedMarkets });\n\n      printOutput(format, {\n        data,\n        hints: buildHints({\n          related: [\"predictarena markets list\", \"predictarena markets get <ticker>\"],\n        }),\n      });\n    });\n\n  const describe = events\n    .command(\"describe\")\n    .description(\"Describe event filters and schema\")\n    .action((_options, command) => {\n      const globals = getGlobalOptions(command);\n      const format = globals.json ? \"json\" : \"plain\";\n      const data = eventsDescribeSchema();\n      printOutput(format, { data });\n    });\n\n  applyGlobalOptions(events);\n  applyGlobalOptions(list);\n  applyGlobalOptions(get);\n  applyGlobalOptions(describe);\n}\n","import type { Command } from \"commander\";\nimport {\n  getMarket,\n  getMarketByMint,\n  getMarkets,\n  getOrderbookByTicker,\n} from \"../api/metadata\";\nimport { applyGlobalOptions, getGlobalOptions } from \"../utils/cli\";\nimport { buildHints, marketsDescribeSchema } from \"../utils/hints\";\nimport { createLogger } from \"../utils/logger\";\nimport { printOutput } from \"../utils/output\";\n\nexport function registerMarketsCommand(program: Command): void {\n  const markets = program.command(\"markets\").description(\"Discover markets\");\n\n  const list = markets\n    .command(\"list\")\n    .description(\"List markets with filters\")\n    .option(\"--status <status>\", \"Market status (default: active)\")\n    .option(\"--sort <sort>\", \"Sort field (default: volume)\")\n    .option(\"--order <order>\", \"Sort order (default: desc)\")\n    .option(\"--limit <limit>\", \"Max results\")\n    .option(\"--cursor <cursor>\", \"Pagination offset\")\n    .option(\"--is-initialized\", \"Only markets with market ledger\")\n    .action(async (options, command) => {\n      const globals = getGlobalOptions(command);\n      const format = globals.json ? \"json\" : \"plain\";\n      const logger = createLogger({ verbose: globals.verbose });\n\n      const status = options.status ?? \"active\";\n      const sort = options.sort ?? \"volume\";\n      const order = options.order ?? \"desc\";\n\n      logger.debug(\"Fetching markets...\");\n      const data = await getMarkets({\n        status,\n        sort,\n        order,\n        limit: options.limit ? Number(options.limit) : undefined,\n        cursor: options.cursor ? Number(options.cursor) : undefined,\n        isInitialized: options.isInitialized ?? undefined,\n      });\n\n      const next =\n        data.cursor !== null && data.cursor !== undefined\n          ? `predictarena markets list --cursor ${data.cursor}`\n          : undefined;\n\n      printOutput(format, {\n        data,\n        pagination: { cursor: data.cursor },\n        hints: buildHints({\n          available_filters: [\n            \"--status\",\n            \"--sort\",\n            \"--order\",\n            \"--limit\",\n            \"--cursor\",\n            \"--is-initialized\",\n          ],\n          next,\n          related: [\"predictarena markets get <ticker>\", \"predictarena markets orderbook <ticker>\"],\n        }),\n      });\n    });\n\n  const get = markets\n    .command(\"get <ticker>\")\n    .description(\"Get a single market by ticker\")\n    .action(async (ticker, _options, command) => {\n      const globals = getGlobalOptions(command);\n      const format = globals.json ? \"json\" : \"plain\";\n      const logger = createLogger({ verbose: globals.verbose });\n\n      logger.debug(`Fetching market ${ticker}...`);\n      const data = await getMarket(ticker);\n\n      printOutput(format, {\n        data,\n        hints: buildHints({\n          related: [\"predictarena markets orderbook <ticker>\"],\n        }),\n      });\n    });\n\n  const getByMint = markets\n    .command(\"get-by-mint <mint>\")\n    .description(\"Get a market by outcome mint\")\n    .action(async (mint, _options, command) => {\n      const globals = getGlobalOptions(command);\n      const format = globals.json ? \"json\" : \"plain\";\n      const logger = createLogger({ verbose: globals.verbose });\n\n      logger.debug(`Fetching market by mint ${mint}...`);\n      const data = await getMarketByMint(mint);\n\n      printOutput(format, {\n        data,\n        hints: buildHints({\n          related: [\"predictarena markets get <ticker>\"],\n        }),\n      });\n    });\n\n  const orderbook = markets\n    .command(\"orderbook <ticker>\")\n    .description(\"Get orderbook by market ticker\")\n    .action(async (ticker, _options, command) => {\n      const globals = getGlobalOptions(command);\n      const format = globals.json ? \"json\" : \"plain\";\n      const logger = createLogger({ verbose: globals.verbose });\n\n      logger.debug(`Fetching orderbook ${ticker}...`);\n      const data = await getOrderbookByTicker(ticker);\n\n      printOutput(format, {\n        data,\n        hints: buildHints({\n          related: [\"predictarena markets get <ticker>\"],\n        }),\n      });\n    });\n\n  const describe = markets\n    .command(\"describe\")\n    .description(\"Describe market filters and schema\")\n    .action((_options, command) => {\n      const globals = getGlobalOptions(command);\n      const format = globals.json ? \"json\" : \"plain\";\n      const data = marketsDescribeSchema();\n      printOutput(format, { data });\n    });\n\n  applyGlobalOptions(markets);\n  applyGlobalOptions(list);\n  applyGlobalOptions(get);\n  applyGlobalOptions(getByMint);\n  applyGlobalOptions(orderbook);\n  applyGlobalOptions(describe);\n}\n","import type { Command } from \"commander\";\nimport { getTrades } from \"../api/metadata\";\nimport { applyGlobalOptions, getGlobalOptions } from \"../utils/cli\";\nimport { buildHints, tradesDescribeSchema } from \"../utils/hints\";\nimport { createLogger } from \"../utils/logger\";\nimport { printOutput } from \"../utils/output\";\n\nexport function registerTradesCommand(program: Command): void {\n  const trades = program.command(\"trades\").description(\"Trade history\");\n\n  const list = trades\n    .command(\"list\")\n    .description(\"List trades with filters\")\n    .option(\"--ticker <ticker>\", \"Filter by market ticker\")\n    .option(\"--min-ts <timestamp>\", \"Min unix timestamp\")\n    .option(\"--max-ts <timestamp>\", \"Max unix timestamp\")\n    .option(\"--limit <limit>\", \"Limit trades (1-1000)\")\n    .option(\"--cursor <cursor>\", \"Pagination cursor (trade ID)\")\n    .action(async (options, command) => {\n      const globals = getGlobalOptions(command);\n      const format = globals.json ? \"json\" : \"plain\";\n      const logger = createLogger({ verbose: globals.verbose });\n\n      logger.debug(\"Fetching trades...\");\n      const data = await getTrades({\n        ticker: options.ticker,\n        minTs: options.minTs ? Number(options.minTs) : undefined,\n        maxTs: options.maxTs ? Number(options.maxTs) : undefined,\n        limit: options.limit ? Number(options.limit) : undefined,\n        cursor: options.cursor,\n      });\n\n      const next =\n        data.cursor !== null && data.cursor !== undefined\n          ? `predictarena trades list --cursor ${data.cursor}`\n          : undefined;\n\n      printOutput(format, {\n        data,\n        pagination: { cursor: data.cursor },\n        hints: buildHints({\n          available_filters: [\"--ticker\", \"--min-ts\", \"--max-ts\", \"--limit\", \"--cursor\"],\n          next,\n          related: [\"predictarena markets list\", \"predictarena events list\"],\n        }),\n      });\n    });\n\n  const describe = trades\n    .command(\"describe\")\n    .description(\"Describe trades filters and schema\")\n    .action((_options, command) => {\n      const globals = getGlobalOptions(command);\n      const format = globals.json ? \"json\" : \"plain\";\n      const data = tradesDescribeSchema();\n      printOutput(format, { data });\n    });\n\n  applyGlobalOptions(trades);\n  applyGlobalOptions(list);\n  applyGlobalOptions(describe);\n}\n","import type { Command } from \"commander\";\nimport { searchEvents } from \"../api/metadata\";\nimport { applyGlobalOptions, getGlobalOptions } from \"../utils/cli\";\nimport { buildHints } from \"../utils/hints\";\nimport { createLogger } from \"../utils/logger\";\nimport { printOutput } from \"../utils/output\";\n\nexport function registerSearchCommand(program: Command): void {\n  const search = program\n    .command(\"search <query>\")\n    .description(\"Search events by title or ticker\")\n    .option(\"--sort <sort>\", \"Sort field\")\n    .option(\"--order <order>\", \"Sort order\")\n    .option(\"--limit <limit>\", \"Limit results\")\n    .option(\"--cursor <cursor>\", \"Pagination offset\")\n    .option(\"--with-nested-markets\", \"Include nested markets\")\n    .option(\"--with-market-accounts\", \"Include market account info\")\n    .action(async (query, options, command) => {\n      const globals = getGlobalOptions(command);\n      const format = globals.json ? \"json\" : \"plain\";\n      const logger = createLogger({ verbose: globals.verbose });\n\n      const withNestedMarkets =\n        options.withNestedMarkets === undefined ? true : options.withNestedMarkets;\n\n      logger.debug(`Searching events for: ${query}`);\n      const data = await searchEvents({\n        q: query,\n        sort: options.sort,\n        order: options.order,\n        limit: options.limit ? Number(options.limit) : undefined,\n        cursor: options.cursor ? Number(options.cursor) : undefined,\n        withNestedMarkets,\n        withMarketAccounts: options.withMarketAccounts ?? undefined,\n      });\n\n      const next =\n        data.cursor !== null && data.cursor !== undefined\n          ? `predictarena search \"${query}\" --cursor ${data.cursor}`\n          : undefined;\n\n      printOutput(format, {\n        data,\n        pagination: { cursor: data.cursor },\n        hints: buildHints({\n          available_filters: [\n            \"--sort\",\n            \"--order\",\n            \"--limit\",\n            \"--cursor\",\n            \"--with-nested-markets\",\n            \"--with-market-accounts\",\n          ],\n          next,\n          related: [\"predictarena events list\", \"predictarena markets list\"],\n        }),\n      });\n    });\n\n  applyGlobalOptions(search);\n}\n","import fs from \"node:fs\";\nimport path from \"node:path\";\nimport { Keypair } from \"@solana/web3.js\";\n\nexport class WalletLoadError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"WalletLoadError\";\n  }\n}\n\nexport function loadKeypairFromPath(filePath: string): Keypair {\n  const resolved = path.resolve(process.cwd(), filePath);\n  if (!fs.existsSync(resolved)) {\n    throw new WalletLoadError(`Wallet file not found: ${resolved}`);\n  }\n  const stat = fs.statSync(resolved);\n  if (stat.isDirectory()) {\n    throw new WalletLoadError(`Path is a directory, expected a file: ${resolved}`);\n  }\n  const raw = fs.readFileSync(resolved, \"utf8\");\n  let arr: unknown;\n  try {\n    arr = JSON.parse(raw);\n  } catch {\n    throw new WalletLoadError(`Invalid JSON in wallet file: ${resolved}`);\n  }\n  if (!Array.isArray(arr) || arr.length !== 64) {\n    throw new WalletLoadError(\n      `Wallet file must be a JSON array of 64 numbers (secret key): ${resolved}`,\n    );\n  }\n  const secretKey = Uint8Array.from(arr as number[]);\n  return Keypair.fromSecretKey(secretKey);\n}\n","import fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { Command } from \"commander\";\nimport { Connection, Keypair, PublicKey } from \"@solana/web3.js\";\nimport { TOKEN_2022_PROGRAM_ID, TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { loadKeypairFromPath, WalletLoadError } from \"../utils/wallet\";\nimport { getSolanaRpcUrl } from \"../utils/config\";\nimport { applyGlobalOptions, getGlobalOptions } from \"../utils/cli\";\nimport { createLogger } from \"../utils/logger\";\nimport { printOutput } from \"../utils/output\";\n\nexport function registerWalletCommand(program: Command): void {\n  const wallet = program\n    .command(\"wallet\")\n    .description(\"Create or manage Solana keypair for agent signing\");\n\n  const create = wallet\n    .command(\"create <path>\")\n    .description(\"Generate keypair, save to file, print public key for funding\")\n    .action(async (pathArg: string, _options, command) => {\n      const globals = getGlobalOptions(command);\n      const logger = createLogger({ verbose: globals.verbose });\n\n      const resolved = path.resolve(process.cwd(), pathArg);\n\n      if (fs.existsSync(resolved)) {\n        const stat = fs.statSync(resolved);\n        if (stat.isDirectory()) {\n          logger.error(\"Path must be a file, not a directory.\");\n          process.exit(1);\n        }\n      }\n\n      const dir = path.dirname(resolved);\n      if (dir !== \".\") {\n        fs.mkdirSync(dir, { recursive: true });\n      }\n\n      logger.debug(`Generating keypair and writing to ${resolved}`);\n      const keypair = Keypair.generate();\n      fs.writeFileSync(\n        resolved,\n        JSON.stringify(Array.from(keypair.secretKey)),\n        \"utf8\",\n      );\n\n      const publicKey = keypair.publicKey.toBase58();\n\n      if (globals.json) {\n        printOutput(\"json\", {\n          data: { publicKey, path: resolved },\n        });\n        return;\n      }\n\n      console.log(`Wallet saved to ${resolved}`);\n      console.log(`Public key: ${publicKey}`);\n      console.log(\"Fund this address to use it.\");\n    });\n\n  const balance = wallet\n    .command(\"balance\")\n    .description(\n      \"Show SOL and token balances. Use --wallet (keypair path) or --pubkey (read-only address).\",\n    )\n    .option(\"--wallet <path>\", \"Path to wallet keypair JSON file\")\n    .option(\"--pubkey <address>\", \"Solana public key (read-only)\")\n    .option(\"--rpc <url>\", \"Solana RPC URL (or set SOLANA_RPC_URL)\")\n    .action(async (options, command) => {\n      const globals = getGlobalOptions(command);\n      const logger = createLogger({ verbose: globals.verbose });\n\n      let address: string;\n      if (options.pubkey) {\n        try {\n          address = new PublicKey(options.pubkey).toBase58();\n        } catch {\n          logger.error(\"Invalid --pubkey: must be a valid Solana base58 address.\");\n          process.exit(1);\n        }\n      } else {\n        const walletPath =\n          options.wallet ||\n          process.env.PREDICTARENA_WALLET ||\n          process.env.WALLET_PATH;\n        if (!walletPath) {\n          logger.error(\"Use --wallet <path> or --pubkey <address> (or set PREDICTARENA_WALLET).\");\n          process.exit(1);\n        }\n        try {\n          const keypair = loadKeypairFromPath(walletPath);\n          address = keypair.publicKey.toBase58();\n        } catch (err) {\n          if (err instanceof WalletLoadError) {\n            logger.error(err.message);\n            process.exit(1);\n          }\n          throw err;\n        }\n      }\n\n      const rpcUrl = options.rpc || getSolanaRpcUrl();\n      if (!rpcUrl) {\n        logger.error(\"RPC URL required: use --rpc <url> or set SOLANA_RPC_URL.\");\n        process.exit(1);\n      }\n\n      const connection = new Connection(rpcUrl);\n      const owner = new PublicKey(address);\n\n      const [solBalance, tokenAccountsLegacy, tokenAccounts2022] =\n        await Promise.all([\n          connection.getBalance(owner),\n          connection.getParsedTokenAccountsByOwner(owner, {\n            programId: TOKEN_PROGRAM_ID,\n          }),\n          connection.getParsedTokenAccountsByOwner(owner, {\n            programId: TOKEN_2022_PROGRAM_ID,\n          }),\n        ]);\n\n      const tokens: { mint: string; rawAmount: string; decimals: number; uiAmount: number | null }[] = [];\n      for (const { account } of [...tokenAccountsLegacy.value, ...tokenAccounts2022.value]) {\n        const info = account.data.parsed?.info;\n        if (!info?.mint || !info?.tokenAmount) continue;\n        const amt = info.tokenAmount;\n        const raw = amt.amount ?? \"0\";\n        if (Number(raw) <= 0) continue;\n        tokens.push({\n          mint: info.mint,\n          rawAmount: raw,\n          decimals: amt.decimals ?? 6,\n          uiAmount: amt.uiAmount ?? null,\n        });\n      }\n\n      const data = {\n        address,\n        sol: {\n          lamports: solBalance,\n          sol: solBalance / 1e9,\n        },\n        tokens,\n      };\n\n      if (globals.json) {\n        printOutput(\"json\", { data });\n        return;\n      }\n\n      console.log(`Address: ${address}`);\n      console.log(`SOL: ${data.sol.sol} (${data.sol.lamports} lamports)`);\n      if (tokens.length > 0) {\n        console.log(\"Tokens:\");\n        for (const t of tokens) {\n          const ui = t.uiAmount != null ? t.uiAmount.toFixed(6) : t.rawAmount;\n          console.log(`  ${t.mint}: ${ui}`);\n        }\n      }\n    });\n\n  applyGlobalOptions(create);\n  applyGlobalOptions(balance);\n}\n","const KNOWN_MINTS: Record<string, string> = {\n  So11111111111111111111111111111111111111112: \"SOL\",\n  EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v: \"USDC\",\n  CASHx9KJUStyftLFWGvEVf59SGeG9sh5FfcnZMVPCASH: \"CASH\",\n};\n\n/** Decimals for known mints (SOL=9, USDC=6, CASH=6). Used when order.routePlan is missing. */\nconst KNOWN_MINT_DECIMALS: Record<string, number> = {\n  So11111111111111111111111111111111111111112: 9,\n  EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v: 6,\n  CASHx9KJUStyftLFWGvEVf59SGeG9sh5FfcnZMVPCASH: 6,\n};\n\nexport function getMintLabel(mint: string, fallbackToShort = true): string {\n  const label = KNOWN_MINTS[mint];\n  if (label) return label;\n  if (fallbackToShort && mint.length >= 8) return `${mint.slice(0, 8)}…`;\n  return mint;\n}\n\nexport function getMintDecimals(mint: string): number | undefined {\n  return KNOWN_MINT_DECIMALS[mint];\n}\n","import { Connection, PublicKey } from \"@solana/web3.js\";\n\n/**\n * SPL Token (and Token-2022) mint account layout: decimals is a u8 at offset 41.\n * Layout: mint_authority (COption<Pubkey>) 33 bytes, supply (u64) 8 bytes, decimals (u8) 1 byte.\n */\nconst MINT_DECIMALS_OFFSET = 41;\n\n/**\n * Fetch decimals for a mint from chain via getAccountInfo. Returns undefined if account missing or not a valid mint.\n */\nexport async function getMintDecimalsOnChain(\n  connection: Connection,\n  mintAddress: string,\n): Promise<number | undefined> {\n  try {\n    const accountInfo = await connection.getAccountInfo(\n      new PublicKey(mintAddress),\n    );\n    if (!accountInfo?.data || accountInfo.data.length < MINT_DECIMALS_OFFSET + 1)\n      return undefined;\n    return accountInfo.data[MINT_DECIMALS_OFFSET];\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Fetch decimals for multiple mints. Returns a map of mint -> decimals for those that succeeded.\n */\nexport async function getMintDecimalsOnChainBatch(\n  connection: Connection,\n  mintAddresses: string[],\n): Promise<Record<string, number>> {\n  const unique = [...new Set(mintAddresses)];\n  const results = await Promise.all(\n    unique.map(async (mint) => {\n      const decimals = await getMintDecimalsOnChain(connection, mint);\n      return { mint, decimals };\n    }),\n  );\n  const map: Record<string, number> = {};\n  for (const { mint, decimals } of results) {\n    if (decimals !== undefined) map[mint] = decimals;\n  }\n  return map;\n}\n","import { Connection, Keypair, VersionedTransaction } from \"@solana/web3.js\";\nimport type { OrderResponse } from \"../types/trade\";\n\nexport class TransactionParseError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"TransactionParseError\";\n  }\n}\n\nexport class QuoteExpiredError extends Error {\n  constructor(\n    message: string,\n    public lastValidBlockHeight: number,\n    public currentBlockHeight: number,\n  ) {\n    super(message);\n    this.name = \"QuoteExpiredError\";\n  }\n}\n\n/**\n * Deserialize base64-encoded transaction from DFlow order response.\n * Throws TransactionParseError if order has no transaction or invalid base64.\n */\nexport function parseTransactionFromOrder(order: OrderResponse): VersionedTransaction {\n  const raw = order.transaction;\n  if (!raw || typeof raw !== \"string\") {\n    throw new TransactionParseError(\n      \"Order response did not include a transaction; ensure userPublicKey was provided and the order is valid.\",\n    );\n  }\n  let buffer: Buffer;\n  try {\n    buffer = Buffer.from(raw, \"base64\");\n  } catch {\n    throw new TransactionParseError(\"Order transaction is not valid base64.\");\n  }\n  if (buffer.length === 0) {\n    throw new TransactionParseError(\"Order transaction is empty.\");\n  }\n  try {\n    return VersionedTransaction.deserialize(buffer);\n  } catch (err) {\n    throw new TransactionParseError(\n      `Failed to deserialize transaction: ${err instanceof Error ? err.message : String(err)}`,\n    );\n  }\n}\n\nexport interface SignAndSendOptions {\n  skipPreflight?: boolean;\n  commitment?: \"processed\" | \"confirmed\" | \"finalized\";\n  /** If true, only send the transaction; do not wait for confirmation. */\n  skipConfirm?: boolean;\n}\n\n/**\n * Sign the transaction with the keypair and submit to the RPC.\n * Confirms using blockheight strategy when lastValidBlockHeight is set.\n * Throws QuoteExpiredError if current block height >= lastValidBlockHeight.\n */\nexport async function signAndSend(\n  connection: Connection,\n  order: OrderResponse,\n  keypair: Keypair,\n  options: SignAndSendOptions = {},\n): Promise<string> {\n  const lastValid = order.lastValidBlockHeight;\n  if (lastValid != null) {\n    const current = await connection.getBlockHeight(\"confirmed\");\n    if (current >= lastValid) {\n      throw new QuoteExpiredError(\n        `Quote expired: current block height ${current} >= lastValidBlockHeight ${lastValid}. Request a fresh order.`,\n        lastValid,\n        current,\n      );\n    }\n  }\n\n  const tx = parseTransactionFromOrder(order);\n  tx.sign([keypair]);\n  const serialized = Buffer.from(tx.serialize());\n\n  const skipPreflight = options.skipPreflight ?? false;\n  const commitment = options.commitment ?? \"confirmed\";\n  const skipConfirm = options.skipConfirm ?? false;\n\n  const signature = await connection.sendRawTransaction(serialized, {\n    skipPreflight,\n    preflightCommitment: commitment,\n  });\n\n  if (skipConfirm) return signature;\n\n  if (lastValid != null) {\n    const blockhash = tx.message.recentBlockhash;\n    await connection.confirmTransaction(\n      { signature, lastValidBlockHeight: lastValid, blockhash },\n      commitment,\n    );\n    return signature;\n  }\n\n  await connection.confirmTransaction(signature, commitment);\n  return signature;\n}\n","import type { Command } from \"commander\";\nimport { Connection } from \"@solana/web3.js\";\nimport { getOrder, getOrderStatus } from \"../api/trade\";\nimport { getMarketByMint } from \"../api/metadata\";\nimport { ApiError } from \"../api/client\";\nimport { loadKeypairFromPath, WalletLoadError } from \"../utils/wallet\";\nimport { getMintLabel, getMintDecimals } from \"../utils/mintLabels\";\nimport { getMintDecimalsOnChainBatch } from \"../utils/mintDecimals\";\nimport { getSolanaRpcUrl } from \"../utils/config\";\nimport { applyGlobalOptions, getGlobalOptions } from \"../utils/cli\";\nimport { createLogger } from \"../utils/logger\";\nimport { printOutput } from \"../utils/output\";\nimport {\n  signAndSend,\n  QuoteExpiredError,\n  TransactionParseError,\n} from \"../trading/signAndSend\";\nimport type { OrderResponse, RoutePlanLeg } from \"../types/trade\";\n\ninterface MarketContext {\n  marketTicker: string;\n  eventTicker: string;\n  marketTitle: string;\n}\n\nasync function resolveMarketContext(\n  outputMint: string,\n  inputMint: string,\n): Promise<MarketContext | null> {\n  for (const mint of [outputMint, inputMint]) {\n    try {\n      const market = await getMarketByMint(mint);\n      return {\n        marketTicker: market.ticker,\n        eventTicker: market.eventTicker,\n        marketTitle: market.title,\n      };\n    } catch (err) {\n      if (err instanceof ApiError && err.status === 404) continue;\n      throw err;\n    }\n  }\n  return null;\n}\n\nfunction getOrderDecimals(\n  order: OrderResponse,\n  decimalsMap?: Record<string, number>,\n): {\n  inputMintDecimals: number | undefined;\n  outputMintDecimals: number | undefined;\n} {\n  const legs = order.routePlan;\n  if (legs?.length) {\n    const first = legs[0] as RoutePlanLeg;\n    const last = legs[legs.length - 1] as RoutePlanLeg;\n    return {\n      inputMintDecimals: first.inputMintDecimals,\n      outputMintDecimals: last.outputMintDecimals,\n    };\n  }\n  return {\n    inputMintDecimals:\n      decimalsMap?.[order.inputMint] ?? getMintDecimals(order.inputMint),\n    outputMintDecimals:\n      decimalsMap?.[order.outputMint] ?? getMintDecimals(order.outputMint),\n  };\n}\n\nfunction buildTradeSummary(\n  order: OrderResponse,\n  market: MarketContext | null,\n): string {\n  const inLabel = getMintLabel(order.inputMint);\n  const outLabel = getMintLabel(order.outputMint);\n  const mode = order.executionMode;\n  let line = `Trade: ${order.inAmount} ${inLabel} → ${order.outAmount} ${outLabel} [${mode}]`;\n  if (market) {\n    line += `\\nMarket: ${market.eventTicker} / ${market.marketTicker}`;\n  }\n  return line;\n}\n\nfunction buildTradeData(\n  order: OrderResponse,\n  market: MarketContext | null,\n  decimalsMap?: Record<string, number>,\n): Record<string, unknown> {\n  const { inputMintDecimals, outputMintDecimals } = getOrderDecimals(\n    order,\n    decimalsMap,\n  );\n  const trade: Record<string, unknown> = {\n    inputMint: order.inputMint,\n    outputMint: order.outputMint,\n    inAmount: order.inAmount,\n    outAmount: order.outAmount,\n    inputMintDecimals: inputMintDecimals ?? undefined,\n    outputMintDecimals: outputMintDecimals ?? undefined,\n    executionMode: order.executionMode,\n    minOutAmount: order.minOutAmount,\n    priceImpactPct: order.priceImpactPct,\n    lastValidBlockHeight: order.lastValidBlockHeight ?? undefined,\n  };\n  if (market) {\n    trade.marketTicker = market.marketTicker;\n    trade.eventTicker = market.eventTicker;\n    trade.marketTitle = market.marketTitle;\n  }\n  return trade;\n}\n\nexport function registerTradeCommand(program: Command): void {\n  const trade = program\n    .command(\"trade\")\n    .description(\"Execute a swap (input mint → output mint) using a wallet keypair\")\n    .requiredOption(\"--wallet <path>\", \"Path to wallet keypair JSON file\")\n    .requiredOption(\"--input-mint <mint>\", \"Input token mint address\")\n    .requiredOption(\"--output-mint <mint>\", \"Output token mint address\")\n    .requiredOption(\"--amount <raw>\", \"Input amount (raw integer, e.g. 1000000 for 1 USDC)\", (v) => Number(v))\n    .option(\"--slippage-bps <bps>\", \"Slippage in basis points (default: 50)\", (v) => (v === \"auto\" ? \"auto\" : Number(v)), 50)\n    .option(\"--priority <level>\", \"Priority fee: auto, medium, high, veryHigh, disabled, or lamports number\", (v) => ([\"auto\", \"medium\", \"high\", \"veryHigh\", \"disabled\"].includes(v) ? v : Number(v)), \"auto\")\n    .option(\"--rpc <url>\", \"Solana RPC URL (or set SOLANA_RPC_URL / PREDICTARENA_RPC_URL)\")\n    .option(\"--dry-run\", \"Fetch order and print quote only; do not sign or send\")\n    .option(\"--no-confirm\", \"Send transaction but do not wait for confirmation\")\n    .option(\"--skip-preflight\", \"Skip preflight simulation (default: false)\")\n    .action(async (options, command) => {\n      const globals = getGlobalOptions(command);\n      const logger = createLogger({ verbose: globals.verbose });\n      const format = globals.json ? \"json\" : \"plain\";\n\n      const walletPath =\n        options.wallet ||\n        process.env.PREDICTARENA_WALLET ||\n        process.env.WALLET_PATH;\n      if (!walletPath) {\n        logger.error(\"Wallet path required: use --wallet <path> or set PREDICTARENA_WALLET.\");\n        process.exit(1);\n      }\n\n      let keypair;\n      try {\n        keypair = loadKeypairFromPath(walletPath);\n      } catch (err) {\n        if (err instanceof WalletLoadError) {\n          logger.error(err.message);\n          process.exit(1);\n        }\n        throw err;\n      }\n\n      const userPublicKey = keypair.publicKey.toBase58();\n      const slippageBps = options.slippageBps;\n      const prioritizationFeeLamports = options.priority;\n\n      logger.debug(\"Fetching order...\");\n      let order: OrderResponse;\n      try {\n        order = await getOrder({\n          inputMint: options.inputMint,\n          outputMint: options.outputMint,\n          amount: options.amount,\n          userPublicKey,\n          slippageBps: slippageBps === \"auto\" ? \"auto\" : slippageBps,\n          prioritizationFeeLamports:\n            typeof prioritizationFeeLamports === \"string\"\n              ? prioritizationFeeLamports\n              : prioritizationFeeLamports,\n        });\n      } catch (err) {\n        if (err instanceof ApiError) {\n          logger.error(`Order failed (${err.status}): ${JSON.stringify(err.body)}`);\n          process.exit(1);\n        }\n        throw err;\n      }\n\n      let decimalsMap: Record<string, number> = {};\n      const rpcUrlForDecimals = options.rpc || getSolanaRpcUrl();\n      if (rpcUrlForDecimals) {\n        try {\n          const connectionForDecimals = new Connection(rpcUrlForDecimals);\n          decimalsMap = await getMintDecimalsOnChainBatch(connectionForDecimals, [\n            order.inputMint,\n            order.outputMint,\n          ]);\n        } catch {\n          // non-fatal: we still have routePlan or known mints\n        }\n      }\n\n      let market: MarketContext | null = null;\n      try {\n        market = await resolveMarketContext(order.outputMint, order.inputMint);\n      } catch (err) {\n        if (err instanceof ApiError && err.status !== 404) {\n          logger.error(`Market lookup failed: ${err.message}`);\n          process.exit(1);\n        }\n      }\n\n      const summary = buildTradeSummary(order, market);\n      const tradeData = buildTradeData(order, market, decimalsMap);\n\n      if (options.dryRun) {\n        if (format === \"json\") {\n          printOutput(\"json\", {\n            data: {\n              trade: tradeData,\n              dryRun: true,\n              quote: {\n                minOutAmount: order.minOutAmount,\n                priceImpactPct: order.priceImpactPct,\n                lastValidBlockHeight: order.lastValidBlockHeight,\n              },\n              message: \"Dry run — no transaction signed or sent.\",\n            },\n          });\n        } else {\n          console.log(summary);\n          console.log(`Min out amount: ${order.minOutAmount}`);\n          console.log(`Price impact: ${order.priceImpactPct}%`);\n          if (order.lastValidBlockHeight != null) {\n            console.log(`Last valid block height: ${order.lastValidBlockHeight}`);\n          }\n          console.log(\"Dry run — no transaction signed or sent.\");\n        }\n        return;\n      }\n\n      if (!order.transaction) {\n        logger.error(\n          \"Order response did not include a transaction. Check userPublicKey and order parameters.\",\n        );\n        process.exit(1);\n      }\n\n      const rpcUrl = options.rpc || getSolanaRpcUrl();\n      if (!rpcUrl) {\n        logger.error(\n          \"RPC URL required: use --rpc <url> or set SOLANA_RPC_URL / PREDICTARENA_RPC_URL.\",\n        );\n        process.exit(1);\n      }\n\n      const skipConfirm = options.confirm === false;\n      if (!skipConfirm && order.lastValidBlockHeight == null) {\n        logger.error(\n          \"Order has no lastValidBlockHeight; use --no-confirm to send without confirmation.\",\n        );\n        process.exit(1);\n      }\n\n      const connection = new Connection(rpcUrl, \"confirmed\");\n\n      try {\n        const signature = await signAndSend(connection, order, keypair, {\n          skipPreflight: options.skipPreflight ?? false,\n          commitment: \"confirmed\",\n          skipConfirm,\n        });\n\n        let orderStatus: unknown;\n        try {\n          orderStatus = await getOrderStatus(\n            signature,\n            order.lastValidBlockHeight ?? undefined,\n          );\n        } catch {\n          orderStatus = undefined;\n        }\n\n        if (format === \"json\") {\n          printOutput(\"json\", {\n            data: {\n              trade: tradeData,\n              result: {\n                signature,\n                confirmed: !skipConfirm,\n                orderStatus: orderStatus ?? undefined,\n              },\n            },\n          });\n        } else {\n          console.log(summary);\n          console.log(`Signature: ${signature}`);\n          console.log(skipConfirm ? \"Sent (not confirmed).\" : \"Confirmed.\");\n        }\n      } catch (err) {\n        if (err instanceof QuoteExpiredError) {\n          logger.error(err.message);\n          process.exit(1);\n        }\n        if (err instanceof TransactionParseError) {\n          logger.error(err.message);\n          process.exit(1);\n        }\n        throw err;\n      }\n    });\n\n  applyGlobalOptions(trade);\n}\n","import { Connection, PublicKey } from \"@solana/web3.js\";\nimport { TOKEN_2022_PROGRAM_ID } from \"@solana/spl-token\";\nimport { filterOutcomeMints, getMarketsBatch } from \"./metadata\";\nimport type { SingleMarketResponse } from \"../types/domain\";\n\nexport interface UserPosition {\n  mint: string;\n  rawBalance: string;\n  decimals: number;\n  /** Human-readable balance (may be null if too small). */\n  uiAmount: number | null;\n  position: \"YES\" | \"NO\" | \"UNKNOWN\";\n  market: SingleMarketResponse | null;\n}\n\ninterface TokenBalance {\n  mint: string;\n  rawBalance: string;\n  decimals: number;\n  uiAmount: number | null;\n}\n\n/**\n * Fetch prediction market positions for a wallet.\n * Uses Solana RPC (Token-2022 accounts) + DFlow Metadata API (filter outcome mints, markets batch).\n */\nexport async function getPositions(\n  connection: Connection,\n  walletPublicKey: string | PublicKey,\n): Promise<UserPosition[]> {\n  const owner = typeof walletPublicKey === \"string\"\n    ? new PublicKey(walletPublicKey)\n    : walletPublicKey;\n\n  const parsed = await connection.getParsedTokenAccountsByOwner(owner, {\n    programId: TOKEN_2022_PROGRAM_ID,\n  });\n\n  const userTokens: TokenBalance[] = parsed.value.map(({ account }) => {\n    const info = account.data.parsed?.info;\n    if (!info?.mint || !info?.tokenAmount) {\n      return null;\n    }\n    const amount = info.tokenAmount;\n    const rawBalance = amount.amount ?? \"0\";\n    const balanceNum = Number(rawBalance);\n    if (balanceNum <= 0) return null;\n    return {\n      mint: info.mint,\n      rawBalance,\n      decimals: amount.decimals ?? 6,\n      uiAmount: amount.uiAmount ?? null,\n    };\n  }).filter((t): t is TokenBalance => t !== null);\n\n  if (userTokens.length === 0) return [];\n\n  const allMints = userTokens.map((t) => t.mint);\n  const { outcomeMints } = await filterOutcomeMints(allMints);\n  if (outcomeMints.length === 0) return [];\n\n  const outcomeTokens = userTokens.filter((t) => outcomeMints.includes(t.mint));\n  const { markets } = await getMarketsBatch({ mints: outcomeMints });\n\n  const marketsByMint = new Map<string, SingleMarketResponse>();\n  for (const market of markets) {\n    const accounts = Object.values(market.accounts ?? {});\n    for (const acc of accounts) {\n      if (acc.yesMint) marketsByMint.set(acc.yesMint, market);\n      if (acc.noMint) marketsByMint.set(acc.noMint, market);\n    }\n  }\n\n  return outcomeTokens.map((token): UserPosition => {\n    const market = marketsByMint.get(token.mint) ?? null;\n    if (!market) {\n      return {\n        mint: token.mint,\n        rawBalance: token.rawBalance,\n        decimals: token.decimals,\n        uiAmount: token.uiAmount,\n        position: \"UNKNOWN\",\n        market: null,\n      };\n    }\n    const accounts = Object.values(market.accounts ?? {});\n    const isYes = accounts.some((a) => a.yesMint === token.mint);\n    const isNo = accounts.some((a) => a.noMint === token.mint);\n    const position = isYes ? \"YES\" : isNo ? \"NO\" : \"UNKNOWN\";\n    return {\n      mint: token.mint,\n      rawBalance: token.rawBalance,\n      decimals: token.decimals,\n      uiAmount: token.uiAmount,\n      position,\n      market,\n    };\n  });\n}\n","import type { Command } from \"commander\";\nimport { Connection, PublicKey } from \"@solana/web3.js\";\nimport { getPositions, type UserPosition } from \"../api/positions\";\nimport { loadKeypairFromPath, WalletLoadError } from \"../utils/wallet\";\nimport { getSolanaRpcUrl } from \"../utils/config\";\nimport { getGlobalOptions } from \"../utils/cli\";\nimport { createLogger } from \"../utils/logger\";\nimport { printOutput } from \"../utils/output\";\n\nfunction formatPositionLine(p: UserPosition): string {\n  const ticker = p.market?.ticker ?? \"—\";\n  const title = p.market?.title ?? p.mint.slice(0, 8) + \"…\";\n  const side = p.position;\n  const bal = p.uiAmount != null ? p.uiAmount.toFixed(4) : p.rawBalance;\n  return `${ticker}  ${side.padEnd(7)}  ${bal}  ${title}`;\n}\n\nfunction parsePubkey(address: string): string {\n  try {\n    const key = new PublicKey(address);\n    return key.toBase58();\n  } catch {\n    return \"\";\n  }\n}\n\nexport function registerPositionsCommand(program: Command): void {\n  const positions = program\n    .command(\"positions\")\n    .description(\n      \"List prediction market positions (Token-2022 outcome tokens). Use --wallet for your keypair or --pubkey for read-only lookup of any address.\",\n    )\n    .option(\"--wallet <path>\", \"Path to wallet keypair JSON file\")\n    .option(\"--pubkey <address>\", \"Solana public key (read-only; no keypair needed)\")\n    .option(\"--rpc <url>\", \"Solana RPC URL (or set SOLANA_RPC_URL / PREDICTARENA_RPC_URL)\")\n    .action(async (options, command) => {\n      const globals = getGlobalOptions(command);\n      const format = globals.json ? \"json\" : \"plain\";\n      const logger = createLogger({ verbose: globals.verbose });\n\n      let walletPublicKey: string;\n\n      if (options.pubkey) {\n        walletPublicKey = parsePubkey(options.pubkey);\n        if (!walletPublicKey) {\n          logger.error(\"Invalid --pubkey: must be a valid Solana base58 address.\");\n          process.exit(1);\n        }\n        logger.debug(`Read-only lookup for pubkey ${walletPublicKey}...`);\n      } else {\n        const walletPath =\n          options.wallet ||\n          process.env.PREDICTARENA_WALLET ||\n          process.env.WALLET_PATH;\n        if (!walletPath) {\n          logger.error(\"Use --wallet <path> or --pubkey <address> (or set PREDICTARENA_WALLET).\");\n          process.exit(1);\n        }\n        try {\n          const keypair = loadKeypairFromPath(walletPath);\n          walletPublicKey = keypair.publicKey.toBase58();\n        } catch (err) {\n          if (err instanceof WalletLoadError) {\n            logger.error(err.message);\n            process.exit(1);\n          }\n          throw err;\n        }\n        logger.debug(`Fetching positions for ${walletPublicKey}...`);\n      }\n\n      const rpcUrl = options.rpc || getSolanaRpcUrl();\n      if (!rpcUrl) {\n        logger.error(\"RPC URL required: use --rpc <url> or set SOLANA_RPC_URL.\");\n        process.exit(1);\n      }\n\n      const connection = new Connection(rpcUrl);\n\n      let list: UserPosition[];\n      try {\n        list = await getPositions(connection, walletPublicKey);\n      } catch (err) {\n        logger.error(err instanceof Error ? err.message : String(err));\n        process.exit(1);\n      }\n\n      if (format === \"json\") {\n        printOutput(\"json\", {\n          data: {\n            wallet: walletPublicKey,\n            positions: list,\n          },\n        });\n        return;\n      }\n\n      if (list.length === 0) {\n        console.log(\"No prediction market positions found.\");\n        return;\n      }\n\n      console.log(\"Ticker   Side     Balance  Market\");\n      console.log(\"------   ----     -------  ------\");\n      for (const p of list) {\n        console.log(formatPositionLine(p));\n      }\n    });\n}\n","#!/usr/bin/env node\nimport { Command } from \"commander\";\nimport { registerCategoriesCommand } from \"./commands/categories\";\nimport { registerSeriesCommand } from \"./commands/series\";\nimport { registerEventsCommand } from \"./commands/events\";\nimport { registerMarketsCommand } from \"./commands/markets\";\nimport { registerTradesCommand } from \"./commands/trades\";\nimport { registerSearchCommand } from \"./commands/search\";\nimport { registerWalletCommand } from \"./commands/wallet\";\nimport { registerTradeCommand } from \"./commands/trade\";\nimport { registerPositionsCommand } from \"./commands/positions\";\n\nconst program = new Command();\n\nprogram\n  .name(\"predictarena\")\n  .description(\"PredictArena CLI for prediction markets\")\n  .option(\"--json\", \"Output full JSON payloads\")\n  .option(\"--verbose\", \"Enable verbose logging\");\n\nregisterCategoriesCommand(program);\nregisterSeriesCommand(program);\nregisterEventsCommand(program);\nregisterMarketsCommand(program);\nregisterTradesCommand(program);\nregisterSearchCommand(program);\nregisterWalletCommand(program);\nregisterTradeCommand(program);\nregisterPositionsCommand(program);\n\nprogram.parseAsync(process.argv);\n"],"mappings":"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"}
{"version":3,"file":"index.js","sources":["../src/utils/shallowEqual.ts","../src/utils/deprecationWarning.ts","../src/validators/generated/index.ts","../src/validators/matchesPattern.ts","../src/validators/buildMatchMemberExpression.ts","../src/validators/react/isReactComponent.ts","../src/validators/react/isCompatTag.ts","../src/validators/isType.ts","../src/validators/isPlaceholderType.ts","../src/validators/is.ts","../src/validators/isValidIdentifier.ts","../src/constants/index.ts","../src/definitions/utils.ts","../src/definitions/core.ts","../src/definitions/flow.ts","../src/definitions/jsx.ts","../src/definitions/placeholders.ts","../src/definitions/misc.ts","../src/definitions/experimental.ts","../src/definitions/typescript.ts","../src/definitions/deprecated-aliases.ts","../src/definitions/index.ts","../src/validators/validate.ts","../src/builders/generated/lowercase.ts","../src/builders/generated/uppercase.ts","../src/utils/react/cleanJSXElementLiteralChild.ts","../src/builders/react/buildChildren.ts","../src/validators/isNode.ts","../src/asserts/assertNode.ts","../src/asserts/generated/index.ts","../src/builders/flow/createTypeAnnotationBasedOnTypeof.ts","../src/modifications/flow/removeTypeDuplicates.ts","../src/builders/flow/createFlowUnionType.ts","../src/modifications/typescript/removeTypeDuplicates.ts","../src/builders/typescript/createTSUnionType.ts","../src/builders/productions.ts","../src/clone/cloneNode.ts","../src/clone/clone.ts","../src/clone/cloneDeep.ts","../src/clone/cloneDeepWithoutLoc.ts","../src/clone/cloneWithoutLoc.ts","../src/comments/addComments.ts","../src/comments/addComment.ts","../src/utils/inherit.ts","../src/comments/inheritInnerComments.ts","../src/comments/inheritLeadingComments.ts","../src/comments/inheritTrailingComments.ts","../src/comments/inheritsComments.ts","../src/comments/removeComments.ts","../src/constants/generated/index.ts","../src/converters/toBlock.ts","../src/converters/ensureBlock.ts","../src/converters/toIdentifier.ts","../src/converters/toBindingIdentifierName.ts","../src/converters/toComputedKey.ts","../src/converters/toExpression.ts","../src/traverse/traverseFast.ts","../src/modifications/removeProperties.ts","../src/modifications/removePropertiesDeep.ts","../src/converters/toKeyAlias.ts","../src/converters/toStatement.ts","../src/converters/valueToNode.ts","../src/modifications/appendToMemberExpression.ts","../src/modifications/inherits.ts","../src/modifications/prependToMemberExpression.ts","../src/retrievers/getAssignmentIdentifiers.ts","../src/retrievers/getBindingIdentifiers.ts","../src/retrievers/getOuterBindingIdentifiers.ts","../src/retrievers/getFunctionName.ts","../src/traverse/traverse.ts","../src/validators/isBinding.ts","../src/validators/isLet.ts","../src/validators/isBlockScoped.ts","../src/validators/isImmutable.ts","../src/validators/isNodesEquivalent.ts","../src/validators/isReferenced.ts","../src/validators/isScope.ts","../src/validators/isSpecifierDefault.ts","../src/validators/isValidES3Identifier.ts","../src/validators/isVar.ts","../src/index.ts"],"sourcesContent":["export default function shallowEqual<T extends object>(\n  actual: object,\n  expected: T,\n): actual is T {\n  const keys = Object.keys(expected) as (keyof T)[];\n\n  for (const key of keys) {\n    if (\n      // @ts-expect-error maybe we should check whether key exists first\n      actual[key] !== expected[key]\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","const warnings = new Set();\n\nexport default function deprecationWarning(\n  oldName: string,\n  newName: string,\n  prefix: string = \"\",\n  cacheKey: string = oldName,\n) {\n  if (warnings.has(cacheKey)) return;\n  warnings.add(cacheKey);\n\n  const { internal, trace } = captureShortStackTrace(1, 2);\n  if (internal) {\n    // If usage comes from an internal package, there is no point in warning because\n    // 1. The new version of the package will already use the new API\n    // 2. When the deprecation will become an error (in a future major version), users\n    //    will have to update every package anyway.\n    return;\n  }\n  console.warn(\n    `${prefix}\\`${oldName}\\` has been deprecated, please migrate to \\`${newName}\\`\\n${trace}`,\n  );\n}\n\nfunction captureShortStackTrace(skip: number, length: number) {\n  const { stackTraceLimit, prepareStackTrace } = Error;\n  let stackTrace: NodeJS.CallSite[];\n  // We add 1 to also take into account this function.\n  Error.stackTraceLimit = 1 + skip + length;\n  Error.prepareStackTrace = function (err, stack) {\n    stackTrace = stack;\n  };\n  // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n  new Error().stack;\n  Error.stackTraceLimit = stackTraceLimit;\n  Error.prepareStackTrace = prepareStackTrace;\n\n  if (!stackTrace!) return { internal: false, trace: \"\" };\n\n  const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);\n  return {\n    internal: /[\\\\/]@babel[\\\\/]/.test(shortStackTrace[1].getFileName()!),\n    // eslint-disable-next-line @typescript-eslint/no-base-to-string\n    trace: shortStackTrace.map(frame => `    at ${frame}`).join(\"\\n\"),\n  };\n}\n","/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\n\n/* eslint-disable no-fallthrough */\n\nimport shallowEqual from \"../../utils/shallowEqual.ts\";\nimport type * as t from \"../../index.ts\";\nimport deprecationWarning from \"../../utils/deprecationWarning.ts\";\n\ntype Options<Obj> = Partial<{\n  [Prop in Exclude<keyof Obj, \"type\">]: Obj[Prop] extends t.Node\n    ? t.Node\n    : Obj[Prop] extends t.Node[]\n      ? t.Node[]\n      : Obj[Prop];\n}>;\n\nexport function isArrayExpression(\n  node: t.Node | null | undefined,\n): node is t.ArrayExpression;\nexport function isArrayExpression<Opts extends Options<t.ArrayExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ArrayExpression & Opts;\nexport function isArrayExpression<Opts extends Options<t.ArrayExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ArrayExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isAssignmentExpression(\n  node: t.Node | null | undefined,\n): node is t.AssignmentExpression;\nexport function isAssignmentExpression<\n  Opts extends Options<t.AssignmentExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.AssignmentExpression & Opts;\nexport function isAssignmentExpression<\n  Opts extends Options<t.AssignmentExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"AssignmentExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBinaryExpression(\n  node: t.Node | null | undefined,\n): node is t.BinaryExpression;\nexport function isBinaryExpression<Opts extends Options<t.BinaryExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BinaryExpression & Opts;\nexport function isBinaryExpression<Opts extends Options<t.BinaryExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BinaryExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isInterpreterDirective(\n  node: t.Node | null | undefined,\n): node is t.InterpreterDirective;\nexport function isInterpreterDirective<\n  Opts extends Options<t.InterpreterDirective>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.InterpreterDirective & Opts;\nexport function isInterpreterDirective<\n  Opts extends Options<t.InterpreterDirective>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"InterpreterDirective\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDirective(\n  node: t.Node | null | undefined,\n): node is t.Directive;\nexport function isDirective<Opts extends Options<t.Directive>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Directive & Opts;\nexport function isDirective<Opts extends Options<t.Directive>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Directive\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDirectiveLiteral(\n  node: t.Node | null | undefined,\n): node is t.DirectiveLiteral;\nexport function isDirectiveLiteral<Opts extends Options<t.DirectiveLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DirectiveLiteral & Opts;\nexport function isDirectiveLiteral<Opts extends Options<t.DirectiveLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DirectiveLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBlockStatement(\n  node: t.Node | null | undefined,\n): node is t.BlockStatement;\nexport function isBlockStatement<Opts extends Options<t.BlockStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BlockStatement & Opts;\nexport function isBlockStatement<Opts extends Options<t.BlockStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BlockStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBreakStatement(\n  node: t.Node | null | undefined,\n): node is t.BreakStatement;\nexport function isBreakStatement<Opts extends Options<t.BreakStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BreakStatement & Opts;\nexport function isBreakStatement<Opts extends Options<t.BreakStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BreakStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isCallExpression(\n  node: t.Node | null | undefined,\n): node is t.CallExpression;\nexport function isCallExpression<Opts extends Options<t.CallExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.CallExpression & Opts;\nexport function isCallExpression<Opts extends Options<t.CallExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"CallExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isCatchClause(\n  node: t.Node | null | undefined,\n): node is t.CatchClause;\nexport function isCatchClause<Opts extends Options<t.CatchClause>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.CatchClause & Opts;\nexport function isCatchClause<Opts extends Options<t.CatchClause>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"CatchClause\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isConditionalExpression(\n  node: t.Node | null | undefined,\n): node is t.ConditionalExpression;\nexport function isConditionalExpression<\n  Opts extends Options<t.ConditionalExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ConditionalExpression & Opts;\nexport function isConditionalExpression<\n  Opts extends Options<t.ConditionalExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ConditionalExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isContinueStatement(\n  node: t.Node | null | undefined,\n): node is t.ContinueStatement;\nexport function isContinueStatement<Opts extends Options<t.ContinueStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ContinueStatement & Opts;\nexport function isContinueStatement<Opts extends Options<t.ContinueStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ContinueStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDebuggerStatement(\n  node: t.Node | null | undefined,\n): node is t.DebuggerStatement;\nexport function isDebuggerStatement<Opts extends Options<t.DebuggerStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DebuggerStatement & Opts;\nexport function isDebuggerStatement<Opts extends Options<t.DebuggerStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DebuggerStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDoWhileStatement(\n  node: t.Node | null | undefined,\n): node is t.DoWhileStatement;\nexport function isDoWhileStatement<Opts extends Options<t.DoWhileStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DoWhileStatement & Opts;\nexport function isDoWhileStatement<Opts extends Options<t.DoWhileStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DoWhileStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEmptyStatement(\n  node: t.Node | null | undefined,\n): node is t.EmptyStatement;\nexport function isEmptyStatement<Opts extends Options<t.EmptyStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EmptyStatement & Opts;\nexport function isEmptyStatement<Opts extends Options<t.EmptyStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EmptyStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExpressionStatement(\n  node: t.Node | null | undefined,\n): node is t.ExpressionStatement;\nexport function isExpressionStatement<\n  Opts extends Options<t.ExpressionStatement>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExpressionStatement & Opts;\nexport function isExpressionStatement<\n  Opts extends Options<t.ExpressionStatement>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExpressionStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFile(node: t.Node | null | undefined): node is t.File;\nexport function isFile<Opts extends Options<t.File>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.File & Opts;\nexport function isFile<Opts extends Options<t.File>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"File\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isForInStatement(\n  node: t.Node | null | undefined,\n): node is t.ForInStatement;\nexport function isForInStatement<Opts extends Options<t.ForInStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ForInStatement & Opts;\nexport function isForInStatement<Opts extends Options<t.ForInStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ForInStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isForStatement(\n  node: t.Node | null | undefined,\n): node is t.ForStatement;\nexport function isForStatement<Opts extends Options<t.ForStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ForStatement & Opts;\nexport function isForStatement<Opts extends Options<t.ForStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ForStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionDeclaration(\n  node: t.Node | null | undefined,\n): node is t.FunctionDeclaration;\nexport function isFunctionDeclaration<\n  Opts extends Options<t.FunctionDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FunctionDeclaration & Opts;\nexport function isFunctionDeclaration<\n  Opts extends Options<t.FunctionDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"FunctionDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionExpression(\n  node: t.Node | null | undefined,\n): node is t.FunctionExpression;\nexport function isFunctionExpression<\n  Opts extends Options<t.FunctionExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FunctionExpression & Opts;\nexport function isFunctionExpression<\n  Opts extends Options<t.FunctionExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"FunctionExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isIdentifier(\n  node: t.Node | null | undefined,\n): node is t.Identifier;\nexport function isIdentifier<Opts extends Options<t.Identifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Identifier & Opts;\nexport function isIdentifier<Opts extends Options<t.Identifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Identifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isIfStatement(\n  node: t.Node | null | undefined,\n): node is t.IfStatement;\nexport function isIfStatement<Opts extends Options<t.IfStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.IfStatement & Opts;\nexport function isIfStatement<Opts extends Options<t.IfStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"IfStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isLabeledStatement(\n  node: t.Node | null | undefined,\n): node is t.LabeledStatement;\nexport function isLabeledStatement<Opts extends Options<t.LabeledStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.LabeledStatement & Opts;\nexport function isLabeledStatement<Opts extends Options<t.LabeledStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"LabeledStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStringLiteral(\n  node: t.Node | null | undefined,\n): node is t.StringLiteral;\nexport function isStringLiteral<Opts extends Options<t.StringLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.StringLiteral & Opts;\nexport function isStringLiteral<Opts extends Options<t.StringLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"StringLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNumericLiteral(\n  node: t.Node | null | undefined,\n): node is t.NumericLiteral;\nexport function isNumericLiteral<Opts extends Options<t.NumericLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NumericLiteral & Opts;\nexport function isNumericLiteral<Opts extends Options<t.NumericLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NumericLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNullLiteral(\n  node: t.Node | null | undefined,\n): node is t.NullLiteral;\nexport function isNullLiteral<Opts extends Options<t.NullLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NullLiteral & Opts;\nexport function isNullLiteral<Opts extends Options<t.NullLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NullLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBooleanLiteral(\n  node: t.Node | null | undefined,\n): node is t.BooleanLiteral;\nexport function isBooleanLiteral<Opts extends Options<t.BooleanLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BooleanLiteral & Opts;\nexport function isBooleanLiteral<Opts extends Options<t.BooleanLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BooleanLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isRegExpLiteral(\n  node: t.Node | null | undefined,\n): node is t.RegExpLiteral;\nexport function isRegExpLiteral<Opts extends Options<t.RegExpLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.RegExpLiteral & Opts;\nexport function isRegExpLiteral<Opts extends Options<t.RegExpLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"RegExpLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isLogicalExpression(\n  node: t.Node | null | undefined,\n): node is t.LogicalExpression;\nexport function isLogicalExpression<Opts extends Options<t.LogicalExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.LogicalExpression & Opts;\nexport function isLogicalExpression<Opts extends Options<t.LogicalExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"LogicalExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isMemberExpression(\n  node: t.Node | null | undefined,\n): node is t.MemberExpression;\nexport function isMemberExpression<Opts extends Options<t.MemberExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.MemberExpression & Opts;\nexport function isMemberExpression<Opts extends Options<t.MemberExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"MemberExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNewExpression(\n  node: t.Node | null | undefined,\n): node is t.NewExpression;\nexport function isNewExpression<Opts extends Options<t.NewExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NewExpression & Opts;\nexport function isNewExpression<Opts extends Options<t.NewExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NewExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isProgram(node: t.Node | null | undefined): node is t.Program;\nexport function isProgram<Opts extends Options<t.Program>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Program & Opts;\nexport function isProgram<Opts extends Options<t.Program>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Program\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectExpression(\n  node: t.Node | null | undefined,\n): node is t.ObjectExpression;\nexport function isObjectExpression<Opts extends Options<t.ObjectExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectExpression & Opts;\nexport function isObjectExpression<Opts extends Options<t.ObjectExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectMethod(\n  node: t.Node | null | undefined,\n): node is t.ObjectMethod;\nexport function isObjectMethod<Opts extends Options<t.ObjectMethod>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectMethod & Opts;\nexport function isObjectMethod<Opts extends Options<t.ObjectMethod>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectMethod\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectProperty(\n  node: t.Node | null | undefined,\n): node is t.ObjectProperty;\nexport function isObjectProperty<Opts extends Options<t.ObjectProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectProperty & Opts;\nexport function isObjectProperty<Opts extends Options<t.ObjectProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isRestElement(\n  node: t.Node | null | undefined,\n): node is t.RestElement;\nexport function isRestElement<Opts extends Options<t.RestElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.RestElement & Opts;\nexport function isRestElement<Opts extends Options<t.RestElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"RestElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isReturnStatement(\n  node: t.Node | null | undefined,\n): node is t.ReturnStatement;\nexport function isReturnStatement<Opts extends Options<t.ReturnStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ReturnStatement & Opts;\nexport function isReturnStatement<Opts extends Options<t.ReturnStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ReturnStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSequenceExpression(\n  node: t.Node | null | undefined,\n): node is t.SequenceExpression;\nexport function isSequenceExpression<\n  Opts extends Options<t.SequenceExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.SequenceExpression & Opts;\nexport function isSequenceExpression<\n  Opts extends Options<t.SequenceExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"SequenceExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isParenthesizedExpression(\n  node: t.Node | null | undefined,\n): node is t.ParenthesizedExpression;\nexport function isParenthesizedExpression<\n  Opts extends Options<t.ParenthesizedExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ParenthesizedExpression & Opts;\nexport function isParenthesizedExpression<\n  Opts extends Options<t.ParenthesizedExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ParenthesizedExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSwitchCase(\n  node: t.Node | null | undefined,\n): node is t.SwitchCase;\nexport function isSwitchCase<Opts extends Options<t.SwitchCase>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.SwitchCase & Opts;\nexport function isSwitchCase<Opts extends Options<t.SwitchCase>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"SwitchCase\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSwitchStatement(\n  node: t.Node | null | undefined,\n): node is t.SwitchStatement;\nexport function isSwitchStatement<Opts extends Options<t.SwitchStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.SwitchStatement & Opts;\nexport function isSwitchStatement<Opts extends Options<t.SwitchStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"SwitchStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isThisExpression(\n  node: t.Node | null | undefined,\n): node is t.ThisExpression;\nexport function isThisExpression<Opts extends Options<t.ThisExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ThisExpression & Opts;\nexport function isThisExpression<Opts extends Options<t.ThisExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ThisExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isThrowStatement(\n  node: t.Node | null | undefined,\n): node is t.ThrowStatement;\nexport function isThrowStatement<Opts extends Options<t.ThrowStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ThrowStatement & Opts;\nexport function isThrowStatement<Opts extends Options<t.ThrowStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ThrowStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTryStatement(\n  node: t.Node | null | undefined,\n): node is t.TryStatement;\nexport function isTryStatement<Opts extends Options<t.TryStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TryStatement & Opts;\nexport function isTryStatement<Opts extends Options<t.TryStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TryStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isUnaryExpression(\n  node: t.Node | null | undefined,\n): node is t.UnaryExpression;\nexport function isUnaryExpression<Opts extends Options<t.UnaryExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.UnaryExpression & Opts;\nexport function isUnaryExpression<Opts extends Options<t.UnaryExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"UnaryExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isUpdateExpression(\n  node: t.Node | null | undefined,\n): node is t.UpdateExpression;\nexport function isUpdateExpression<Opts extends Options<t.UpdateExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.UpdateExpression & Opts;\nexport function isUpdateExpression<Opts extends Options<t.UpdateExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"UpdateExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isVariableDeclaration(\n  node: t.Node | null | undefined,\n): node is t.VariableDeclaration;\nexport function isVariableDeclaration<\n  Opts extends Options<t.VariableDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.VariableDeclaration & Opts;\nexport function isVariableDeclaration<\n  Opts extends Options<t.VariableDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"VariableDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isVariableDeclarator(\n  node: t.Node | null | undefined,\n): node is t.VariableDeclarator;\nexport function isVariableDeclarator<\n  Opts extends Options<t.VariableDeclarator>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.VariableDeclarator & Opts;\nexport function isVariableDeclarator<\n  Opts extends Options<t.VariableDeclarator>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"VariableDeclarator\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isWhileStatement(\n  node: t.Node | null | undefined,\n): node is t.WhileStatement;\nexport function isWhileStatement<Opts extends Options<t.WhileStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.WhileStatement & Opts;\nexport function isWhileStatement<Opts extends Options<t.WhileStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"WhileStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isWithStatement(\n  node: t.Node | null | undefined,\n): node is t.WithStatement;\nexport function isWithStatement<Opts extends Options<t.WithStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.WithStatement & Opts;\nexport function isWithStatement<Opts extends Options<t.WithStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"WithStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isAssignmentPattern(\n  node: t.Node | null | undefined,\n): node is t.AssignmentPattern;\nexport function isAssignmentPattern<Opts extends Options<t.AssignmentPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.AssignmentPattern & Opts;\nexport function isAssignmentPattern<Opts extends Options<t.AssignmentPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"AssignmentPattern\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isArrayPattern(\n  node: t.Node | null | undefined,\n): node is t.ArrayPattern;\nexport function isArrayPattern<Opts extends Options<t.ArrayPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ArrayPattern & Opts;\nexport function isArrayPattern<Opts extends Options<t.ArrayPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ArrayPattern\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isArrowFunctionExpression(\n  node: t.Node | null | undefined,\n): node is t.ArrowFunctionExpression;\nexport function isArrowFunctionExpression<\n  Opts extends Options<t.ArrowFunctionExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ArrowFunctionExpression & Opts;\nexport function isArrowFunctionExpression<\n  Opts extends Options<t.ArrowFunctionExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ArrowFunctionExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassBody(\n  node: t.Node | null | undefined,\n): node is t.ClassBody;\nexport function isClassBody<Opts extends Options<t.ClassBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassBody & Opts;\nexport function isClassBody<Opts extends Options<t.ClassBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassExpression(\n  node: t.Node | null | undefined,\n): node is t.ClassExpression;\nexport function isClassExpression<Opts extends Options<t.ClassExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassExpression & Opts;\nexport function isClassExpression<Opts extends Options<t.ClassExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ClassDeclaration;\nexport function isClassDeclaration<Opts extends Options<t.ClassDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassDeclaration & Opts;\nexport function isClassDeclaration<Opts extends Options<t.ClassDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportAllDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ExportAllDeclaration;\nexport function isExportAllDeclaration<\n  Opts extends Options<t.ExportAllDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportAllDeclaration & Opts;\nexport function isExportAllDeclaration<\n  Opts extends Options<t.ExportAllDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExportAllDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportDefaultDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ExportDefaultDeclaration;\nexport function isExportDefaultDeclaration<\n  Opts extends Options<t.ExportDefaultDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportDefaultDeclaration & Opts;\nexport function isExportDefaultDeclaration<\n  Opts extends Options<t.ExportDefaultDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExportDefaultDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportNamedDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ExportNamedDeclaration;\nexport function isExportNamedDeclaration<\n  Opts extends Options<t.ExportNamedDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportNamedDeclaration & Opts;\nexport function isExportNamedDeclaration<\n  Opts extends Options<t.ExportNamedDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExportNamedDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ExportSpecifier;\nexport function isExportSpecifier<Opts extends Options<t.ExportSpecifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportSpecifier & Opts;\nexport function isExportSpecifier<Opts extends Options<t.ExportSpecifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExportSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isForOfStatement(\n  node: t.Node | null | undefined,\n): node is t.ForOfStatement;\nexport function isForOfStatement<Opts extends Options<t.ForOfStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ForOfStatement & Opts;\nexport function isForOfStatement<Opts extends Options<t.ForOfStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ForOfStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ImportDeclaration;\nexport function isImportDeclaration<Opts extends Options<t.ImportDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportDeclaration & Opts;\nexport function isImportDeclaration<Opts extends Options<t.ImportDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ImportDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportDefaultSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ImportDefaultSpecifier;\nexport function isImportDefaultSpecifier<\n  Opts extends Options<t.ImportDefaultSpecifier>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportDefaultSpecifier & Opts;\nexport function isImportDefaultSpecifier<\n  Opts extends Options<t.ImportDefaultSpecifier>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ImportDefaultSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportNamespaceSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ImportNamespaceSpecifier;\nexport function isImportNamespaceSpecifier<\n  Opts extends Options<t.ImportNamespaceSpecifier>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportNamespaceSpecifier & Opts;\nexport function isImportNamespaceSpecifier<\n  Opts extends Options<t.ImportNamespaceSpecifier>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ImportNamespaceSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ImportSpecifier;\nexport function isImportSpecifier<Opts extends Options<t.ImportSpecifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportSpecifier & Opts;\nexport function isImportSpecifier<Opts extends Options<t.ImportSpecifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ImportSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportExpression(\n  node: t.Node | null | undefined,\n): node is t.ImportExpression;\nexport function isImportExpression<Opts extends Options<t.ImportExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportExpression & Opts;\nexport function isImportExpression<Opts extends Options<t.ImportExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ImportExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isMetaProperty(\n  node: t.Node | null | undefined,\n): node is t.MetaProperty;\nexport function isMetaProperty<Opts extends Options<t.MetaProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.MetaProperty & Opts;\nexport function isMetaProperty<Opts extends Options<t.MetaProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"MetaProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassMethod(\n  node: t.Node | null | undefined,\n): node is t.ClassMethod;\nexport function isClassMethod<Opts extends Options<t.ClassMethod>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassMethod & Opts;\nexport function isClassMethod<Opts extends Options<t.ClassMethod>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassMethod\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectPattern(\n  node: t.Node | null | undefined,\n): node is t.ObjectPattern;\nexport function isObjectPattern<Opts extends Options<t.ObjectPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectPattern & Opts;\nexport function isObjectPattern<Opts extends Options<t.ObjectPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectPattern\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSpreadElement(\n  node: t.Node | null | undefined,\n): node is t.SpreadElement;\nexport function isSpreadElement<Opts extends Options<t.SpreadElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.SpreadElement & Opts;\nexport function isSpreadElement<Opts extends Options<t.SpreadElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"SpreadElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSuper(node: t.Node | null | undefined): node is t.Super;\nexport function isSuper<Opts extends Options<t.Super>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Super & Opts;\nexport function isSuper<Opts extends Options<t.Super>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Super\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTaggedTemplateExpression(\n  node: t.Node | null | undefined,\n): node is t.TaggedTemplateExpression;\nexport function isTaggedTemplateExpression<\n  Opts extends Options<t.TaggedTemplateExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TaggedTemplateExpression & Opts;\nexport function isTaggedTemplateExpression<\n  Opts extends Options<t.TaggedTemplateExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TaggedTemplateExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTemplateElement(\n  node: t.Node | null | undefined,\n): node is t.TemplateElement;\nexport function isTemplateElement<Opts extends Options<t.TemplateElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TemplateElement & Opts;\nexport function isTemplateElement<Opts extends Options<t.TemplateElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TemplateElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTemplateLiteral(\n  node: t.Node | null | undefined,\n): node is t.TemplateLiteral;\nexport function isTemplateLiteral<Opts extends Options<t.TemplateLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TemplateLiteral & Opts;\nexport function isTemplateLiteral<Opts extends Options<t.TemplateLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TemplateLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isYieldExpression(\n  node: t.Node | null | undefined,\n): node is t.YieldExpression;\nexport function isYieldExpression<Opts extends Options<t.YieldExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.YieldExpression & Opts;\nexport function isYieldExpression<Opts extends Options<t.YieldExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"YieldExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isAwaitExpression(\n  node: t.Node | null | undefined,\n): node is t.AwaitExpression;\nexport function isAwaitExpression<Opts extends Options<t.AwaitExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.AwaitExpression & Opts;\nexport function isAwaitExpression<Opts extends Options<t.AwaitExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"AwaitExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImport(node: t.Node | null | undefined): node is t.Import;\nexport function isImport<Opts extends Options<t.Import>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Import & Opts;\nexport function isImport<Opts extends Options<t.Import>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Import\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBigIntLiteral(\n  node: t.Node | null | undefined,\n): node is t.BigIntLiteral;\nexport function isBigIntLiteral<Opts extends Options<t.BigIntLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BigIntLiteral & Opts;\nexport function isBigIntLiteral<Opts extends Options<t.BigIntLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BigIntLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportNamespaceSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ExportNamespaceSpecifier;\nexport function isExportNamespaceSpecifier<\n  Opts extends Options<t.ExportNamespaceSpecifier>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportNamespaceSpecifier & Opts;\nexport function isExportNamespaceSpecifier<\n  Opts extends Options<t.ExportNamespaceSpecifier>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExportNamespaceSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isOptionalMemberExpression(\n  node: t.Node | null | undefined,\n): node is t.OptionalMemberExpression;\nexport function isOptionalMemberExpression<\n  Opts extends Options<t.OptionalMemberExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.OptionalMemberExpression & Opts;\nexport function isOptionalMemberExpression<\n  Opts extends Options<t.OptionalMemberExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"OptionalMemberExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isOptionalCallExpression(\n  node: t.Node | null | undefined,\n): node is t.OptionalCallExpression;\nexport function isOptionalCallExpression<\n  Opts extends Options<t.OptionalCallExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.OptionalCallExpression & Opts;\nexport function isOptionalCallExpression<\n  Opts extends Options<t.OptionalCallExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"OptionalCallExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassProperty(\n  node: t.Node | null | undefined,\n): node is t.ClassProperty;\nexport function isClassProperty<Opts extends Options<t.ClassProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassProperty & Opts;\nexport function isClassProperty<Opts extends Options<t.ClassProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassPrivateProperty(\n  node: t.Node | null | undefined,\n): node is t.ClassPrivateProperty;\nexport function isClassPrivateProperty<\n  Opts extends Options<t.ClassPrivateProperty>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassPrivateProperty & Opts;\nexport function isClassPrivateProperty<\n  Opts extends Options<t.ClassPrivateProperty>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassPrivateProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassPrivateMethod(\n  node: t.Node | null | undefined,\n): node is t.ClassPrivateMethod;\nexport function isClassPrivateMethod<\n  Opts extends Options<t.ClassPrivateMethod>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassPrivateMethod & Opts;\nexport function isClassPrivateMethod<\n  Opts extends Options<t.ClassPrivateMethod>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassPrivateMethod\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPrivateName(\n  node: t.Node | null | undefined,\n): node is t.PrivateName;\nexport function isPrivateName<Opts extends Options<t.PrivateName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.PrivateName & Opts;\nexport function isPrivateName<Opts extends Options<t.PrivateName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"PrivateName\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStaticBlock(\n  node: t.Node | null | undefined,\n): node is t.StaticBlock;\nexport function isStaticBlock<Opts extends Options<t.StaticBlock>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.StaticBlock & Opts;\nexport function isStaticBlock<Opts extends Options<t.StaticBlock>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"StaticBlock\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportAttribute(\n  node: t.Node | null | undefined,\n): node is t.ImportAttribute;\nexport function isImportAttribute<Opts extends Options<t.ImportAttribute>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportAttribute & Opts;\nexport function isImportAttribute<Opts extends Options<t.ImportAttribute>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ImportAttribute\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isAnyTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.AnyTypeAnnotation;\nexport function isAnyTypeAnnotation<Opts extends Options<t.AnyTypeAnnotation>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.AnyTypeAnnotation & Opts;\nexport function isAnyTypeAnnotation<Opts extends Options<t.AnyTypeAnnotation>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"AnyTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isArrayTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.ArrayTypeAnnotation;\nexport function isArrayTypeAnnotation<\n  Opts extends Options<t.ArrayTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ArrayTypeAnnotation & Opts;\nexport function isArrayTypeAnnotation<\n  Opts extends Options<t.ArrayTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ArrayTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBooleanTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.BooleanTypeAnnotation;\nexport function isBooleanTypeAnnotation<\n  Opts extends Options<t.BooleanTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BooleanTypeAnnotation & Opts;\nexport function isBooleanTypeAnnotation<\n  Opts extends Options<t.BooleanTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BooleanTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBooleanLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.BooleanLiteralTypeAnnotation;\nexport function isBooleanLiteralTypeAnnotation<\n  Opts extends Options<t.BooleanLiteralTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BooleanLiteralTypeAnnotation & Opts;\nexport function isBooleanLiteralTypeAnnotation<\n  Opts extends Options<t.BooleanLiteralTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BooleanLiteralTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNullLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.NullLiteralTypeAnnotation;\nexport function isNullLiteralTypeAnnotation<\n  Opts extends Options<t.NullLiteralTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NullLiteralTypeAnnotation & Opts;\nexport function isNullLiteralTypeAnnotation<\n  Opts extends Options<t.NullLiteralTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NullLiteralTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassImplements(\n  node: t.Node | null | undefined,\n): node is t.ClassImplements;\nexport function isClassImplements<Opts extends Options<t.ClassImplements>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassImplements & Opts;\nexport function isClassImplements<Opts extends Options<t.ClassImplements>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassImplements\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareClass(\n  node: t.Node | null | undefined,\n): node is t.DeclareClass;\nexport function isDeclareClass<Opts extends Options<t.DeclareClass>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareClass & Opts;\nexport function isDeclareClass<Opts extends Options<t.DeclareClass>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareClass\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareFunction(\n  node: t.Node | null | undefined,\n): node is t.DeclareFunction;\nexport function isDeclareFunction<Opts extends Options<t.DeclareFunction>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareFunction & Opts;\nexport function isDeclareFunction<Opts extends Options<t.DeclareFunction>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareFunction\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareInterface(\n  node: t.Node | null | undefined,\n): node is t.DeclareInterface;\nexport function isDeclareInterface<Opts extends Options<t.DeclareInterface>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareInterface & Opts;\nexport function isDeclareInterface<Opts extends Options<t.DeclareInterface>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareInterface\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareModule(\n  node: t.Node | null | undefined,\n): node is t.DeclareModule;\nexport function isDeclareModule<Opts extends Options<t.DeclareModule>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareModule & Opts;\nexport function isDeclareModule<Opts extends Options<t.DeclareModule>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareModule\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareModuleExports(\n  node: t.Node | null | undefined,\n): node is t.DeclareModuleExports;\nexport function isDeclareModuleExports<\n  Opts extends Options<t.DeclareModuleExports>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareModuleExports & Opts;\nexport function isDeclareModuleExports<\n  Opts extends Options<t.DeclareModuleExports>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareModuleExports\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareTypeAlias(\n  node: t.Node | null | undefined,\n): node is t.DeclareTypeAlias;\nexport function isDeclareTypeAlias<Opts extends Options<t.DeclareTypeAlias>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareTypeAlias & Opts;\nexport function isDeclareTypeAlias<Opts extends Options<t.DeclareTypeAlias>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareTypeAlias\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareOpaqueType(\n  node: t.Node | null | undefined,\n): node is t.DeclareOpaqueType;\nexport function isDeclareOpaqueType<Opts extends Options<t.DeclareOpaqueType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareOpaqueType & Opts;\nexport function isDeclareOpaqueType<Opts extends Options<t.DeclareOpaqueType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareOpaqueType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareVariable(\n  node: t.Node | null | undefined,\n): node is t.DeclareVariable;\nexport function isDeclareVariable<Opts extends Options<t.DeclareVariable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareVariable & Opts;\nexport function isDeclareVariable<Opts extends Options<t.DeclareVariable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareVariable\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareExportDeclaration(\n  node: t.Node | null | undefined,\n): node is t.DeclareExportDeclaration;\nexport function isDeclareExportDeclaration<\n  Opts extends Options<t.DeclareExportDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareExportDeclaration & Opts;\nexport function isDeclareExportDeclaration<\n  Opts extends Options<t.DeclareExportDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareExportDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareExportAllDeclaration(\n  node: t.Node | null | undefined,\n): node is t.DeclareExportAllDeclaration;\nexport function isDeclareExportAllDeclaration<\n  Opts extends Options<t.DeclareExportAllDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareExportAllDeclaration & Opts;\nexport function isDeclareExportAllDeclaration<\n  Opts extends Options<t.DeclareExportAllDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareExportAllDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclaredPredicate(\n  node: t.Node | null | undefined,\n): node is t.DeclaredPredicate;\nexport function isDeclaredPredicate<Opts extends Options<t.DeclaredPredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclaredPredicate & Opts;\nexport function isDeclaredPredicate<Opts extends Options<t.DeclaredPredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclaredPredicate\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExistsTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.ExistsTypeAnnotation;\nexport function isExistsTypeAnnotation<\n  Opts extends Options<t.ExistsTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExistsTypeAnnotation & Opts;\nexport function isExistsTypeAnnotation<\n  Opts extends Options<t.ExistsTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExistsTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.FunctionTypeAnnotation;\nexport function isFunctionTypeAnnotation<\n  Opts extends Options<t.FunctionTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FunctionTypeAnnotation & Opts;\nexport function isFunctionTypeAnnotation<\n  Opts extends Options<t.FunctionTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"FunctionTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionTypeParam(\n  node: t.Node | null | undefined,\n): node is t.FunctionTypeParam;\nexport function isFunctionTypeParam<Opts extends Options<t.FunctionTypeParam>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FunctionTypeParam & Opts;\nexport function isFunctionTypeParam<Opts extends Options<t.FunctionTypeParam>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"FunctionTypeParam\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isGenericTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.GenericTypeAnnotation;\nexport function isGenericTypeAnnotation<\n  Opts extends Options<t.GenericTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.GenericTypeAnnotation & Opts;\nexport function isGenericTypeAnnotation<\n  Opts extends Options<t.GenericTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"GenericTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isInferredPredicate(\n  node: t.Node | null | undefined,\n): node is t.InferredPredicate;\nexport function isInferredPredicate<Opts extends Options<t.InferredPredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.InferredPredicate & Opts;\nexport function isInferredPredicate<Opts extends Options<t.InferredPredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"InferredPredicate\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isInterfaceExtends(\n  node: t.Node | null | undefined,\n): node is t.InterfaceExtends;\nexport function isInterfaceExtends<Opts extends Options<t.InterfaceExtends>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.InterfaceExtends & Opts;\nexport function isInterfaceExtends<Opts extends Options<t.InterfaceExtends>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"InterfaceExtends\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isInterfaceDeclaration(\n  node: t.Node | null | undefined,\n): node is t.InterfaceDeclaration;\nexport function isInterfaceDeclaration<\n  Opts extends Options<t.InterfaceDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.InterfaceDeclaration & Opts;\nexport function isInterfaceDeclaration<\n  Opts extends Options<t.InterfaceDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"InterfaceDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isInterfaceTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.InterfaceTypeAnnotation;\nexport function isInterfaceTypeAnnotation<\n  Opts extends Options<t.InterfaceTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.InterfaceTypeAnnotation & Opts;\nexport function isInterfaceTypeAnnotation<\n  Opts extends Options<t.InterfaceTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"InterfaceTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isIntersectionTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.IntersectionTypeAnnotation;\nexport function isIntersectionTypeAnnotation<\n  Opts extends Options<t.IntersectionTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.IntersectionTypeAnnotation & Opts;\nexport function isIntersectionTypeAnnotation<\n  Opts extends Options<t.IntersectionTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"IntersectionTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isMixedTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.MixedTypeAnnotation;\nexport function isMixedTypeAnnotation<\n  Opts extends Options<t.MixedTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.MixedTypeAnnotation & Opts;\nexport function isMixedTypeAnnotation<\n  Opts extends Options<t.MixedTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"MixedTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEmptyTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.EmptyTypeAnnotation;\nexport function isEmptyTypeAnnotation<\n  Opts extends Options<t.EmptyTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EmptyTypeAnnotation & Opts;\nexport function isEmptyTypeAnnotation<\n  Opts extends Options<t.EmptyTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EmptyTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNullableTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.NullableTypeAnnotation;\nexport function isNullableTypeAnnotation<\n  Opts extends Options<t.NullableTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NullableTypeAnnotation & Opts;\nexport function isNullableTypeAnnotation<\n  Opts extends Options<t.NullableTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NullableTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNumberLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.NumberLiteralTypeAnnotation;\nexport function isNumberLiteralTypeAnnotation<\n  Opts extends Options<t.NumberLiteralTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NumberLiteralTypeAnnotation & Opts;\nexport function isNumberLiteralTypeAnnotation<\n  Opts extends Options<t.NumberLiteralTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NumberLiteralTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNumberTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.NumberTypeAnnotation;\nexport function isNumberTypeAnnotation<\n  Opts extends Options<t.NumberTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NumberTypeAnnotation & Opts;\nexport function isNumberTypeAnnotation<\n  Opts extends Options<t.NumberTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NumberTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeAnnotation;\nexport function isObjectTypeAnnotation<\n  Opts extends Options<t.ObjectTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectTypeAnnotation & Opts;\nexport function isObjectTypeAnnotation<\n  Opts extends Options<t.ObjectTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeInternalSlot(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeInternalSlot;\nexport function isObjectTypeInternalSlot<\n  Opts extends Options<t.ObjectTypeInternalSlot>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectTypeInternalSlot & Opts;\nexport function isObjectTypeInternalSlot<\n  Opts extends Options<t.ObjectTypeInternalSlot>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeInternalSlot\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeCallProperty(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeCallProperty;\nexport function isObjectTypeCallProperty<\n  Opts extends Options<t.ObjectTypeCallProperty>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectTypeCallProperty & Opts;\nexport function isObjectTypeCallProperty<\n  Opts extends Options<t.ObjectTypeCallProperty>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeCallProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeIndexer(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeIndexer;\nexport function isObjectTypeIndexer<Opts extends Options<t.ObjectTypeIndexer>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectTypeIndexer & Opts;\nexport function isObjectTypeIndexer<Opts extends Options<t.ObjectTypeIndexer>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeIndexer\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeProperty(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeProperty;\nexport function isObjectTypeProperty<\n  Opts extends Options<t.ObjectTypeProperty>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectTypeProperty & Opts;\nexport function isObjectTypeProperty<\n  Opts extends Options<t.ObjectTypeProperty>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeSpreadProperty(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeSpreadProperty;\nexport function isObjectTypeSpreadProperty<\n  Opts extends Options<t.ObjectTypeSpreadProperty>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectTypeSpreadProperty & Opts;\nexport function isObjectTypeSpreadProperty<\n  Opts extends Options<t.ObjectTypeSpreadProperty>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeSpreadProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isOpaqueType(\n  node: t.Node | null | undefined,\n): node is t.OpaqueType;\nexport function isOpaqueType<Opts extends Options<t.OpaqueType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.OpaqueType & Opts;\nexport function isOpaqueType<Opts extends Options<t.OpaqueType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"OpaqueType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isQualifiedTypeIdentifier(\n  node: t.Node | null | undefined,\n): node is t.QualifiedTypeIdentifier;\nexport function isQualifiedTypeIdentifier<\n  Opts extends Options<t.QualifiedTypeIdentifier>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.QualifiedTypeIdentifier & Opts;\nexport function isQualifiedTypeIdentifier<\n  Opts extends Options<t.QualifiedTypeIdentifier>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"QualifiedTypeIdentifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStringLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.StringLiteralTypeAnnotation;\nexport function isStringLiteralTypeAnnotation<\n  Opts extends Options<t.StringLiteralTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.StringLiteralTypeAnnotation & Opts;\nexport function isStringLiteralTypeAnnotation<\n  Opts extends Options<t.StringLiteralTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"StringLiteralTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStringTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.StringTypeAnnotation;\nexport function isStringTypeAnnotation<\n  Opts extends Options<t.StringTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.StringTypeAnnotation & Opts;\nexport function isStringTypeAnnotation<\n  Opts extends Options<t.StringTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"StringTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSymbolTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.SymbolTypeAnnotation;\nexport function isSymbolTypeAnnotation<\n  Opts extends Options<t.SymbolTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.SymbolTypeAnnotation & Opts;\nexport function isSymbolTypeAnnotation<\n  Opts extends Options<t.SymbolTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"SymbolTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isThisTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.ThisTypeAnnotation;\nexport function isThisTypeAnnotation<\n  Opts extends Options<t.ThisTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ThisTypeAnnotation & Opts;\nexport function isThisTypeAnnotation<\n  Opts extends Options<t.ThisTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ThisTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTupleTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.TupleTypeAnnotation;\nexport function isTupleTypeAnnotation<\n  Opts extends Options<t.TupleTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TupleTypeAnnotation & Opts;\nexport function isTupleTypeAnnotation<\n  Opts extends Options<t.TupleTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TupleTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeofTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.TypeofTypeAnnotation;\nexport function isTypeofTypeAnnotation<\n  Opts extends Options<t.TypeofTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeofTypeAnnotation & Opts;\nexport function isTypeofTypeAnnotation<\n  Opts extends Options<t.TypeofTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeofTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeAlias(\n  node: t.Node | null | undefined,\n): node is t.TypeAlias;\nexport function isTypeAlias<Opts extends Options<t.TypeAlias>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeAlias & Opts;\nexport function isTypeAlias<Opts extends Options<t.TypeAlias>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeAlias\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.TypeAnnotation;\nexport function isTypeAnnotation<Opts extends Options<t.TypeAnnotation>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeAnnotation & Opts;\nexport function isTypeAnnotation<Opts extends Options<t.TypeAnnotation>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeCastExpression(\n  node: t.Node | null | undefined,\n): node is t.TypeCastExpression;\nexport function isTypeCastExpression<\n  Opts extends Options<t.TypeCastExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeCastExpression & Opts;\nexport function isTypeCastExpression<\n  Opts extends Options<t.TypeCastExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeCastExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeParameter(\n  node: t.Node | null | undefined,\n): node is t.TypeParameter;\nexport function isTypeParameter<Opts extends Options<t.TypeParameter>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeParameter & Opts;\nexport function isTypeParameter<Opts extends Options<t.TypeParameter>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeParameter\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeParameterDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TypeParameterDeclaration;\nexport function isTypeParameterDeclaration<\n  Opts extends Options<t.TypeParameterDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeParameterDeclaration & Opts;\nexport function isTypeParameterDeclaration<\n  Opts extends Options<t.TypeParameterDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeParameterDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeParameterInstantiation(\n  node: t.Node | null | undefined,\n): node is t.TypeParameterInstantiation;\nexport function isTypeParameterInstantiation<\n  Opts extends Options<t.TypeParameterInstantiation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeParameterInstantiation & Opts;\nexport function isTypeParameterInstantiation<\n  Opts extends Options<t.TypeParameterInstantiation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeParameterInstantiation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isUnionTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.UnionTypeAnnotation;\nexport function isUnionTypeAnnotation<\n  Opts extends Options<t.UnionTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.UnionTypeAnnotation & Opts;\nexport function isUnionTypeAnnotation<\n  Opts extends Options<t.UnionTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"UnionTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isVariance(node: t.Node | null | undefined): node is t.Variance;\nexport function isVariance<Opts extends Options<t.Variance>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Variance & Opts;\nexport function isVariance<Opts extends Options<t.Variance>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Variance\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isVoidTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.VoidTypeAnnotation;\nexport function isVoidTypeAnnotation<\n  Opts extends Options<t.VoidTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.VoidTypeAnnotation & Opts;\nexport function isVoidTypeAnnotation<\n  Opts extends Options<t.VoidTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"VoidTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumDeclaration(\n  node: t.Node | null | undefined,\n): node is t.EnumDeclaration;\nexport function isEnumDeclaration<Opts extends Options<t.EnumDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumDeclaration & Opts;\nexport function isEnumDeclaration<Opts extends Options<t.EnumDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumBooleanBody(\n  node: t.Node | null | undefined,\n): node is t.EnumBooleanBody;\nexport function isEnumBooleanBody<Opts extends Options<t.EnumBooleanBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumBooleanBody & Opts;\nexport function isEnumBooleanBody<Opts extends Options<t.EnumBooleanBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumBooleanBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumNumberBody(\n  node: t.Node | null | undefined,\n): node is t.EnumNumberBody;\nexport function isEnumNumberBody<Opts extends Options<t.EnumNumberBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumNumberBody & Opts;\nexport function isEnumNumberBody<Opts extends Options<t.EnumNumberBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumNumberBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumStringBody(\n  node: t.Node | null | undefined,\n): node is t.EnumStringBody;\nexport function isEnumStringBody<Opts extends Options<t.EnumStringBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumStringBody & Opts;\nexport function isEnumStringBody<Opts extends Options<t.EnumStringBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumStringBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumSymbolBody(\n  node: t.Node | null | undefined,\n): node is t.EnumSymbolBody;\nexport function isEnumSymbolBody<Opts extends Options<t.EnumSymbolBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumSymbolBody & Opts;\nexport function isEnumSymbolBody<Opts extends Options<t.EnumSymbolBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumSymbolBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumBooleanMember(\n  node: t.Node | null | undefined,\n): node is t.EnumBooleanMember;\nexport function isEnumBooleanMember<Opts extends Options<t.EnumBooleanMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumBooleanMember & Opts;\nexport function isEnumBooleanMember<Opts extends Options<t.EnumBooleanMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumBooleanMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumNumberMember(\n  node: t.Node | null | undefined,\n): node is t.EnumNumberMember;\nexport function isEnumNumberMember<Opts extends Options<t.EnumNumberMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumNumberMember & Opts;\nexport function isEnumNumberMember<Opts extends Options<t.EnumNumberMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumNumberMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumStringMember(\n  node: t.Node | null | undefined,\n): node is t.EnumStringMember;\nexport function isEnumStringMember<Opts extends Options<t.EnumStringMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumStringMember & Opts;\nexport function isEnumStringMember<Opts extends Options<t.EnumStringMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumStringMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumDefaultedMember(\n  node: t.Node | null | undefined,\n): node is t.EnumDefaultedMember;\nexport function isEnumDefaultedMember<\n  Opts extends Options<t.EnumDefaultedMember>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumDefaultedMember & Opts;\nexport function isEnumDefaultedMember<\n  Opts extends Options<t.EnumDefaultedMember>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumDefaultedMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isIndexedAccessType(\n  node: t.Node | null | undefined,\n): node is t.IndexedAccessType;\nexport function isIndexedAccessType<Opts extends Options<t.IndexedAccessType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.IndexedAccessType & Opts;\nexport function isIndexedAccessType<Opts extends Options<t.IndexedAccessType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"IndexedAccessType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isOptionalIndexedAccessType(\n  node: t.Node | null | undefined,\n): node is t.OptionalIndexedAccessType;\nexport function isOptionalIndexedAccessType<\n  Opts extends Options<t.OptionalIndexedAccessType>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.OptionalIndexedAccessType & Opts;\nexport function isOptionalIndexedAccessType<\n  Opts extends Options<t.OptionalIndexedAccessType>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"OptionalIndexedAccessType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXAttribute(\n  node: t.Node | null | undefined,\n): node is t.JSXAttribute;\nexport function isJSXAttribute<Opts extends Options<t.JSXAttribute>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXAttribute & Opts;\nexport function isJSXAttribute<Opts extends Options<t.JSXAttribute>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXAttribute\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXClosingElement(\n  node: t.Node | null | undefined,\n): node is t.JSXClosingElement;\nexport function isJSXClosingElement<Opts extends Options<t.JSXClosingElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXClosingElement & Opts;\nexport function isJSXClosingElement<Opts extends Options<t.JSXClosingElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXClosingElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXElement(\n  node: t.Node | null | undefined,\n): node is t.JSXElement;\nexport function isJSXElement<Opts extends Options<t.JSXElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXElement & Opts;\nexport function isJSXElement<Opts extends Options<t.JSXElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXEmptyExpression(\n  node: t.Node | null | undefined,\n): node is t.JSXEmptyExpression;\nexport function isJSXEmptyExpression<\n  Opts extends Options<t.JSXEmptyExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXEmptyExpression & Opts;\nexport function isJSXEmptyExpression<\n  Opts extends Options<t.JSXEmptyExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXEmptyExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXExpressionContainer(\n  node: t.Node | null | undefined,\n): node is t.JSXExpressionContainer;\nexport function isJSXExpressionContainer<\n  Opts extends Options<t.JSXExpressionContainer>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXExpressionContainer & Opts;\nexport function isJSXExpressionContainer<\n  Opts extends Options<t.JSXExpressionContainer>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXExpressionContainer\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXSpreadChild(\n  node: t.Node | null | undefined,\n): node is t.JSXSpreadChild;\nexport function isJSXSpreadChild<Opts extends Options<t.JSXSpreadChild>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXSpreadChild & Opts;\nexport function isJSXSpreadChild<Opts extends Options<t.JSXSpreadChild>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXSpreadChild\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXIdentifier(\n  node: t.Node | null | undefined,\n): node is t.JSXIdentifier;\nexport function isJSXIdentifier<Opts extends Options<t.JSXIdentifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXIdentifier & Opts;\nexport function isJSXIdentifier<Opts extends Options<t.JSXIdentifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXIdentifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXMemberExpression(\n  node: t.Node | null | undefined,\n): node is t.JSXMemberExpression;\nexport function isJSXMemberExpression<\n  Opts extends Options<t.JSXMemberExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXMemberExpression & Opts;\nexport function isJSXMemberExpression<\n  Opts extends Options<t.JSXMemberExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXMemberExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXNamespacedName(\n  node: t.Node | null | undefined,\n): node is t.JSXNamespacedName;\nexport function isJSXNamespacedName<Opts extends Options<t.JSXNamespacedName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXNamespacedName & Opts;\nexport function isJSXNamespacedName<Opts extends Options<t.JSXNamespacedName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXNamespacedName\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXOpeningElement(\n  node: t.Node | null | undefined,\n): node is t.JSXOpeningElement;\nexport function isJSXOpeningElement<Opts extends Options<t.JSXOpeningElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXOpeningElement & Opts;\nexport function isJSXOpeningElement<Opts extends Options<t.JSXOpeningElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXOpeningElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXSpreadAttribute(\n  node: t.Node | null | undefined,\n): node is t.JSXSpreadAttribute;\nexport function isJSXSpreadAttribute<\n  Opts extends Options<t.JSXSpreadAttribute>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXSpreadAttribute & Opts;\nexport function isJSXSpreadAttribute<\n  Opts extends Options<t.JSXSpreadAttribute>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXSpreadAttribute\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXText(node: t.Node | null | undefined): node is t.JSXText;\nexport function isJSXText<Opts extends Options<t.JSXText>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXText & Opts;\nexport function isJSXText<Opts extends Options<t.JSXText>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXText\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXFragment(\n  node: t.Node | null | undefined,\n): node is t.JSXFragment;\nexport function isJSXFragment<Opts extends Options<t.JSXFragment>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXFragment & Opts;\nexport function isJSXFragment<Opts extends Options<t.JSXFragment>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXFragment\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXOpeningFragment(\n  node: t.Node | null | undefined,\n): node is t.JSXOpeningFragment;\nexport function isJSXOpeningFragment<\n  Opts extends Options<t.JSXOpeningFragment>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXOpeningFragment & Opts;\nexport function isJSXOpeningFragment<\n  Opts extends Options<t.JSXOpeningFragment>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXOpeningFragment\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXClosingFragment(\n  node: t.Node | null | undefined,\n): node is t.JSXClosingFragment;\nexport function isJSXClosingFragment<\n  Opts extends Options<t.JSXClosingFragment>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXClosingFragment & Opts;\nexport function isJSXClosingFragment<\n  Opts extends Options<t.JSXClosingFragment>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXClosingFragment\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPlaceholder(\n  node: t.Node | null | undefined,\n): node is t.Placeholder;\nexport function isPlaceholder<Opts extends Options<t.Placeholder>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Placeholder & Opts;\nexport function isPlaceholder<Opts extends Options<t.Placeholder>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Placeholder\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isV8IntrinsicIdentifier(\n  node: t.Node | null | undefined,\n): node is t.V8IntrinsicIdentifier;\nexport function isV8IntrinsicIdentifier<\n  Opts extends Options<t.V8IntrinsicIdentifier>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.V8IntrinsicIdentifier & Opts;\nexport function isV8IntrinsicIdentifier<\n  Opts extends Options<t.V8IntrinsicIdentifier>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"V8IntrinsicIdentifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isArgumentPlaceholder(\n  node: t.Node | null | undefined,\n): node is t.ArgumentPlaceholder;\nexport function isArgumentPlaceholder<\n  Opts extends Options<t.ArgumentPlaceholder>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ArgumentPlaceholder & Opts;\nexport function isArgumentPlaceholder<\n  Opts extends Options<t.ArgumentPlaceholder>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ArgumentPlaceholder\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBindExpression(\n  node: t.Node | null | undefined,\n): node is t.BindExpression;\nexport function isBindExpression<Opts extends Options<t.BindExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BindExpression & Opts;\nexport function isBindExpression<Opts extends Options<t.BindExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BindExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassAccessorProperty(\n  node: t.Node | null | undefined,\n): node is t.ClassAccessorProperty;\nexport function isClassAccessorProperty<\n  Opts extends Options<t.ClassAccessorProperty>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassAccessorProperty & Opts;\nexport function isClassAccessorProperty<\n  Opts extends Options<t.ClassAccessorProperty>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassAccessorProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDecorator(\n  node: t.Node | null | undefined,\n): node is t.Decorator;\nexport function isDecorator<Opts extends Options<t.Decorator>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Decorator & Opts;\nexport function isDecorator<Opts extends Options<t.Decorator>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Decorator\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDoExpression(\n  node: t.Node | null | undefined,\n): node is t.DoExpression;\nexport function isDoExpression<Opts extends Options<t.DoExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DoExpression & Opts;\nexport function isDoExpression<Opts extends Options<t.DoExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DoExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportDefaultSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ExportDefaultSpecifier;\nexport function isExportDefaultSpecifier<\n  Opts extends Options<t.ExportDefaultSpecifier>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportDefaultSpecifier & Opts;\nexport function isExportDefaultSpecifier<\n  Opts extends Options<t.ExportDefaultSpecifier>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExportDefaultSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isModuleExpression(\n  node: t.Node | null | undefined,\n): node is t.ModuleExpression;\nexport function isModuleExpression<Opts extends Options<t.ModuleExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ModuleExpression & Opts;\nexport function isModuleExpression<Opts extends Options<t.ModuleExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ModuleExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTopicReference(\n  node: t.Node | null | undefined,\n): node is t.TopicReference;\nexport function isTopicReference<Opts extends Options<t.TopicReference>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TopicReference & Opts;\nexport function isTopicReference<Opts extends Options<t.TopicReference>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TopicReference\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isVoidPattern(\n  node: t.Node | null | undefined,\n): node is t.VoidPattern;\nexport function isVoidPattern<Opts extends Options<t.VoidPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.VoidPattern & Opts;\nexport function isVoidPattern<Opts extends Options<t.VoidPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"VoidPattern\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSParameterProperty(\n  node: t.Node | null | undefined,\n): node is t.TSParameterProperty;\nexport function isTSParameterProperty<\n  Opts extends Options<t.TSParameterProperty>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSParameterProperty & Opts;\nexport function isTSParameterProperty<\n  Opts extends Options<t.TSParameterProperty>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSParameterProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSDeclareFunction(\n  node: t.Node | null | undefined,\n): node is t.TSDeclareFunction;\nexport function isTSDeclareFunction<Opts extends Options<t.TSDeclareFunction>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSDeclareFunction & Opts;\nexport function isTSDeclareFunction<Opts extends Options<t.TSDeclareFunction>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSDeclareFunction\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSDeclareMethod(\n  node: t.Node | null | undefined,\n): node is t.TSDeclareMethod;\nexport function isTSDeclareMethod<Opts extends Options<t.TSDeclareMethod>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSDeclareMethod & Opts;\nexport function isTSDeclareMethod<Opts extends Options<t.TSDeclareMethod>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSDeclareMethod\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSQualifiedName(\n  node: t.Node | null | undefined,\n): node is t.TSQualifiedName;\nexport function isTSQualifiedName<Opts extends Options<t.TSQualifiedName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSQualifiedName & Opts;\nexport function isTSQualifiedName<Opts extends Options<t.TSQualifiedName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSQualifiedName\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSCallSignatureDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSCallSignatureDeclaration;\nexport function isTSCallSignatureDeclaration<\n  Opts extends Options<t.TSCallSignatureDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSCallSignatureDeclaration & Opts;\nexport function isTSCallSignatureDeclaration<\n  Opts extends Options<t.TSCallSignatureDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSCallSignatureDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSConstructSignatureDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSConstructSignatureDeclaration;\nexport function isTSConstructSignatureDeclaration<\n  Opts extends Options<t.TSConstructSignatureDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSConstructSignatureDeclaration & Opts;\nexport function isTSConstructSignatureDeclaration<\n  Opts extends Options<t.TSConstructSignatureDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSConstructSignatureDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSPropertySignature(\n  node: t.Node | null | undefined,\n): node is t.TSPropertySignature;\nexport function isTSPropertySignature<\n  Opts extends Options<t.TSPropertySignature>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSPropertySignature & Opts;\nexport function isTSPropertySignature<\n  Opts extends Options<t.TSPropertySignature>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSPropertySignature\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSMethodSignature(\n  node: t.Node | null | undefined,\n): node is t.TSMethodSignature;\nexport function isTSMethodSignature<Opts extends Options<t.TSMethodSignature>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSMethodSignature & Opts;\nexport function isTSMethodSignature<Opts extends Options<t.TSMethodSignature>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSMethodSignature\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSIndexSignature(\n  node: t.Node | null | undefined,\n): node is t.TSIndexSignature;\nexport function isTSIndexSignature<Opts extends Options<t.TSIndexSignature>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSIndexSignature & Opts;\nexport function isTSIndexSignature<Opts extends Options<t.TSIndexSignature>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSIndexSignature\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSAnyKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSAnyKeyword;\nexport function isTSAnyKeyword<Opts extends Options<t.TSAnyKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSAnyKeyword & Opts;\nexport function isTSAnyKeyword<Opts extends Options<t.TSAnyKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSAnyKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSBooleanKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSBooleanKeyword;\nexport function isTSBooleanKeyword<Opts extends Options<t.TSBooleanKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSBooleanKeyword & Opts;\nexport function isTSBooleanKeyword<Opts extends Options<t.TSBooleanKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSBooleanKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSBigIntKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSBigIntKeyword;\nexport function isTSBigIntKeyword<Opts extends Options<t.TSBigIntKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSBigIntKeyword & Opts;\nexport function isTSBigIntKeyword<Opts extends Options<t.TSBigIntKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSBigIntKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSIntrinsicKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSIntrinsicKeyword;\nexport function isTSIntrinsicKeyword<\n  Opts extends Options<t.TSIntrinsicKeyword>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSIntrinsicKeyword & Opts;\nexport function isTSIntrinsicKeyword<\n  Opts extends Options<t.TSIntrinsicKeyword>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSIntrinsicKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNeverKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSNeverKeyword;\nexport function isTSNeverKeyword<Opts extends Options<t.TSNeverKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSNeverKeyword & Opts;\nexport function isTSNeverKeyword<Opts extends Options<t.TSNeverKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSNeverKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNullKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSNullKeyword;\nexport function isTSNullKeyword<Opts extends Options<t.TSNullKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSNullKeyword & Opts;\nexport function isTSNullKeyword<Opts extends Options<t.TSNullKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSNullKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNumberKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSNumberKeyword;\nexport function isTSNumberKeyword<Opts extends Options<t.TSNumberKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSNumberKeyword & Opts;\nexport function isTSNumberKeyword<Opts extends Options<t.TSNumberKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSNumberKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSObjectKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSObjectKeyword;\nexport function isTSObjectKeyword<Opts extends Options<t.TSObjectKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSObjectKeyword & Opts;\nexport function isTSObjectKeyword<Opts extends Options<t.TSObjectKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSObjectKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSStringKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSStringKeyword;\nexport function isTSStringKeyword<Opts extends Options<t.TSStringKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSStringKeyword & Opts;\nexport function isTSStringKeyword<Opts extends Options<t.TSStringKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSStringKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSSymbolKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSSymbolKeyword;\nexport function isTSSymbolKeyword<Opts extends Options<t.TSSymbolKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSSymbolKeyword & Opts;\nexport function isTSSymbolKeyword<Opts extends Options<t.TSSymbolKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSSymbolKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSUndefinedKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSUndefinedKeyword;\nexport function isTSUndefinedKeyword<\n  Opts extends Options<t.TSUndefinedKeyword>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSUndefinedKeyword & Opts;\nexport function isTSUndefinedKeyword<\n  Opts extends Options<t.TSUndefinedKeyword>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSUndefinedKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSUnknownKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSUnknownKeyword;\nexport function isTSUnknownKeyword<Opts extends Options<t.TSUnknownKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSUnknownKeyword & Opts;\nexport function isTSUnknownKeyword<Opts extends Options<t.TSUnknownKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSUnknownKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSVoidKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSVoidKeyword;\nexport function isTSVoidKeyword<Opts extends Options<t.TSVoidKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSVoidKeyword & Opts;\nexport function isTSVoidKeyword<Opts extends Options<t.TSVoidKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSVoidKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSThisType(\n  node: t.Node | null | undefined,\n): node is t.TSThisType;\nexport function isTSThisType<Opts extends Options<t.TSThisType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSThisType & Opts;\nexport function isTSThisType<Opts extends Options<t.TSThisType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSThisType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSFunctionType(\n  node: t.Node | null | undefined,\n): node is t.TSFunctionType;\nexport function isTSFunctionType<Opts extends Options<t.TSFunctionType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSFunctionType & Opts;\nexport function isTSFunctionType<Opts extends Options<t.TSFunctionType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSFunctionType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSConstructorType(\n  node: t.Node | null | undefined,\n): node is t.TSConstructorType;\nexport function isTSConstructorType<Opts extends Options<t.TSConstructorType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSConstructorType & Opts;\nexport function isTSConstructorType<Opts extends Options<t.TSConstructorType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSConstructorType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeReference(\n  node: t.Node | null | undefined,\n): node is t.TSTypeReference;\nexport function isTSTypeReference<Opts extends Options<t.TSTypeReference>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeReference & Opts;\nexport function isTSTypeReference<Opts extends Options<t.TSTypeReference>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeReference\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypePredicate(\n  node: t.Node | null | undefined,\n): node is t.TSTypePredicate;\nexport function isTSTypePredicate<Opts extends Options<t.TSTypePredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypePredicate & Opts;\nexport function isTSTypePredicate<Opts extends Options<t.TSTypePredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypePredicate\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeQuery(\n  node: t.Node | null | undefined,\n): node is t.TSTypeQuery;\nexport function isTSTypeQuery<Opts extends Options<t.TSTypeQuery>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeQuery & Opts;\nexport function isTSTypeQuery<Opts extends Options<t.TSTypeQuery>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeQuery\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeLiteral(\n  node: t.Node | null | undefined,\n): node is t.TSTypeLiteral;\nexport function isTSTypeLiteral<Opts extends Options<t.TSTypeLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeLiteral & Opts;\nexport function isTSTypeLiteral<Opts extends Options<t.TSTypeLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSArrayType(\n  node: t.Node | null | undefined,\n): node is t.TSArrayType;\nexport function isTSArrayType<Opts extends Options<t.TSArrayType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSArrayType & Opts;\nexport function isTSArrayType<Opts extends Options<t.TSArrayType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSArrayType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTupleType(\n  node: t.Node | null | undefined,\n): node is t.TSTupleType;\nexport function isTSTupleType<Opts extends Options<t.TSTupleType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTupleType & Opts;\nexport function isTSTupleType<Opts extends Options<t.TSTupleType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTupleType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSOptionalType(\n  node: t.Node | null | undefined,\n): node is t.TSOptionalType;\nexport function isTSOptionalType<Opts extends Options<t.TSOptionalType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSOptionalType & Opts;\nexport function isTSOptionalType<Opts extends Options<t.TSOptionalType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSOptionalType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSRestType(\n  node: t.Node | null | undefined,\n): node is t.TSRestType;\nexport function isTSRestType<Opts extends Options<t.TSRestType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSRestType & Opts;\nexport function isTSRestType<Opts extends Options<t.TSRestType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSRestType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNamedTupleMember(\n  node: t.Node | null | undefined,\n): node is t.TSNamedTupleMember;\nexport function isTSNamedTupleMember<\n  Opts extends Options<t.TSNamedTupleMember>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSNamedTupleMember & Opts;\nexport function isTSNamedTupleMember<\n  Opts extends Options<t.TSNamedTupleMember>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSNamedTupleMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSUnionType(\n  node: t.Node | null | undefined,\n): node is t.TSUnionType;\nexport function isTSUnionType<Opts extends Options<t.TSUnionType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSUnionType & Opts;\nexport function isTSUnionType<Opts extends Options<t.TSUnionType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSUnionType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSIntersectionType(\n  node: t.Node | null | undefined,\n): node is t.TSIntersectionType;\nexport function isTSIntersectionType<\n  Opts extends Options<t.TSIntersectionType>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSIntersectionType & Opts;\nexport function isTSIntersectionType<\n  Opts extends Options<t.TSIntersectionType>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSIntersectionType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSConditionalType(\n  node: t.Node | null | undefined,\n): node is t.TSConditionalType;\nexport function isTSConditionalType<Opts extends Options<t.TSConditionalType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSConditionalType & Opts;\nexport function isTSConditionalType<Opts extends Options<t.TSConditionalType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSConditionalType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSInferType(\n  node: t.Node | null | undefined,\n): node is t.TSInferType;\nexport function isTSInferType<Opts extends Options<t.TSInferType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSInferType & Opts;\nexport function isTSInferType<Opts extends Options<t.TSInferType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSInferType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSParenthesizedType(\n  node: t.Node | null | undefined,\n): node is t.TSParenthesizedType;\nexport function isTSParenthesizedType<\n  Opts extends Options<t.TSParenthesizedType>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSParenthesizedType & Opts;\nexport function isTSParenthesizedType<\n  Opts extends Options<t.TSParenthesizedType>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSParenthesizedType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeOperator(\n  node: t.Node | null | undefined,\n): node is t.TSTypeOperator;\nexport function isTSTypeOperator<Opts extends Options<t.TSTypeOperator>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeOperator & Opts;\nexport function isTSTypeOperator<Opts extends Options<t.TSTypeOperator>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeOperator\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSIndexedAccessType(\n  node: t.Node | null | undefined,\n): node is t.TSIndexedAccessType;\nexport function isTSIndexedAccessType<\n  Opts extends Options<t.TSIndexedAccessType>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSIndexedAccessType & Opts;\nexport function isTSIndexedAccessType<\n  Opts extends Options<t.TSIndexedAccessType>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSIndexedAccessType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSMappedType(\n  node: t.Node | null | undefined,\n): node is t.TSMappedType;\nexport function isTSMappedType<Opts extends Options<t.TSMappedType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSMappedType & Opts;\nexport function isTSMappedType<Opts extends Options<t.TSMappedType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSMappedType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTemplateLiteralType(\n  node: t.Node | null | undefined,\n): node is t.TSTemplateLiteralType;\nexport function isTSTemplateLiteralType<\n  Opts extends Options<t.TSTemplateLiteralType>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTemplateLiteralType & Opts;\nexport function isTSTemplateLiteralType<\n  Opts extends Options<t.TSTemplateLiteralType>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTemplateLiteralType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSLiteralType(\n  node: t.Node | null | undefined,\n): node is t.TSLiteralType;\nexport function isTSLiteralType<Opts extends Options<t.TSLiteralType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSLiteralType & Opts;\nexport function isTSLiteralType<Opts extends Options<t.TSLiteralType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSLiteralType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSClassImplements(\n  node: t.Node | null | undefined,\n): node is t.TSClassImplements;\nexport function isTSClassImplements<Opts extends Options<t.TSClassImplements>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSClassImplements & Opts;\nexport function isTSClassImplements<Opts extends Options<t.TSClassImplements>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSClassImplements\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSInterfaceHeritage(\n  node: t.Node | null | undefined,\n): node is t.TSInterfaceHeritage;\nexport function isTSInterfaceHeritage<\n  Opts extends Options<t.TSInterfaceHeritage>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSInterfaceHeritage & Opts;\nexport function isTSInterfaceHeritage<\n  Opts extends Options<t.TSInterfaceHeritage>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSInterfaceHeritage\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSInterfaceDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSInterfaceDeclaration;\nexport function isTSInterfaceDeclaration<\n  Opts extends Options<t.TSInterfaceDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSInterfaceDeclaration & Opts;\nexport function isTSInterfaceDeclaration<\n  Opts extends Options<t.TSInterfaceDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSInterfaceDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSInterfaceBody(\n  node: t.Node | null | undefined,\n): node is t.TSInterfaceBody;\nexport function isTSInterfaceBody<Opts extends Options<t.TSInterfaceBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSInterfaceBody & Opts;\nexport function isTSInterfaceBody<Opts extends Options<t.TSInterfaceBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSInterfaceBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeAliasDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSTypeAliasDeclaration;\nexport function isTSTypeAliasDeclaration<\n  Opts extends Options<t.TSTypeAliasDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeAliasDeclaration & Opts;\nexport function isTSTypeAliasDeclaration<\n  Opts extends Options<t.TSTypeAliasDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeAliasDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSInstantiationExpression(\n  node: t.Node | null | undefined,\n): node is t.TSInstantiationExpression;\nexport function isTSInstantiationExpression<\n  Opts extends Options<t.TSInstantiationExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSInstantiationExpression & Opts;\nexport function isTSInstantiationExpression<\n  Opts extends Options<t.TSInstantiationExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSInstantiationExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSAsExpression(\n  node: t.Node | null | undefined,\n): node is t.TSAsExpression;\nexport function isTSAsExpression<Opts extends Options<t.TSAsExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSAsExpression & Opts;\nexport function isTSAsExpression<Opts extends Options<t.TSAsExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSAsExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSSatisfiesExpression(\n  node: t.Node | null | undefined,\n): node is t.TSSatisfiesExpression;\nexport function isTSSatisfiesExpression<\n  Opts extends Options<t.TSSatisfiesExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSSatisfiesExpression & Opts;\nexport function isTSSatisfiesExpression<\n  Opts extends Options<t.TSSatisfiesExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSSatisfiesExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeAssertion(\n  node: t.Node | null | undefined,\n): node is t.TSTypeAssertion;\nexport function isTSTypeAssertion<Opts extends Options<t.TSTypeAssertion>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeAssertion & Opts;\nexport function isTSTypeAssertion<Opts extends Options<t.TSTypeAssertion>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeAssertion\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSEnumBody(\n  node: t.Node | null | undefined,\n): node is t.TSEnumBody;\nexport function isTSEnumBody<Opts extends Options<t.TSEnumBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSEnumBody & Opts;\nexport function isTSEnumBody<Opts extends Options<t.TSEnumBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSEnumBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSEnumDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSEnumDeclaration;\nexport function isTSEnumDeclaration<Opts extends Options<t.TSEnumDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSEnumDeclaration & Opts;\nexport function isTSEnumDeclaration<Opts extends Options<t.TSEnumDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSEnumDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSEnumMember(\n  node: t.Node | null | undefined,\n): node is t.TSEnumMember;\nexport function isTSEnumMember<Opts extends Options<t.TSEnumMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSEnumMember & Opts;\nexport function isTSEnumMember<Opts extends Options<t.TSEnumMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSEnumMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSModuleDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSModuleDeclaration;\nexport function isTSModuleDeclaration<\n  Opts extends Options<t.TSModuleDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSModuleDeclaration & Opts;\nexport function isTSModuleDeclaration<\n  Opts extends Options<t.TSModuleDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSModuleDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSModuleBlock(\n  node: t.Node | null | undefined,\n): node is t.TSModuleBlock;\nexport function isTSModuleBlock<Opts extends Options<t.TSModuleBlock>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSModuleBlock & Opts;\nexport function isTSModuleBlock<Opts extends Options<t.TSModuleBlock>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSModuleBlock\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSImportType(\n  node: t.Node | null | undefined,\n): node is t.TSImportType;\nexport function isTSImportType<Opts extends Options<t.TSImportType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSImportType & Opts;\nexport function isTSImportType<Opts extends Options<t.TSImportType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSImportType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSImportEqualsDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSImportEqualsDeclaration;\nexport function isTSImportEqualsDeclaration<\n  Opts extends Options<t.TSImportEqualsDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSImportEqualsDeclaration & Opts;\nexport function isTSImportEqualsDeclaration<\n  Opts extends Options<t.TSImportEqualsDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSImportEqualsDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSExternalModuleReference(\n  node: t.Node | null | undefined,\n): node is t.TSExternalModuleReference;\nexport function isTSExternalModuleReference<\n  Opts extends Options<t.TSExternalModuleReference>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSExternalModuleReference & Opts;\nexport function isTSExternalModuleReference<\n  Opts extends Options<t.TSExternalModuleReference>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSExternalModuleReference\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNonNullExpression(\n  node: t.Node | null | undefined,\n): node is t.TSNonNullExpression;\nexport function isTSNonNullExpression<\n  Opts extends Options<t.TSNonNullExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSNonNullExpression & Opts;\nexport function isTSNonNullExpression<\n  Opts extends Options<t.TSNonNullExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSNonNullExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSExportAssignment(\n  node: t.Node | null | undefined,\n): node is t.TSExportAssignment;\nexport function isTSExportAssignment<\n  Opts extends Options<t.TSExportAssignment>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSExportAssignment & Opts;\nexport function isTSExportAssignment<\n  Opts extends Options<t.TSExportAssignment>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSExportAssignment\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNamespaceExportDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSNamespaceExportDeclaration;\nexport function isTSNamespaceExportDeclaration<\n  Opts extends Options<t.TSNamespaceExportDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSNamespaceExportDeclaration & Opts;\nexport function isTSNamespaceExportDeclaration<\n  Opts extends Options<t.TSNamespaceExportDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSNamespaceExportDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.TSTypeAnnotation;\nexport function isTSTypeAnnotation<Opts extends Options<t.TSTypeAnnotation>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeAnnotation & Opts;\nexport function isTSTypeAnnotation<Opts extends Options<t.TSTypeAnnotation>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeParameterInstantiation(\n  node: t.Node | null | undefined,\n): node is t.TSTypeParameterInstantiation;\nexport function isTSTypeParameterInstantiation<\n  Opts extends Options<t.TSTypeParameterInstantiation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeParameterInstantiation & Opts;\nexport function isTSTypeParameterInstantiation<\n  Opts extends Options<t.TSTypeParameterInstantiation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeParameterInstantiation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeParameterDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSTypeParameterDeclaration;\nexport function isTSTypeParameterDeclaration<\n  Opts extends Options<t.TSTypeParameterDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeParameterDeclaration & Opts;\nexport function isTSTypeParameterDeclaration<\n  Opts extends Options<t.TSTypeParameterDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeParameterDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeParameter(\n  node: t.Node | null | undefined,\n): node is t.TSTypeParameter;\nexport function isTSTypeParameter<Opts extends Options<t.TSTypeParameter>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeParameter & Opts;\nexport function isTSTypeParameter<Opts extends Options<t.TSTypeParameter>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeParameter\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStandardized(\n  node: t.Node | null | undefined,\n): node is t.Standardized;\nexport function isStandardized<Opts extends Options<t.Standardized>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Standardized & Opts;\nexport function isStandardized<Opts extends Options<t.Standardized>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ArrayExpression\":\n    case \"AssignmentExpression\":\n    case \"BinaryExpression\":\n    case \"InterpreterDirective\":\n    case \"Directive\":\n    case \"DirectiveLiteral\":\n    case \"BlockStatement\":\n    case \"BreakStatement\":\n    case \"CallExpression\":\n    case \"CatchClause\":\n    case \"ConditionalExpression\":\n    case \"ContinueStatement\":\n    case \"DebuggerStatement\":\n    case \"DoWhileStatement\":\n    case \"EmptyStatement\":\n    case \"ExpressionStatement\":\n    case \"File\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"Identifier\":\n    case \"IfStatement\":\n    case \"LabeledStatement\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"LogicalExpression\":\n    case \"MemberExpression\":\n    case \"NewExpression\":\n    case \"Program\":\n    case \"ObjectExpression\":\n    case \"ObjectMethod\":\n    case \"ObjectProperty\":\n    case \"RestElement\":\n    case \"ReturnStatement\":\n    case \"SequenceExpression\":\n    case \"ParenthesizedExpression\":\n    case \"SwitchCase\":\n    case \"SwitchStatement\":\n    case \"ThisExpression\":\n    case \"ThrowStatement\":\n    case \"TryStatement\":\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n    case \"VariableDeclaration\":\n    case \"VariableDeclarator\":\n    case \"WhileStatement\":\n    case \"WithStatement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassBody\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ExportSpecifier\":\n    case \"ForOfStatement\":\n    case \"ImportDeclaration\":\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n    case \"ImportExpression\":\n    case \"MetaProperty\":\n    case \"ClassMethod\":\n    case \"ObjectPattern\":\n    case \"SpreadElement\":\n    case \"Super\":\n    case \"TaggedTemplateExpression\":\n    case \"TemplateElement\":\n    case \"TemplateLiteral\":\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n    case \"Import\":\n    case \"BigIntLiteral\":\n    case \"ExportNamespaceSpecifier\":\n    case \"OptionalMemberExpression\":\n    case \"OptionalCallExpression\":\n    case \"ClassProperty\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n    case \"PrivateName\":\n    case \"StaticBlock\":\n    case \"ImportAttribute\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Identifier\":\n        case \"StringLiteral\":\n        case \"BlockStatement\":\n        case \"ClassBody\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExpression(\n  node: t.Node | null | undefined,\n): node is t.Expression;\nexport function isExpression<Opts extends Options<t.Expression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Expression & Opts;\nexport function isExpression<Opts extends Options<t.Expression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ArrayExpression\":\n    case \"AssignmentExpression\":\n    case \"BinaryExpression\":\n    case \"CallExpression\":\n    case \"ConditionalExpression\":\n    case \"FunctionExpression\":\n    case \"Identifier\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"LogicalExpression\":\n    case \"MemberExpression\":\n    case \"NewExpression\":\n    case \"ObjectExpression\":\n    case \"SequenceExpression\":\n    case \"ParenthesizedExpression\":\n    case \"ThisExpression\":\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassExpression\":\n    case \"ImportExpression\":\n    case \"MetaProperty\":\n    case \"TaggedTemplateExpression\":\n    case \"TemplateLiteral\":\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n    case \"Import\":\n    case \"BigIntLiteral\":\n    case \"OptionalMemberExpression\":\n    case \"OptionalCallExpression\":\n    case \"TypeCastExpression\":\n    case \"JSXElement\":\n    case \"JSXFragment\":\n    case \"BindExpression\":\n    case \"DoExpression\":\n    case \"ModuleExpression\":\n    case \"TopicReference\":\n    case \"TSInstantiationExpression\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSNonNullExpression\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Expression\":\n        case \"Identifier\":\n        case \"StringLiteral\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBinary(node: t.Node | null | undefined): node is t.Binary;\nexport function isBinary<Opts extends Options<t.Binary>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Binary & Opts;\nexport function isBinary<Opts extends Options<t.Binary>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isScopable(node: t.Node | null | undefined): node is t.Scopable;\nexport function isScopable<Opts extends Options<t.Scopable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Scopable & Opts;\nexport function isScopable<Opts extends Options<t.Scopable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"CatchClause\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"Program\":\n    case \"ObjectMethod\":\n    case \"SwitchStatement\":\n    case \"WhileStatement\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n    case \"ForOfStatement\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"StaticBlock\":\n    case \"TSModuleBlock\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"BlockStatement\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBlockParent(\n  node: t.Node | null | undefined,\n): node is t.BlockParent;\nexport function isBlockParent<Opts extends Options<t.BlockParent>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BlockParent & Opts;\nexport function isBlockParent<Opts extends Options<t.BlockParent>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"CatchClause\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"Program\":\n    case \"ObjectMethod\":\n    case \"SwitchStatement\":\n    case \"WhileStatement\":\n    case \"ArrowFunctionExpression\":\n    case \"ForOfStatement\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"StaticBlock\":\n    case \"TSModuleBlock\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"BlockStatement\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBlock(node: t.Node | null | undefined): node is t.Block;\nexport function isBlock<Opts extends Options<t.Block>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Block & Opts;\nexport function isBlock<Opts extends Options<t.Block>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"Program\":\n    case \"TSModuleBlock\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"BlockStatement\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStatement(\n  node: t.Node | null | undefined,\n): node is t.Statement;\nexport function isStatement<Opts extends Options<t.Statement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Statement & Opts;\nexport function isStatement<Opts extends Options<t.Statement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"DebuggerStatement\":\n    case \"DoWhileStatement\":\n    case \"EmptyStatement\":\n    case \"ExpressionStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"IfStatement\":\n    case \"LabeledStatement\":\n    case \"ReturnStatement\":\n    case \"SwitchStatement\":\n    case \"ThrowStatement\":\n    case \"TryStatement\":\n    case \"VariableDeclaration\":\n    case \"WhileStatement\":\n    case \"WithStatement\":\n    case \"ClassDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ForOfStatement\":\n    case \"ImportDeclaration\":\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"InterfaceDeclaration\":\n    case \"OpaqueType\":\n    case \"TypeAlias\":\n    case \"EnumDeclaration\":\n    case \"TSDeclareFunction\":\n    case \"TSInterfaceDeclaration\":\n    case \"TSTypeAliasDeclaration\":\n    case \"TSEnumDeclaration\":\n    case \"TSModuleDeclaration\":\n    case \"TSImportEqualsDeclaration\":\n    case \"TSExportAssignment\":\n    case \"TSNamespaceExportDeclaration\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Statement\":\n        case \"Declaration\":\n        case \"BlockStatement\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTerminatorless(\n  node: t.Node | null | undefined,\n): node is t.Terminatorless;\nexport function isTerminatorless<Opts extends Options<t.Terminatorless>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Terminatorless & Opts;\nexport function isTerminatorless<Opts extends Options<t.Terminatorless>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"ReturnStatement\":\n    case \"ThrowStatement\":\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isCompletionStatement(\n  node: t.Node | null | undefined,\n): node is t.CompletionStatement;\nexport function isCompletionStatement<\n  Opts extends Options<t.CompletionStatement>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.CompletionStatement & Opts;\nexport function isCompletionStatement<\n  Opts extends Options<t.CompletionStatement>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"ReturnStatement\":\n    case \"ThrowStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isConditional(\n  node: t.Node | null | undefined,\n): node is t.Conditional;\nexport function isConditional<Opts extends Options<t.Conditional>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Conditional & Opts;\nexport function isConditional<Opts extends Options<t.Conditional>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isLoop(node: t.Node | null | undefined): node is t.Loop;\nexport function isLoop<Opts extends Options<t.Loop>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Loop & Opts;\nexport function isLoop<Opts extends Options<t.Loop>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"WhileStatement\":\n    case \"ForOfStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isWhile(node: t.Node | null | undefined): node is t.While;\nexport function isWhile<Opts extends Options<t.While>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.While & Opts;\nexport function isWhile<Opts extends Options<t.While>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"DoWhileStatement\":\n    case \"WhileStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExpressionWrapper(\n  node: t.Node | null | undefined,\n): node is t.ExpressionWrapper;\nexport function isExpressionWrapper<Opts extends Options<t.ExpressionWrapper>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExpressionWrapper & Opts;\nexport function isExpressionWrapper<Opts extends Options<t.ExpressionWrapper>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ExpressionStatement\":\n    case \"ParenthesizedExpression\":\n    case \"TypeCastExpression\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFor(node: t.Node | null | undefined): node is t.For;\nexport function isFor<Opts extends Options<t.For>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.For & Opts;\nexport function isFor<Opts extends Options<t.For>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"ForOfStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isForXStatement(\n  node: t.Node | null | undefined,\n): node is t.ForXStatement;\nexport function isForXStatement<Opts extends Options<t.ForXStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ForXStatement & Opts;\nexport function isForXStatement<Opts extends Options<t.ForXStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunction(node: t.Node | null | undefined): node is t.Function;\nexport function isFunction<Opts extends Options<t.Function>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Function & Opts;\nexport function isFunction<Opts extends Options<t.Function>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ObjectMethod\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionParent(\n  node: t.Node | null | undefined,\n): node is t.FunctionParent;\nexport function isFunctionParent<Opts extends Options<t.FunctionParent>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FunctionParent & Opts;\nexport function isFunctionParent<Opts extends Options<t.FunctionParent>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ObjectMethod\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"StaticBlock\":\n    case \"TSModuleBlock\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPureish(node: t.Node | null | undefined): node is t.Pureish;\nexport function isPureish<Opts extends Options<t.Pureish>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Pureish & Opts;\nexport function isPureish<Opts extends Options<t.Pureish>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"ArrowFunctionExpression\":\n    case \"BigIntLiteral\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"StringLiteral\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclaration(\n  node: t.Node | null | undefined,\n): node is t.Declaration;\nexport function isDeclaration<Opts extends Options<t.Declaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Declaration & Opts;\nexport function isDeclaration<Opts extends Options<t.Declaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"VariableDeclaration\":\n    case \"ClassDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ImportDeclaration\":\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"InterfaceDeclaration\":\n    case \"OpaqueType\":\n    case \"TypeAlias\":\n    case \"EnumDeclaration\":\n    case \"TSDeclareFunction\":\n    case \"TSInterfaceDeclaration\":\n    case \"TSTypeAliasDeclaration\":\n    case \"TSEnumDeclaration\":\n    case \"TSModuleDeclaration\":\n    case \"TSImportEqualsDeclaration\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Declaration\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionParameter(\n  node: t.Node | null | undefined,\n): node is t.FunctionParameter;\nexport function isFunctionParameter<Opts extends Options<t.FunctionParameter>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FunctionParameter & Opts;\nexport function isFunctionParameter<Opts extends Options<t.FunctionParameter>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"Identifier\":\n    case \"RestElement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"VoidPattern\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Identifier\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPatternLike(\n  node: t.Node | null | undefined,\n): node is t.PatternLike;\nexport function isPatternLike<Opts extends Options<t.PatternLike>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.PatternLike & Opts;\nexport function isPatternLike<Opts extends Options<t.PatternLike>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\":\n    case \"RestElement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"VoidPattern\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSNonNullExpression\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Pattern\":\n        case \"Identifier\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isLVal(node: t.Node | null | undefined): node is t.LVal;\nexport function isLVal<Opts extends Options<t.LVal>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.LVal & Opts;\nexport function isLVal<Opts extends Options<t.LVal>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSNonNullExpression\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Pattern\":\n        case \"Identifier\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSEntityName(\n  node: t.Node | null | undefined,\n): node is t.TSEntityName;\nexport function isTSEntityName<Opts extends Options<t.TSEntityName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSEntityName & Opts;\nexport function isTSEntityName<Opts extends Options<t.TSEntityName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"Identifier\":\n    case \"ThisExpression\":\n    case \"TSQualifiedName\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Identifier\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isLiteral(node: t.Node | null | undefined): node is t.Literal;\nexport function isLiteral<Opts extends Options<t.Literal>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Literal & Opts;\nexport function isLiteral<Opts extends Options<t.Literal>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"TemplateLiteral\":\n    case \"BigIntLiteral\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"StringLiteral\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImmutable(\n  node: t.Node | null | undefined,\n): node is t.Immutable;\nexport function isImmutable<Opts extends Options<t.Immutable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Immutable & Opts;\nexport function isImmutable<Opts extends Options<t.Immutable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"BigIntLiteral\":\n    case \"JSXAttribute\":\n    case \"JSXClosingElement\":\n    case \"JSXElement\":\n    case \"JSXExpressionContainer\":\n    case \"JSXSpreadChild\":\n    case \"JSXOpeningElement\":\n    case \"JSXText\":\n    case \"JSXFragment\":\n    case \"JSXOpeningFragment\":\n    case \"JSXClosingFragment\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"StringLiteral\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isUserWhitespacable(\n  node: t.Node | null | undefined,\n): node is t.UserWhitespacable;\nexport function isUserWhitespacable<Opts extends Options<t.UserWhitespacable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.UserWhitespacable & Opts;\nexport function isUserWhitespacable<Opts extends Options<t.UserWhitespacable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ObjectMethod\":\n    case \"ObjectProperty\":\n    case \"ObjectTypeInternalSlot\":\n    case \"ObjectTypeCallProperty\":\n    case \"ObjectTypeIndexer\":\n    case \"ObjectTypeProperty\":\n    case \"ObjectTypeSpreadProperty\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isMethod(node: t.Node | null | undefined): node is t.Method;\nexport function isMethod<Opts extends Options<t.Method>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Method & Opts;\nexport function isMethod<Opts extends Options<t.Method>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ObjectMethod\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectMember(\n  node: t.Node | null | undefined,\n): node is t.ObjectMember;\nexport function isObjectMember<Opts extends Options<t.ObjectMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectMember & Opts;\nexport function isObjectMember<Opts extends Options<t.ObjectMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ObjectMethod\":\n    case \"ObjectProperty\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isProperty(node: t.Node | null | undefined): node is t.Property;\nexport function isProperty<Opts extends Options<t.Property>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Property & Opts;\nexport function isProperty<Opts extends Options<t.Property>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ObjectProperty\":\n    case \"ClassProperty\":\n    case \"ClassPrivateProperty\":\n    case \"ClassAccessorProperty\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isUnaryLike(\n  node: t.Node | null | undefined,\n): node is t.UnaryLike;\nexport function isUnaryLike<Opts extends Options<t.UnaryLike>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.UnaryLike & Opts;\nexport function isUnaryLike<Opts extends Options<t.UnaryLike>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"UnaryExpression\":\n    case \"SpreadElement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPattern(node: t.Node | null | undefined): node is t.Pattern;\nexport function isPattern<Opts extends Options<t.Pattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Pattern & Opts;\nexport function isPattern<Opts extends Options<t.Pattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"VoidPattern\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Pattern\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClass(node: t.Node | null | undefined): node is t.Class;\nexport function isClass<Opts extends Options<t.Class>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Class & Opts;\nexport function isClass<Opts extends Options<t.Class>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportOrExportDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ImportOrExportDeclaration;\nexport function isImportOrExportDeclaration<\n  Opts extends Options<t.ImportOrExportDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportOrExportDeclaration & Opts;\nexport function isImportOrExportDeclaration<\n  Opts extends Options<t.ImportOrExportDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ImportDeclaration\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ExportDeclaration;\nexport function isExportDeclaration<Opts extends Options<t.ExportDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportDeclaration & Opts;\nexport function isExportDeclaration<Opts extends Options<t.ExportDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isModuleSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ModuleSpecifier;\nexport function isModuleSpecifier<Opts extends Options<t.ModuleSpecifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ModuleSpecifier & Opts;\nexport function isModuleSpecifier<Opts extends Options<t.ModuleSpecifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ExportSpecifier\":\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPrivate(node: t.Node | null | undefined): node is t.Private;\nexport function isPrivate<Opts extends Options<t.Private>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Private & Opts;\nexport function isPrivate<Opts extends Options<t.Private>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n    case \"PrivateName\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFlow(node: t.Node | null | undefined): node is t.Flow;\nexport function isFlow<Opts extends Options<t.Flow>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Flow & Opts;\nexport function isFlow<Opts extends Options<t.Flow>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"AnyTypeAnnotation\":\n    case \"ArrayTypeAnnotation\":\n    case \"BooleanTypeAnnotation\":\n    case \"BooleanLiteralTypeAnnotation\":\n    case \"NullLiteralTypeAnnotation\":\n    case \"ClassImplements\":\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"DeclaredPredicate\":\n    case \"ExistsTypeAnnotation\":\n    case \"FunctionTypeAnnotation\":\n    case \"FunctionTypeParam\":\n    case \"GenericTypeAnnotation\":\n    case \"InferredPredicate\":\n    case \"InterfaceExtends\":\n    case \"InterfaceDeclaration\":\n    case \"InterfaceTypeAnnotation\":\n    case \"IntersectionTypeAnnotation\":\n    case \"MixedTypeAnnotation\":\n    case \"EmptyTypeAnnotation\":\n    case \"NullableTypeAnnotation\":\n    case \"NumberLiteralTypeAnnotation\":\n    case \"NumberTypeAnnotation\":\n    case \"ObjectTypeAnnotation\":\n    case \"ObjectTypeInternalSlot\":\n    case \"ObjectTypeCallProperty\":\n    case \"ObjectTypeIndexer\":\n    case \"ObjectTypeProperty\":\n    case \"ObjectTypeSpreadProperty\":\n    case \"OpaqueType\":\n    case \"QualifiedTypeIdentifier\":\n    case \"StringLiteralTypeAnnotation\":\n    case \"StringTypeAnnotation\":\n    case \"SymbolTypeAnnotation\":\n    case \"ThisTypeAnnotation\":\n    case \"TupleTypeAnnotation\":\n    case \"TypeofTypeAnnotation\":\n    case \"TypeAlias\":\n    case \"TypeAnnotation\":\n    case \"TypeCastExpression\":\n    case \"TypeParameter\":\n    case \"TypeParameterDeclaration\":\n    case \"TypeParameterInstantiation\":\n    case \"UnionTypeAnnotation\":\n    case \"Variance\":\n    case \"VoidTypeAnnotation\":\n    case \"EnumDeclaration\":\n    case \"EnumBooleanBody\":\n    case \"EnumNumberBody\":\n    case \"EnumStringBody\":\n    case \"EnumSymbolBody\":\n    case \"EnumBooleanMember\":\n    case \"EnumNumberMember\":\n    case \"EnumStringMember\":\n    case \"EnumDefaultedMember\":\n    case \"IndexedAccessType\":\n    case \"OptionalIndexedAccessType\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFlowType(node: t.Node | null | undefined): node is t.FlowType;\nexport function isFlowType<Opts extends Options<t.FlowType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FlowType & Opts;\nexport function isFlowType<Opts extends Options<t.FlowType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"AnyTypeAnnotation\":\n    case \"ArrayTypeAnnotation\":\n    case \"BooleanTypeAnnotation\":\n    case \"BooleanLiteralTypeAnnotation\":\n    case \"NullLiteralTypeAnnotation\":\n    case \"ExistsTypeAnnotation\":\n    case \"FunctionTypeAnnotation\":\n    case \"GenericTypeAnnotation\":\n    case \"InterfaceTypeAnnotation\":\n    case \"IntersectionTypeAnnotation\":\n    case \"MixedTypeAnnotation\":\n    case \"EmptyTypeAnnotation\":\n    case \"NullableTypeAnnotation\":\n    case \"NumberLiteralTypeAnnotation\":\n    case \"NumberTypeAnnotation\":\n    case \"ObjectTypeAnnotation\":\n    case \"StringLiteralTypeAnnotation\":\n    case \"StringTypeAnnotation\":\n    case \"SymbolTypeAnnotation\":\n    case \"ThisTypeAnnotation\":\n    case \"TupleTypeAnnotation\":\n    case \"TypeofTypeAnnotation\":\n    case \"UnionTypeAnnotation\":\n    case \"VoidTypeAnnotation\":\n    case \"IndexedAccessType\":\n    case \"OptionalIndexedAccessType\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFlowBaseAnnotation(\n  node: t.Node | null | undefined,\n): node is t.FlowBaseAnnotation;\nexport function isFlowBaseAnnotation<\n  Opts extends Options<t.FlowBaseAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FlowBaseAnnotation & Opts;\nexport function isFlowBaseAnnotation<\n  Opts extends Options<t.FlowBaseAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"AnyTypeAnnotation\":\n    case \"BooleanTypeAnnotation\":\n    case \"NullLiteralTypeAnnotation\":\n    case \"MixedTypeAnnotation\":\n    case \"EmptyTypeAnnotation\":\n    case \"NumberTypeAnnotation\":\n    case \"StringTypeAnnotation\":\n    case \"SymbolTypeAnnotation\":\n    case \"ThisTypeAnnotation\":\n    case \"VoidTypeAnnotation\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFlowDeclaration(\n  node: t.Node | null | undefined,\n): node is t.FlowDeclaration;\nexport function isFlowDeclaration<Opts extends Options<t.FlowDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FlowDeclaration & Opts;\nexport function isFlowDeclaration<Opts extends Options<t.FlowDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"InterfaceDeclaration\":\n    case \"OpaqueType\":\n    case \"TypeAlias\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFlowPredicate(\n  node: t.Node | null | undefined,\n): node is t.FlowPredicate;\nexport function isFlowPredicate<Opts extends Options<t.FlowPredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FlowPredicate & Opts;\nexport function isFlowPredicate<Opts extends Options<t.FlowPredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"DeclaredPredicate\":\n    case \"InferredPredicate\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumBody(node: t.Node | null | undefined): node is t.EnumBody;\nexport function isEnumBody<Opts extends Options<t.EnumBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumBody & Opts;\nexport function isEnumBody<Opts extends Options<t.EnumBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"EnumBooleanBody\":\n    case \"EnumNumberBody\":\n    case \"EnumStringBody\":\n    case \"EnumSymbolBody\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumMember(\n  node: t.Node | null | undefined,\n): node is t.EnumMember;\nexport function isEnumMember<Opts extends Options<t.EnumMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumMember & Opts;\nexport function isEnumMember<Opts extends Options<t.EnumMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"EnumBooleanMember\":\n    case \"EnumNumberMember\":\n    case \"EnumStringMember\":\n    case \"EnumDefaultedMember\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSX(node: t.Node | null | undefined): node is t.JSX;\nexport function isJSX<Opts extends Options<t.JSX>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSX & Opts;\nexport function isJSX<Opts extends Options<t.JSX>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"JSXAttribute\":\n    case \"JSXClosingElement\":\n    case \"JSXElement\":\n    case \"JSXEmptyExpression\":\n    case \"JSXExpressionContainer\":\n    case \"JSXSpreadChild\":\n    case \"JSXIdentifier\":\n    case \"JSXMemberExpression\":\n    case \"JSXNamespacedName\":\n    case \"JSXOpeningElement\":\n    case \"JSXSpreadAttribute\":\n    case \"JSXText\":\n    case \"JSXFragment\":\n    case \"JSXOpeningFragment\":\n    case \"JSXClosingFragment\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isMiscellaneous(\n  node: t.Node | null | undefined,\n): node is t.Miscellaneous;\nexport function isMiscellaneous<Opts extends Options<t.Miscellaneous>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Miscellaneous & Opts;\nexport function isMiscellaneous<Opts extends Options<t.Miscellaneous>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"Placeholder\":\n    case \"V8IntrinsicIdentifier\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isAccessor(node: t.Node | null | undefined): node is t.Accessor;\nexport function isAccessor<Opts extends Options<t.Accessor>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Accessor & Opts;\nexport function isAccessor<Opts extends Options<t.Accessor>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ClassAccessorProperty\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeScript(\n  node: t.Node | null | undefined,\n): node is t.TypeScript;\nexport function isTypeScript<Opts extends Options<t.TypeScript>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeScript & Opts;\nexport function isTypeScript<Opts extends Options<t.TypeScript>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"TSParameterProperty\":\n    case \"TSDeclareFunction\":\n    case \"TSDeclareMethod\":\n    case \"TSQualifiedName\":\n    case \"TSCallSignatureDeclaration\":\n    case \"TSConstructSignatureDeclaration\":\n    case \"TSPropertySignature\":\n    case \"TSMethodSignature\":\n    case \"TSIndexSignature\":\n    case \"TSAnyKeyword\":\n    case \"TSBooleanKeyword\":\n    case \"TSBigIntKeyword\":\n    case \"TSIntrinsicKeyword\":\n    case \"TSNeverKeyword\":\n    case \"TSNullKeyword\":\n    case \"TSNumberKeyword\":\n    case \"TSObjectKeyword\":\n    case \"TSStringKeyword\":\n    case \"TSSymbolKeyword\":\n    case \"TSUndefinedKeyword\":\n    case \"TSUnknownKeyword\":\n    case \"TSVoidKeyword\":\n    case \"TSThisType\":\n    case \"TSFunctionType\":\n    case \"TSConstructorType\":\n    case \"TSTypeReference\":\n    case \"TSTypePredicate\":\n    case \"TSTypeQuery\":\n    case \"TSTypeLiteral\":\n    case \"TSArrayType\":\n    case \"TSTupleType\":\n    case \"TSOptionalType\":\n    case \"TSRestType\":\n    case \"TSNamedTupleMember\":\n    case \"TSUnionType\":\n    case \"TSIntersectionType\":\n    case \"TSConditionalType\":\n    case \"TSInferType\":\n    case \"TSParenthesizedType\":\n    case \"TSTypeOperator\":\n    case \"TSIndexedAccessType\":\n    case \"TSMappedType\":\n    case \"TSTemplateLiteralType\":\n    case \"TSLiteralType\":\n    case \"TSClassImplements\":\n    case \"TSInterfaceHeritage\":\n    case \"TSInterfaceDeclaration\":\n    case \"TSInterfaceBody\":\n    case \"TSTypeAliasDeclaration\":\n    case \"TSInstantiationExpression\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSEnumBody\":\n    case \"TSEnumDeclaration\":\n    case \"TSEnumMember\":\n    case \"TSModuleDeclaration\":\n    case \"TSModuleBlock\":\n    case \"TSImportType\":\n    case \"TSImportEqualsDeclaration\":\n    case \"TSExternalModuleReference\":\n    case \"TSNonNullExpression\":\n    case \"TSExportAssignment\":\n    case \"TSNamespaceExportDeclaration\":\n    case \"TSTypeAnnotation\":\n    case \"TSTypeParameterInstantiation\":\n    case \"TSTypeParameterDeclaration\":\n    case \"TSTypeParameter\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeElement(\n  node: t.Node | null | undefined,\n): node is t.TSTypeElement;\nexport function isTSTypeElement<Opts extends Options<t.TSTypeElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeElement & Opts;\nexport function isTSTypeElement<Opts extends Options<t.TSTypeElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"TSCallSignatureDeclaration\":\n    case \"TSConstructSignatureDeclaration\":\n    case \"TSPropertySignature\":\n    case \"TSMethodSignature\":\n    case \"TSIndexSignature\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSType(node: t.Node | null | undefined): node is t.TSType;\nexport function isTSType<Opts extends Options<t.TSType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSType & Opts;\nexport function isTSType<Opts extends Options<t.TSType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"TSAnyKeyword\":\n    case \"TSBooleanKeyword\":\n    case \"TSBigIntKeyword\":\n    case \"TSIntrinsicKeyword\":\n    case \"TSNeverKeyword\":\n    case \"TSNullKeyword\":\n    case \"TSNumberKeyword\":\n    case \"TSObjectKeyword\":\n    case \"TSStringKeyword\":\n    case \"TSSymbolKeyword\":\n    case \"TSUndefinedKeyword\":\n    case \"TSUnknownKeyword\":\n    case \"TSVoidKeyword\":\n    case \"TSThisType\":\n    case \"TSFunctionType\":\n    case \"TSConstructorType\":\n    case \"TSTypeReference\":\n    case \"TSTypePredicate\":\n    case \"TSTypeQuery\":\n    case \"TSTypeLiteral\":\n    case \"TSArrayType\":\n    case \"TSTupleType\":\n    case \"TSOptionalType\":\n    case \"TSRestType\":\n    case \"TSUnionType\":\n    case \"TSIntersectionType\":\n    case \"TSConditionalType\":\n    case \"TSInferType\":\n    case \"TSParenthesizedType\":\n    case \"TSTypeOperator\":\n    case \"TSIndexedAccessType\":\n    case \"TSMappedType\":\n    case \"TSTemplateLiteralType\":\n    case \"TSLiteralType\":\n    case \"TSClassImplements\":\n    case \"TSInterfaceHeritage\":\n    case \"TSImportType\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSBaseType(\n  node: t.Node | null | undefined,\n): node is t.TSBaseType;\nexport function isTSBaseType<Opts extends Options<t.TSBaseType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSBaseType & Opts;\nexport function isTSBaseType<Opts extends Options<t.TSBaseType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"TSAnyKeyword\":\n    case \"TSBooleanKeyword\":\n    case \"TSBigIntKeyword\":\n    case \"TSIntrinsicKeyword\":\n    case \"TSNeverKeyword\":\n    case \"TSNullKeyword\":\n    case \"TSNumberKeyword\":\n    case \"TSObjectKeyword\":\n    case \"TSStringKeyword\":\n    case \"TSSymbolKeyword\":\n    case \"TSUndefinedKeyword\":\n    case \"TSUnknownKeyword\":\n    case \"TSVoidKeyword\":\n    case \"TSThisType\":\n    case \"TSTemplateLiteralType\":\n    case \"TSLiteralType\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\n/**\n * @deprecated Use `isNumericLiteral`\n */\nexport function isNumberLiteral(node: t.Node | null | undefined): boolean;\nexport function isNumberLiteral<Opts extends Options<t.NumberLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean;\nexport function isNumberLiteral<Opts extends Options<t.NumberLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  deprecationWarning(\"isNumberLiteral\", \"isNumericLiteral\");\n  if (!node) return false;\n\n  if (node.type !== \"NumberLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\n/**\n * @deprecated Use `isRegExpLiteral`\n */\nexport function isRegexLiteral(node: t.Node | null | undefined): boolean;\nexport function isRegexLiteral<Opts extends Options<t.RegexLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean;\nexport function isRegexLiteral<Opts extends Options<t.RegexLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  deprecationWarning(\"isRegexLiteral\", \"isRegExpLiteral\");\n  if (!node) return false;\n\n  if (node.type !== \"RegexLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\n/**\n * @deprecated Use `isRestElement`\n */\nexport function isRestProperty(node: t.Node | null | undefined): boolean;\nexport function isRestProperty<Opts extends Options<t.RestProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean;\nexport function isRestProperty<Opts extends Options<t.RestProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  deprecationWarning(\"isRestProperty\", \"isRestElement\");\n  if (!node) return false;\n\n  if (node.type !== \"RestProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\n/**\n * @deprecated Use `isSpreadElement`\n */\nexport function isSpreadProperty(node: t.Node | null | undefined): boolean;\nexport function isSpreadProperty<Opts extends Options<t.SpreadProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean;\nexport function isSpreadProperty<Opts extends Options<t.SpreadProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  deprecationWarning(\"isSpreadProperty\", \"isSpreadElement\");\n  if (!node) return false;\n\n  if (node.type !== \"SpreadProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\n/**\n * @deprecated Use `isImportOrExportDeclaration`\n */\nexport function isModuleDeclaration<Opts extends Options<t.ModuleDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportOrExportDeclaration & Opts {\n  deprecationWarning(\"isModuleDeclaration\", \"isImportOrExportDeclaration\");\n  return isImportOrExportDeclaration(node, opts);\n}\n","import {\n  isIdentifier,\n  isMetaProperty,\n  isMemberExpression,\n  isPrivateName,\n  isStringLiteral,\n  isSuper,\n  isThisExpression,\n} from \"./generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\nfunction isMemberExpressionLike(\n  node: t.Node | undefined | null,\n): node is t.MemberExpression | t.MetaProperty {\n  return isMemberExpression(node) || isMetaProperty(node);\n}\n\n/**\n * Determines whether or not the input node `member` matches the\n * input `match`.\n *\n * For example, given the match `React.createClass` it would match the\n * parsed nodes of `React.createClass` and `React[\"createClass\"]`.\n */\nexport default function matchesPattern(\n  member: t.Node | null | undefined,\n  match: string | string[],\n  allowPartial?: boolean,\n): boolean {\n  // not a member expression\n  if (!isMemberExpressionLike(member)) return false;\n\n  const parts = Array.isArray(match) ? match : match.split(\".\");\n  const nodes = [];\n\n  let node;\n  for (\n    node = member;\n    isMemberExpressionLike(node);\n    node = (node as t.MemberExpression).object ?? (node as t.MetaProperty).meta\n  ) {\n    nodes.push(node.property);\n  }\n  nodes.push(node);\n\n  if (nodes.length < parts.length) return false;\n  if (!allowPartial && nodes.length > parts.length) return false;\n\n  for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {\n    const node = nodes[j];\n    let value;\n    if (isIdentifier(node)) {\n      value = node.name;\n    } else if (isStringLiteral(node)) {\n      value = node.value;\n    } else if (isThisExpression(node)) {\n      value = \"this\";\n    } else if (isSuper(node)) {\n      value = \"super\";\n    } else if (isPrivateName(node)) {\n      value = \"#\" + node.id.name;\n    } else {\n      return false;\n    }\n\n    if (parts[i] !== value) return false;\n  }\n\n  return true;\n}\n","import matchesPattern from \"./matchesPattern.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Build a function that when called will return whether or not the\n * input `node` `MemberExpression` matches the input `match`.\n *\n * For example, given the match `React.createClass` it would match the\n * parsed nodes of `React.createClass` and `React[\"createClass\"]`.\n */\nexport default function buildMatchMemberExpression(\n  match: string,\n  allowPartial?: boolean,\n) {\n  const parts = match.split(\".\");\n\n  return (member: t.Node) => matchesPattern(member, parts, allowPartial);\n}\n","import buildMatchMemberExpression from \"../buildMatchMemberExpression.ts\";\n\nconst isReactComponent = buildMatchMemberExpression(\"React.Component\");\n\nexport default isReactComponent;\n","export default function isCompatTag(tagName?: string): boolean {\n  // Must start with a lowercase ASCII letter\n  return !!tagName && /^[a-z]/.test(tagName);\n}\n","import { FLIPPED_ALIAS_KEYS, ALIAS_KEYS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function isType<T extends t.Node[\"type\"]>(\n  nodeType: string,\n  targetType: T,\n): nodeType is T;\n\nexport default function isType(\n  nodeType: string | null | undefined,\n  targetType: string,\n): boolean;\n\n/**\n * Test if a `nodeType` is a `targetType` or if `targetType` is an alias of `nodeType`.\n */\nexport default function isType(nodeType: string, targetType: string): boolean {\n  if (nodeType === targetType) return true;\n\n  // If nodeType is nullish, it can't be an alias of targetType.\n  if (nodeType == null) return false;\n\n  // This is a fast-path. If the test above failed, but an alias key is found, then the\n  // targetType was a primary node type, so there's no need to check the aliases.\n  // @ts-expect-error targetType may not index ALIAS_KEYS\n  if (ALIAS_KEYS[targetType]) return false;\n\n  const aliases: string[] | undefined = FLIPPED_ALIAS_KEYS[targetType];\n  if (aliases?.includes(nodeType)) return true;\n\n  return false;\n}\n","import { PLACEHOLDERS_ALIAS } from \"../definitions/index.ts\";\n\n/**\n * Test if a `placeholderType` is a `targetType` or if `targetType` is an alias of `placeholderType`.\n */\nexport default function isPlaceholderType(\n  placeholderType: string,\n  targetType: string,\n): boolean {\n  if (placeholderType === targetType) return true;\n\n  const aliases: string[] | undefined = PLACEHOLDERS_ALIAS[placeholderType];\n  if (aliases?.includes(targetType)) return true;\n\n  return false;\n}\n","import shallowEqual from \"../utils/shallowEqual.ts\";\nimport isType from \"./isType.ts\";\nimport isPlaceholderType from \"./isPlaceholderType.ts\";\nimport { FLIPPED_ALIAS_KEYS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function is<T extends t.Node[\"type\"]>(\n  type: T,\n  node: t.Node | null | undefined,\n  opts?: undefined,\n): node is Extract<t.Node, { type: T }>;\n\nexport default function is<\n  T extends t.Node[\"type\"],\n  P extends Extract<t.Node, { type: T }>,\n>(type: T, n: t.Node | null | undefined, required: Partial<P>): n is P;\n\nexport default function is<P extends t.Node>(\n  type: string,\n  node: t.Node | null | undefined,\n  opts: Partial<P>,\n): node is P;\n\nexport default function is(\n  type: string,\n  node: t.Node | null | undefined,\n  opts?: Partial<t.Node>,\n): node is t.Node;\n/**\n * Returns whether `node` is of given `type`.\n *\n * For better performance, use this instead of `is[Type]` when `type` is unknown.\n */\nexport default function is(\n  type: string,\n  node: t.Node | null | undefined,\n  opts?: Partial<t.Node>,\n): node is t.Node {\n  if (!node) return false;\n\n  const matches = isType(node.type, type);\n  if (!matches) {\n    if (!opts && node.type === \"Placeholder\" && type in FLIPPED_ALIAS_KEYS) {\n      // We can only return true if the placeholder doesn't replace a real node,\n      // but it replaces a category of nodes (an alias).\n      //\n      // t.is(\"Identifier\", node) gives some guarantees about node's shape, so we\n      // can't say that Placeholder(expectedNode: \"Identifier\") is an identifier\n      // because it doesn't have the same properties.\n      // On the other hand, t.is(\"Expression\", node) doesn't say anything about\n      // the shape of node because Expression can be many different nodes: we can,\n      // and should, safely report expression placeholders as Expressions.\n      return isPlaceholderType(node.expectedNode, type);\n    }\n    return false;\n  }\n\n  if (opts === undefined) {\n    return true;\n  } else {\n    return shallowEqual(node, opts);\n  }\n}\n","import {\n  isIdentifierName,\n  isStrictReservedWord,\n  isKeyword,\n} from \"@babel/helper-validator-identifier\";\n\n/**\n * Check if the input `name` is a valid identifier name\n * and isn't a reserved word.\n */\nexport default function isValidIdentifier(\n  name: string,\n  reserved: boolean = true,\n): boolean {\n  if (typeof name !== \"string\") return false;\n\n  if (reserved) {\n    // \"await\" is invalid in module, valid in script; better be safe (see #4952)\n    if (isKeyword(name) || isStrictReservedWord(name, true)) {\n      return false;\n    }\n  }\n\n  return isIdentifierName(name);\n}\n","export const STATEMENT_OR_BLOCK_KEYS = [\"consequent\", \"body\", \"alternate\"];\nexport const FLATTENABLE_KEYS = [\"body\", \"expressions\"];\nexport const FOR_INIT_KEYS = [\"left\", \"init\"];\nexport const COMMENT_KEYS = [\n  \"leadingComments\",\n  \"trailingComments\",\n  \"innerComments\",\n] as const;\n\nexport const LOGICAL_OPERATORS = [\"||\", \"&&\", \"??\"];\nexport const UPDATE_OPERATORS = [\"++\", \"--\"];\n\nexport const BOOLEAN_NUMBER_BINARY_OPERATORS = [\">\", \"<\", \">=\", \"<=\"];\nexport const EQUALITY_BINARY_OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\nexport const COMPARISON_BINARY_OPERATORS = [\n  ...EQUALITY_BINARY_OPERATORS,\n  \"in\",\n  \"instanceof\",\n];\nexport const BOOLEAN_BINARY_OPERATORS = [\n  ...COMPARISON_BINARY_OPERATORS,\n  ...BOOLEAN_NUMBER_BINARY_OPERATORS,\n];\nexport const NUMBER_BINARY_OPERATORS = [\n  \"-\",\n  \"/\",\n  \"%\",\n  \"*\",\n  \"**\",\n  \"&\",\n  \"|\",\n  \">>\",\n  \">>>\",\n  \"<<\",\n  \"^\",\n];\nexport const BINARY_OPERATORS = [\n  \"+\",\n  ...NUMBER_BINARY_OPERATORS,\n  ...BOOLEAN_BINARY_OPERATORS,\n  \"|>\",\n];\n\nexport const ASSIGNMENT_OPERATORS = [\n  \"=\",\n  \"+=\",\n  ...NUMBER_BINARY_OPERATORS.map(op => op + \"=\"),\n  ...LOGICAL_OPERATORS.map(op => op + \"=\"),\n];\n\nexport const BOOLEAN_UNARY_OPERATORS = [\"delete\", \"!\"];\nexport const NUMBER_UNARY_OPERATORS = [\"+\", \"-\", \"~\"];\nexport const STRING_UNARY_OPERATORS = [\"typeof\"];\nexport const UNARY_OPERATORS = [\n  \"void\",\n  \"throw\",\n  ...BOOLEAN_UNARY_OPERATORS,\n  ...NUMBER_UNARY_OPERATORS,\n  ...STRING_UNARY_OPERATORS,\n];\n\nexport const INHERIT_KEYS = {\n  optional: [\"typeAnnotation\", \"typeParameters\", \"returnType\"],\n  force: [\"start\", \"loc\", \"end\"],\n} as const;\n","import is from \"../validators/is.ts\";\nimport { validateField, validateChild } from \"../validators/validate.ts\";\nimport type * as t from \"../index.ts\";\n\nexport const VISITOR_KEYS: Record<string, string[]> = {};\nexport const ALIAS_KEYS: Partial<Record<NodeTypesWithoutComment, string[]>> =\n  {};\nexport const FLIPPED_ALIAS_KEYS: Record<string, NodeTypesWithoutComment[]> = {};\nexport const NODE_FIELDS: Record<string, FieldDefinitions> = {};\nexport const BUILDER_KEYS: Record<string, string[]> = {};\nexport const DEPRECATED_KEYS: Record<string, NodeTypesWithoutComment> = {};\nexport const NODE_PARENT_VALIDATIONS: Record<string, Validator> = {};\nexport const NODE_UNION_SHAPES__PRIVATE: Record<string, UnionShape> = {};\n\nfunction getType(val: any) {\n  if (Array.isArray(val)) {\n    return \"array\";\n  } else if (val === null) {\n    return \"null\";\n  } else {\n    return typeof val;\n  }\n}\n\ntype NodeTypesWithoutComment = t.Node[\"type\"] | keyof t.Aliases;\n\ntype NodeTypes = NodeTypesWithoutComment | t.Comment[\"type\"];\n\ntype PrimitiveTypes = ReturnType<typeof getType>;\n\ntype FieldDefinitions = Record<string, FieldOptions>;\n\ntype UnionShape = {\n  discriminator: string;\n  shapes: {\n    name: string;\n    value: any[];\n    properties: Record<string, FieldOptions>;\n  }[];\n};\n\ntype DefineTypeOpts = {\n  fields?: FieldDefinitions;\n  visitor?: string[];\n  aliases?: string[];\n  builder?: string[];\n  inherits?: NodeTypes;\n  deprecatedAlias?: string;\n  validate?: Validator;\n  unionShape?: UnionShape;\n};\n\nexport type ValidatorImpl = (\n  node: t.Node | null | undefined,\n  key: string | { toString(): string },\n  val: any,\n) => void;\n\nexport type ValidatorType = { type: PrimitiveTypes } & ValidatorImpl;\nexport type ValidatorEach = { each: Validator } & ValidatorImpl;\nexport type ValidatorChainOf = {\n  chainOf: readonly Validator[];\n} & ValidatorImpl;\nexport type ValidatorOneOf = { oneOf: readonly any[] } & ValidatorImpl;\nexport type ValidatorOneOfNodeTypes = {\n  oneOfNodeTypes: readonly NodeTypes[];\n} & ValidatorImpl;\nexport type ValidatorOneOfNodeOrValueTypes = {\n  oneOfNodeOrValueTypes: readonly (NodeTypes | PrimitiveTypes)[];\n} & ValidatorImpl;\nexport type ValidatorShapeOf = {\n  shapeOf: Record<string, FieldOptions>;\n} & ValidatorImpl;\n\nexport type Validator =\n  | ValidatorType\n  | ValidatorEach\n  | ValidatorChainOf\n  | ValidatorOneOf\n  | ValidatorOneOfNodeTypes\n  | ValidatorOneOfNodeOrValueTypes\n  | ValidatorShapeOf\n  | ValidatorImpl;\n\nexport type FieldOptions = {\n  default?: string | number | boolean | [] | null;\n  optional?: boolean;\n  deprecated?: boolean;\n  validate?: Validator;\n};\n\nexport function validate(validate: Validator): FieldOptions {\n  return { validate };\n}\n\nexport function validateType(...typeNames: NodeTypes[]) {\n  return validate(assertNodeType(...typeNames));\n}\n\nexport function validateOptional(validate: Validator): FieldOptions {\n  return { validate, optional: true };\n}\n\nexport function validateDefault(\n  validate: Validator,\n  defaultValue: any,\n): FieldOptions {\n  return { validate, default: defaultValue, optional: false };\n}\n\nexport function validateOptionalType(...typeNames: NodeTypes[]): FieldOptions {\n  return { validate: assertNodeType(...typeNames), optional: true };\n}\n\nexport function arrayOf(elementType: Validator): Validator {\n  return chain(assertValueType(\"array\"), assertEach(elementType));\n}\n\nexport function arrayOfType(...typeNames: NodeTypes[]) {\n  return arrayOf(assertNodeType(...typeNames));\n}\n\nexport function validateArrayOfType(...typeNames: NodeTypes[]) {\n  return validate(arrayOfType(...typeNames));\n}\n\nexport function assertEach(callback: Validator): Validator {\n  const childValidator = validateChild;\n  function validator(node: t.Node, key: string, val: any) {\n    if (!Array.isArray(val)) return;\n\n    let i = 0;\n    // We lazily concatenate strings here for performance reasons.\n    // Concatenating the strings is expensive because we are actually concatenating a string and a number,\n    // so V8 cannot just create a \"rope string\" but has to allocate memory for the string resulting from the number\n    // This string is very rarely used, only in error paths, so we can skip the concatenation cost in most cases\n    const subKey = {\n      toString() {\n        return `${key}[${i}]`;\n      },\n    };\n\n    for (; i < val.length; i++) {\n      const v = val[i];\n      callback(node, subKey, v);\n      childValidator(node, subKey, v);\n    }\n  }\n  validator.each = callback;\n  return validator;\n}\n\nexport function assertOneOf(...values: any[]): Validator {\n  function validate(node: any, key: string, val: any) {\n    if (!values.includes(val)) {\n      throw new TypeError(\n        `Property ${key} expected value to be one of ${JSON.stringify(\n          values,\n        )} but got ${JSON.stringify(val)}`,\n      );\n    }\n  }\n\n  validate.oneOf = values;\n\n  return validate;\n}\n\nexport const allExpandedTypes: {\n  types: NodeTypes[];\n  set: Set<string>;\n}[] = [];\n\nexport function assertNodeType(...types: NodeTypes[]): Validator {\n  const expandedTypes = new Set<string>();\n\n  allExpandedTypes.push({ types, set: expandedTypes });\n\n  function validate(node: t.Node, key: string, val: any) {\n    const valType = val?.type;\n    if (valType != null) {\n      if (expandedTypes.has(valType)) {\n        validateChild(node, key, val);\n        return;\n      }\n      if (valType === \"Placeholder\") {\n        for (const type of types) {\n          if (is(type, val)) {\n            validateChild(node, key, val);\n            return;\n          }\n        }\n      }\n    }\n\n    throw new TypeError(\n      `Property ${key} of ${\n        node.type\n      } expected node to be of a type ${JSON.stringify(\n        types,\n      )} but instead got ${JSON.stringify(valType)}`,\n    );\n  }\n\n  validate.oneOfNodeTypes = types;\n\n  return validate;\n}\n\nexport function assertNodeOrValueType(\n  ...types: (NodeTypes | PrimitiveTypes)[]\n): Validator {\n  function validate(node: t.Node, key: string, val: any) {\n    const primitiveType = getType(val);\n    for (const type of types) {\n      if (primitiveType === type || is(type, val)) {\n        validateChild(node, key, val);\n        return;\n      }\n    }\n\n    throw new TypeError(\n      `Property ${key} of ${\n        node.type\n      } expected node to be of a type ${JSON.stringify(\n        types,\n      )} but instead got ${JSON.stringify(val?.type)}`,\n    );\n  }\n\n  validate.oneOfNodeOrValueTypes = types;\n\n  return validate;\n}\n\nexport function assertValueType(type: PrimitiveTypes): Validator {\n  function validate(node: t.Node, key: string, val: any) {\n    if (getType(val) === type) {\n      return;\n    }\n\n    throw new TypeError(\n      `Property ${key} expected type of ${type} but got ${getType(val)}`,\n    );\n  }\n\n  validate.type = type;\n\n  return validate;\n}\n\nexport function assertShape(shape: Record<string, FieldOptions>): Validator {\n  const keys = Object.keys(shape);\n  function validate(node: t.Node, key: string, val: any) {\n    const errors = [];\n    for (const property of keys) {\n      try {\n        validateField(node, property, val[property], shape[property]);\n      } catch (error) {\n        if (error instanceof TypeError) {\n          errors.push(error.message);\n          continue;\n        }\n        throw error;\n      }\n    }\n    if (errors.length) {\n      throw new TypeError(\n        `Property ${key} of ${\n          node.type\n        } expected to have the following:\\n${errors.join(\"\\n\")}`,\n      );\n    }\n  }\n\n  validate.shapeOf = shape;\n\n  return validate;\n}\n\nexport function assertOptionalChainStart(): Validator {\n  function validate(node: t.Node) {\n    let current = node;\n    while (node) {\n      const { type } = current;\n      if (type === \"OptionalCallExpression\") {\n        if (current.optional) return;\n        current = current.callee;\n        continue;\n      }\n\n      if (type === \"OptionalMemberExpression\") {\n        if (current.optional) return;\n        current = current.object;\n        continue;\n      }\n\n      break;\n    }\n\n    throw new TypeError(\n      `Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${current?.type}`,\n    );\n  }\n\n  return validate;\n}\n\nexport function chain(...fns: Validator[]): Validator {\n  function validate(...args: Parameters<Validator>) {\n    for (const fn of fns) {\n      fn(...args);\n    }\n  }\n  validate.chainOf = fns;\n\n  if (\n    fns.length >= 2 &&\n    \"type\" in fns[0] &&\n    fns[0].type === \"array\" &&\n    !(\"each\" in fns[1])\n  ) {\n    throw new Error(\n      `An assertValueType(\"array\") validator can only be followed by an assertEach(...) validator.`,\n    );\n  }\n\n  return validate;\n}\n\nconst validTypeOpts = new Set([\n  \"aliases\",\n  \"builder\",\n  \"deprecatedAlias\",\n  \"fields\",\n  \"inherits\",\n  \"visitor\",\n  \"validate\",\n  \"unionShape\",\n]);\nconst validFieldKeys = new Set([\n  \"default\",\n  \"optional\",\n  \"deprecated\",\n  \"validate\",\n]);\n\nconst store = {} as Record<string, DefineTypeOpts>;\n\n// Wraps defineType to ensure these aliases are included.\nexport function defineAliasedType(...aliases: string[]) {\n  return (type: string, opts: DefineTypeOpts = {}) => {\n    let defined = opts.aliases;\n    if (!defined) {\n      if (opts.inherits) defined = store[opts.inherits].aliases?.slice();\n      defined ??= [];\n      opts.aliases = defined;\n    }\n    const additional = aliases.filter(a => !defined.includes(a));\n    defined.unshift(...additional);\n    defineType(type, opts);\n  };\n}\n\nexport default function defineType(type: string, opts: DefineTypeOpts = {}) {\n  const inherits = (opts.inherits && store[opts.inherits]) || {};\n\n  const visitor: string[] = opts.visitor || inherits.visitor || [];\n  const aliases: string[] = opts.aliases || inherits.aliases || [];\n  const builder: string[] =\n    opts.builder || inherits.builder || opts.visitor || [];\n\n  let fields = opts.fields;\n  if (!fields) {\n    fields = {};\n    if (inherits.fields) {\n      const keys = Object.getOwnPropertyNames(inherits.fields);\n      for (const key of keys) {\n        const field = inherits.fields[key];\n        const def = field.default;\n        if (\n          Array.isArray(def) ? def.length > 0 : def && typeof def === \"object\"\n        ) {\n          throw new Error(\n            \"field defaults can only be primitives or empty arrays currently\",\n          );\n        }\n        fields[key] = {\n          default: Array.isArray(def) ? [] : def,\n          optional: field.optional,\n          deprecated: field.deprecated,\n          validate: field.validate,\n        };\n      }\n    }\n  }\n\n  for (const k of Object.keys(opts)) {\n    if (!validTypeOpts.has(k)) {\n      throw new Error(`Unknown type option \"${k}\" on ${type}`);\n    }\n  }\n\n  if (opts.deprecatedAlias) {\n    DEPRECATED_KEYS[opts.deprecatedAlias] = type as NodeTypesWithoutComment;\n  }\n\n  // ensure all field keys are represented in `fields`\n  for (const key of visitor.concat(builder)) {\n    fields[key] = fields[key] || {};\n  }\n\n  for (const key of Object.keys(fields)) {\n    const field = fields[key];\n\n    if (field.default === null) {\n      field.optional ??= true;\n    }\n    if (field.default === undefined) {\n      field.default = null;\n      field.optional ??= false;\n    } else if (!field.validate && field.default != null) {\n      field.validate = assertValueType(getType(field.default));\n    }\n\n    for (const k of Object.keys(field)) {\n      if (!validFieldKeys.has(k)) {\n        throw new Error(`Unknown field key \"${k}\" on ${type}.${key}`);\n      }\n    }\n  }\n\n  VISITOR_KEYS[type] = opts.visitor = visitor;\n  BUILDER_KEYS[type] = opts.builder = builder;\n  NODE_FIELDS[type] = opts.fields = fields;\n  ALIAS_KEYS[type as NodeTypesWithoutComment] = opts.aliases = aliases;\n  aliases.forEach(alias => {\n    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];\n    FLIPPED_ALIAS_KEYS[alias].push(type as NodeTypesWithoutComment);\n  });\n\n  if (opts.validate) {\n    NODE_PARENT_VALIDATIONS[type] = opts.validate;\n  }\n  if (opts.unionShape) {\n    NODE_UNION_SHAPES__PRIVATE[type] = opts.unionShape;\n  }\n\n  store[type] = opts;\n}\n","import is from \"../validators/is.ts\";\nimport isValidIdentifier from \"../validators/isValidIdentifier.ts\";\nimport { isKeyword, isReservedWord } from \"@babel/helper-validator-identifier\";\nimport type * as t from \"../index.ts\";\nimport { readStringContents } from \"@babel/helper-string-parser\";\n\nimport {\n  BINARY_OPERATORS,\n  LOGICAL_OPERATORS,\n  ASSIGNMENT_OPERATORS,\n  UNARY_OPERATORS,\n  UPDATE_OPERATORS,\n} from \"../constants/index.ts\";\n\nimport {\n  defineAliasedType,\n  assertShape,\n  assertOptionalChainStart,\n  assertValueType,\n  assertNodeType,\n  assertNodeOrValueType,\n  assertEach,\n  chain,\n  assertOneOf,\n  validateOptional,\n  arrayOf,\n  arrayOfType,\n  validateArrayOfType,\n  validateType,\n  type Validator,\n  type ValidatorImpl,\n  type ValidatorOneOfNodeTypes,\n  type ValidatorType,\n} from \"./utils.ts\";\n\nexport const classMethodOrPropertyUnionShapeCommon = (\n  allowPrivateName = false,\n) => ({\n  unionShape: {\n    discriminator: \"computed\",\n    shapes: [\n      {\n        name: \"computed\",\n        value: [true],\n        properties: {\n          key: {\n            validate: assertNodeType(\"Expression\"),\n          },\n        },\n      },\n      {\n        name: \"nonComputed\",\n        value: [false],\n        properties: {\n          key: {\n            validate: allowPrivateName\n              ? assertNodeType(\n                  \"Identifier\",\n                  \"StringLiteral\",\n                  \"NumericLiteral\",\n                  \"BigIntLiteral\",\n                  \"PrivateName\",\n                )\n              : assertNodeType(\n                  \"Identifier\",\n                  \"StringLiteral\",\n                  \"NumericLiteral\",\n                  \"BigIntLiteral\",\n                ),\n          },\n        },\n      },\n    ],\n  },\n});\n\nconst defineType = defineAliasedType(\"Standardized\");\n\ndefineType(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: arrayOf(\n        assertNodeOrValueType(\"null\", \"Expression\", \"SpreadElement\"),\n      ),\n      default: undefined,\n    },\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: Object.assign(\n        (function () {\n          const identifier = assertOneOf(...ASSIGNMENT_OPERATORS);\n          const pattern = assertOneOf(\"=\");\n\n          return function (node: t.AssignmentExpression, key, val) {\n            const validator = is(\"Pattern\", node.left) ? pattern : identifier;\n            validator(node, key, val);\n          } satisfies ValidatorImpl;\n        })(),\n        { oneOf: ASSIGNMENT_OPERATORS },\n      ),\n    },\n    left: {\n      validate: assertNodeType(\n        \"Identifier\",\n        \"MemberExpression\",\n        \"OptionalMemberExpression\",\n        \"ArrayPattern\",\n        \"ObjectPattern\",\n        \"TSAsExpression\",\n        \"TSSatisfiesExpression\",\n        \"TSTypeAssertion\",\n        \"TSNonNullExpression\",\n      ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: assertOneOf(...BINARY_OPERATORS),\n    },\n    left: {\n      validate: (function () {\n        const expression = assertNodeType(\"Expression\");\n        const inOp = assertNodeType(\"Expression\", \"PrivateName\");\n\n        const validator: ValidatorOneOfNodeTypes = Object.assign(\n          function (node: t.BinaryExpression, key, val) {\n            const validator = node.operator === \"in\" ? inOp : expression;\n            validator(node, key, val);\n          } satisfies ValidatorImpl,\n          // todo(ts): can be discriminated union by `operator` property\n          { oneOfNodeTypes: [\"Expression\", \"PrivateName\"] as const },\n        );\n        return validator;\n      })(),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n});\n\ndefineType(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n\ndefineType(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: assertNodeType(\"DirectiveLiteral\"),\n    },\n  },\n});\n\ndefineType(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n\ndefineType(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: arrayOfType(\"Directive\"),\n      default: [],\n    },\n    body: validateArrayOfType(\"Statement\"),\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"],\n});\n\ndefineType(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n});\n\ndefineType(\"CallExpression\", {\n  visitor: [\"callee\", \"typeArguments\", \"arguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: assertNodeType(\"Expression\", \"Super\", \"V8IntrinsicIdentifier\"),\n    },\n    arguments: validateArrayOfType(\n      \"Expression\",\n      \"SpreadElement\",\n      \"ArgumentPlaceholder\",\n    ),\n    typeArguments: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: assertNodeType(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n  aliases: [\"Scopable\", \"BlockParent\"],\n});\n\ndefineType(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    consequent: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    alternate: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  aliases: [\"Expression\", \"Conditional\"],\n});\n\ndefineType(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n});\n\ndefineType(\"DebuggerStatement\", {\n  aliases: [\"Statement\"],\n});\n\ndefineType(\"DoWhileStatement\", {\n  builder: [\"test\", \"body\"],\n  visitor: [\"body\", \"test\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n});\n\ndefineType(\"EmptyStatement\", {\n  aliases: [\"Statement\"],\n});\n\ndefineType(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"],\n});\n\ndefineType(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: assertNodeType(\"Program\"),\n    },\n    comments: {\n      validate: assertEach(assertNodeType(\"CommentBlock\", \"CommentLine\")),\n      optional: true,\n    },\n    tokens: {\n      // todo(ts): add Token type\n      validate: assertEach(Object.assign(() => {}, { type: \"any\" })),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\n    \"Scopable\",\n    \"Statement\",\n    \"For\",\n    \"BlockParent\",\n    \"Loop\",\n    \"ForXStatement\",\n  ],\n  fields: {\n    left: {\n      validate: assertNodeType(\n        \"VariableDeclaration\",\n        \"Identifier\",\n        \"MemberExpression\",\n        \"ArrayPattern\",\n        \"ObjectPattern\",\n        \"TSAsExpression\",\n        \"TSSatisfiesExpression\",\n        \"TSTypeAssertion\",\n        \"TSNonNullExpression\",\n      ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: assertNodeType(\"VariableDeclaration\", \"Expression\"),\n      optional: true,\n    },\n    test: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    update: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\nexport const functionCommon = () => ({\n  params: validateArrayOfType(\"FunctionParameter\"),\n  generator: {\n    default: false,\n  },\n  async: {\n    default: false,\n  },\n});\n\nexport const functionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\"),\n\n    optional: true,\n  },\n  typeParameters: {\n    validate: assertNodeType(\n      \"TypeParameterDeclaration\",\n      \"TSTypeParameterDeclaration\",\n    ),\n\n    optional: true,\n  },\n});\n\nexport const functionDeclarationCommon = () => ({\n  ...functionCommon(),\n  declare: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  id: {\n    validate: assertNodeType(\"Identifier\"),\n    optional: true, // May be null for `export default function`\n  },\n});\n\ndefineType(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\n    \"id\",\n    \"typeParameters\",\n    \"params\",\n    \"predicate\",\n    \"returnType\",\n    \"body\",\n  ],\n  fields: {\n    ...functionDeclarationCommon(),\n    ...functionTypeAnnotationCommon(),\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Statement\",\n    \"Pureish\",\n    \"Declaration\",\n  ],\n  validate: (function () {\n    const identifier = assertNodeType(\"Identifier\");\n\n    return function (parent, key, node) {\n      if (!is(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  })(),\n});\n\ndefineType(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Expression\",\n    \"Pureish\",\n  ],\n  fields: {\n    ...functionCommon(),\n    ...functionTypeAnnotationCommon(),\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n});\n\nexport const patternLikeCommon = () => ({\n  typeAnnotation: {\n    validate: assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\"),\n\n    optional: true,\n  },\n  optional: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  decorators: {\n    validate: arrayOfType(\"Decorator\"),\n    optional: true,\n  },\n});\n\ndefineType(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\" /* for legacy param decorators */],\n  aliases: [\n    \"Expression\",\n    \"FunctionParameter\",\n    \"PatternLike\",\n    \"LVal\",\n    \"TSEntityName\",\n  ],\n  fields: {\n    ...patternLikeCommon(),\n    name: {\n      validate: chain(\n        assertValueType(\"string\"),\n        Object.assign(\n          function (node, key, val) {\n            if (!isValidIdentifier(val, false)) {\n              throw new TypeError(`\"${val}\" is not a valid identifier name`);\n            }\n          } satisfies ValidatorImpl,\n          { type: \"string\" as const },\n        ) satisfies ValidatorType,\n      ),\n    },\n  },\n  validate: function (parent, key, node) {\n    const match = /\\.(\\w+)$/.exec(key.toString());\n    if (!match) return;\n\n    const [, parentKey] = match;\n    const nonComp = { computed: false };\n\n    // We can't check if `parent.property === node`, because nodes are validated\n    // before replacing them in the AST.\n    if (parentKey === \"property\") {\n      if (is(\"MemberExpression\", parent, nonComp)) return;\n      if (is(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if (is(\"Property\", parent, nonComp)) return;\n      if (is(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if (is(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if (is(\"ImportSpecifier\", parent, { imported: node })) return;\n    } else if (parentKey === \"meta\") {\n      if (is(\"MetaProperty\", parent, { meta: node })) return;\n    }\n\n    if (\n      // Ideally we should call isStrictReservedWord if this node is a descendant\n      // of a block in strict mode. Also, we should pass the inModule option so\n      // we can disable \"await\" in module.\n      (isKeyword(node.name) || isReservedWord(node.name, false)) &&\n      // Even if \"this\" is a keyword, we are using the Identifier\n      // node to represent it.\n      node.name !== \"this\"\n    ) {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  },\n});\n\ndefineType(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    consequent: {\n      validate: assertNodeType(\"Statement\"),\n    },\n    alternate: {\n      optional: true,\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: chain(\n        assertValueType(\"number\"),\n        Object.assign(\n          function (node, key, val) {\n            if (1 / val < 0 || !Number.isFinite(val)) {\n              const error = new Error(\n                \"NumericLiterals must be non-negative finite numbers. \" +\n                  `You can use t.valueToNode(${val}) instead.`,\n              );\n\n              // TODO(@nicolo-ribaudo) Fix regenerator to not pass negative\n              // numbers here.\n              if (!IS_STANDALONE) {\n                if (!new Error().stack!.includes(\"regenerator\")) {\n                  throw error;\n                }\n              }\n            }\n          } satisfies ValidatorImpl,\n          { type: \"number\" as const },\n        ) satisfies ValidatorType,\n      ),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"boolean\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: assertValueType(\"string\"),\n    },\n    flags: {\n      validate: chain(\n        assertValueType(\"string\"),\n        Object.assign(\n          function (node, key, val) {\n            const invalid = /[^dgimsuvy]/.exec(val);\n            if (invalid) {\n              throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n            }\n          } satisfies ValidatorImpl,\n          { type: \"string\" as const },\n        ) satisfies ValidatorType,\n      ),\n      default: \"\",\n    },\n  },\n});\n\ndefineType(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: assertOneOf(...LOGICAL_OPERATORS),\n    },\n    left: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", ...[]],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  unionShape: {\n    discriminator: \"computed\",\n    shapes: [\n      {\n        name: \"computed\",\n        value: [true],\n        properties: {\n          property: {\n            validate: assertNodeType(\"Expression\"),\n          },\n        },\n      },\n      {\n        name: \"nonComputed\",\n        value: [false],\n        properties: {\n          property: {\n            validate: assertNodeType(\"Identifier\", \"PrivateName\"),\n          },\n        },\n      },\n    ],\n  },\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\", \"Super\"),\n    },\n    property: {\n      validate: (function () {\n        const normal = assertNodeType(\"Identifier\", \"PrivateName\");\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: ValidatorOneOfNodeTypes = function (\n          node: t.MemberExpression,\n          key,\n          val,\n        ) {\n          const validator: Validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        // todo(ts): can be discriminated union by `computed` property\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      })(),\n    },\n    computed: {\n      default: false,\n    },\n  },\n});\n\ndefineType(\"NewExpression\", { inherits: \"CallExpression\" });\n\ndefineType(\"Program\", {\n  // Note: We explicitly leave 'interpreter' out here because it is\n  // conceptually comment-like, and Babel does not traverse comments either.\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceType: {\n      validate: assertOneOf(\"script\", \"module\"),\n      default: \"script\",\n    },\n    interpreter: {\n      validate: assertNodeType(\"InterpreterDirective\"),\n      default: null,\n      optional: true,\n    },\n    directives: {\n      validate: arrayOfType(\"Directive\"),\n      default: [],\n    },\n    body: validateArrayOfType(\"Statement\"),\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"],\n});\n\ndefineType(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: validateArrayOfType(\n      \"ObjectMethod\",\n      \"ObjectProperty\",\n      \"SpreadElement\",\n    ),\n  },\n});\n\ndefineType(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  visitor: [\n    \"decorators\",\n    \"key\",\n    \"typeParameters\",\n    \"params\",\n    \"returnType\",\n    \"body\",\n  ],\n  ...classMethodOrPropertyUnionShapeCommon(),\n  fields: {\n    ...functionCommon(),\n    ...functionTypeAnnotationCommon(),\n    kind: {\n      validate: assertOneOf(\"method\", \"get\", \"set\"),\n    },\n\n    computed: {\n      default: false,\n    },\n    key: {\n      validate: (function () {\n        const normal = assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        );\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: ValidatorOneOfNodeTypes = function (\n          node: t.ObjectMethod,\n          key,\n          val,\n        ) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        // todo(ts): can be discriminated union by `computed` property\n        validator.oneOfNodeTypes = [\n          \"Expression\",\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        ];\n        return validator;\n      })(),\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n  aliases: [\n    \"UserWhitespacable\",\n    \"Function\",\n    \"Scopable\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Method\",\n    \"ObjectMember\",\n  ],\n});\n\ndefineType(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", ...[]],\n  unionShape: {\n    discriminator: \"computed\",\n    shapes: [\n      {\n        name: \"computed\",\n        value: [true],\n        properties: {\n          key: {\n            validate: assertNodeType(\"Expression\"),\n          },\n        },\n      },\n      {\n        name: \"nonComputed\",\n        value: [false],\n        properties: {\n          key: {\n            validate: assertNodeType(\n              \"Identifier\",\n              \"StringLiteral\",\n              \"NumericLiteral\",\n              \"BigIntLiteral\",\n              \"PrivateName\",\n            ),\n          },\n        },\n      },\n    ],\n  },\n  fields: {\n    computed: {\n      default: false,\n    },\n    key: {\n      validate: (function () {\n        const normal = assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n          \"PrivateName\",\n        );\n\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: ValidatorOneOfNodeTypes = Object.assign(\n          function (node: t.ObjectProperty, key, val) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          } satisfies ValidatorImpl,\n          {\n            // todo(ts): can be discriminated union by `computed` property\n            oneOfNodeTypes: [\n              \"Expression\",\n              \"Identifier\",\n              \"StringLiteral\",\n              \"NumericLiteral\",\n              \"BigIntLiteral\",\n              \"PrivateName\",\n            ] as const,\n          },\n        );\n        return validator;\n      })(),\n    },\n    value: {\n      // Value may be PatternLike if this is an AssignmentProperty\n      // https://github.com/babel/babylon/issues/434\n      validate: assertNodeType(\"Expression\", \"PatternLike\"),\n    },\n    shorthand: {\n      validate: chain(\n        assertValueType(\"boolean\"),\n        Object.assign(\n          function (node: t.ObjectProperty, key, shorthand) {\n            if (!shorthand) return;\n\n            if (node.computed) {\n              throw new TypeError(\n                \"Property shorthand of ObjectProperty cannot be true if computed is true\",\n              );\n            }\n\n            if (!is(\"Identifier\", node.key)) {\n              throw new TypeError(\n                \"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\",\n              );\n            }\n          } satisfies ValidatorImpl,\n          { type: \"boolean\" as const },\n        ) satisfies ValidatorType,\n      ),\n      default: false,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n  },\n  visitor: [\"decorators\", \"key\", \"value\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: (function () {\n    const pattern = assertNodeType(\n      \"Identifier\",\n      \"Pattern\",\n      \"TSAsExpression\",\n      \"TSSatisfiesExpression\",\n      \"TSNonNullExpression\",\n      \"TSTypeAssertion\",\n    );\n    const expression = assertNodeType(\"Expression\");\n\n    return function (parent, key, node) {\n      const validator = is(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  })(),\n});\n\ndefineType(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"FunctionParameter\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: {\n    ...patternLikeCommon(),\n    argument: {\n      validate: assertNodeType(\n        \"Identifier\",\n        \"ArrayPattern\",\n        \"ObjectPattern\",\n        \"MemberExpression\",\n        \"TSAsExpression\",\n        \"TSSatisfiesExpression\",\n        \"TSTypeAssertion\",\n        \"TSNonNullExpression\",\n      ),\n    },\n  },\n  validate: function (parent: t.ArrayPattern | t.ObjectPattern, key) {\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key.toString());\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n\n    const [, listKey, index] = match as unknown as [\n      string,\n      keyof typeof parent,\n      string,\n    ];\n    if ((parent[listKey] as t.Node[]).length > +index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  } satisfies ValidatorImpl,\n});\n\ndefineType(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: validateArrayOfType(\"Expression\"),\n  },\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    consequent: validateArrayOfType(\"Statement\"),\n  },\n});\n\ndefineType(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    cases: validateArrayOfType(\"SwitchCase\"),\n  },\n});\n\ndefineType(\"ThisExpression\", {\n  aliases: [\"Expression\", \"TSEntityName\"],\n});\n\ndefineType(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: chain(\n        assertNodeType(\"BlockStatement\"),\n        Object.assign(\n          function (node: t.TryStatement) {\n            // This validator isn't put at the top level because we can run it\n            // even if this node doesn't have a parent.\n\n            if (!node.handler && !node.finalizer) {\n              throw new TypeError(\n                \"TryStatement expects either a handler or finalizer, or both\",\n              );\n            }\n          } satisfies ValidatorImpl,\n          { oneOfNodeTypes: [\"BlockStatement\"] as const },\n        ) satisfies ValidatorOneOfNodeTypes,\n      ),\n    },\n    handler: {\n      optional: true,\n      validate: assertNodeType(\"CatchClause\"),\n    },\n    finalizer: {\n      optional: true,\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true,\n    },\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    operator: {\n      validate: assertOneOf(...UNARY_OPERATORS),\n    },\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"],\n});\n\ndefineType(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false,\n    },\n    argument: {\n      validate: assertNodeType(\"Identifier\", \"MemberExpression\"),\n    },\n    operator: {\n      validate: assertOneOf(...UPDATE_OPERATORS),\n    },\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    kind: {\n      validate: assertOneOf(\n        \"var\",\n        \"let\",\n        \"const\",\n        // https://github.com/tc39/proposal-explicit-resource-management\n        \"using\",\n        // https://github.com/tc39/proposal-async-explicit-resource-management\n        \"await using\",\n      ),\n    },\n    declarations: validateArrayOfType(\"VariableDeclarator\"),\n  },\n  validate: (() => {\n    const withoutInit = assertNodeType(\"Identifier\", \"Placeholder\");\n    const constOrLetOrVar = assertNodeType(\n      \"Identifier\",\n      \"ArrayPattern\",\n      \"ObjectPattern\",\n      \"Placeholder\",\n    );\n    const usingOrAwaitUsing = assertNodeType(\n      \"Identifier\",\n      \"VoidPattern\",\n      \"Placeholder\",\n    );\n\n    return function (parent, key, node: t.VariableDeclaration) {\n      const { kind, declarations } = node;\n      const parentIsForX = is(\"ForXStatement\", parent, { left: node });\n      if (parentIsForX) {\n        if (declarations.length !== 1) {\n          throw new TypeError(\n            `Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`,\n          );\n        }\n      }\n      for (const decl of declarations) {\n        if (kind === \"const\" || kind === \"let\" || kind === \"var\") {\n          if (!parentIsForX && !decl.init) {\n            withoutInit(decl, \"id\", decl.id);\n          } else {\n            constOrLetOrVar(decl, \"id\", decl.id);\n          }\n        } else {\n          usingOrAwaitUsing(decl, \"id\", decl.id);\n        }\n      }\n    };\n  })(),\n});\n\ndefineType(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\n        \"Identifier\",\n        \"ArrayPattern\",\n        \"ObjectPattern\",\n        \"VoidPattern\",\n      ),\n    },\n    definite: {\n      optional: true,\n      validate: assertValueType(\"boolean\"),\n    },\n    init: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\n// --- ES2015 ---\ndefineType(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\" /* for legacy param decorators */],\n  builder: [\"left\", \"right\"],\n  aliases: [\"FunctionParameter\", \"Pattern\", \"PatternLike\"],\n  fields: {\n    ...patternLikeCommon(),\n    left: {\n      validate: assertNodeType(\n        \"Identifier\",\n        \"ObjectPattern\",\n        \"ArrayPattern\",\n        \"MemberExpression\",\n        \"TSAsExpression\",\n        \"TSSatisfiesExpression\",\n        \"TSTypeAssertion\",\n        \"TSNonNullExpression\",\n      ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    // For TypeScript\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"FunctionParameter\", \"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: {\n    ...patternLikeCommon(),\n    elements: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeOrValueType(\"null\", \"PatternLike\")),\n      ),\n    },\n  },\n});\n\ndefineType(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"typeParameters\", \"params\", \"predicate\", \"returnType\", \"body\"],\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Expression\",\n    \"Pureish\",\n  ],\n  fields: {\n    ...functionCommon(),\n    generator: {\n      // NOTE: This is not actually supoprte by arrow function, but since it\n      // comes from functionCommon() also supporting it as a field here in the\n      // type definitions makes usage of t.Function simpler.\n      // Make it optional at least, defautling to `null`.\n      default: null,\n      optional: true,\n      validate: Object.assign(\n        ((node, key, val) => {\n          if (val) {\n            throw new TypeError(\n              \"ArrowFunctionExpression cannot be a generator\",\n            );\n          }\n        }) satisfies ValidatorImpl,\n        { type: \"boolean\" as const },\n      ),\n    },\n    ...functionTypeAnnotationCommon(),\n    expression: {\n      // https://github.com/babel/babylon/issues/505\n      //\n      // NOTE: In the generated builder we compute the value of this field based\n      // on the body.\n      validate: assertValueType(\"boolean\"),\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\", \"Expression\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\n      \"ClassMethod\",\n      \"ClassPrivateMethod\",\n      \"ClassProperty\",\n      \"ClassPrivateProperty\",\n      \"ClassAccessorProperty\",\n      \"TSDeclareMethod\",\n      \"TSIndexSignature\",\n      \"StaticBlock\",\n    ),\n  },\n});\n\ndefineType(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\n    \"decorators\",\n    \"id\",\n    \"typeParameters\",\n    \"superClass\",\n    \"superTypeArguments\",\n    \"mixins\",\n    \"implements\",\n    \"body\",\n  ],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n    typeParameters: {\n      validate: assertNodeType(\n        \"TypeParameterDeclaration\",\n        \"TSTypeParameterDeclaration\",\n      ),\n\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"ClassBody\"),\n    },\n    superClass: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n    [\"superTypeArguments\"]: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n    implements: {\n      validate: arrayOfType(\"TSClassImplements\", \"ClassImplements\"),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    mixins: {\n      validate: assertNodeType(\"InterfaceExtends\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n      // The id may be omitted if this is the child of an\n      // ExportDefaultDeclaration.\n      optional: true,\n    },\n    typeParameters: {\n      validate: assertNodeType(\n        \"TypeParameterDeclaration\",\n        \"TSTypeParameterDeclaration\",\n      ),\n\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"ClassBody\"),\n    },\n    superClass: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n    [\"superTypeArguments\"]: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n    implements: {\n      validate: arrayOfType(\"TSClassImplements\", \"ClassImplements\"),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    mixins: {\n      validate: assertNodeType(\"InterfaceExtends\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    abstract: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n  },\n  validate: (function () {\n    const identifier = assertNodeType(\"Identifier\");\n    return function (parent, key, node) {\n      if (!is(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  })(),\n});\n\nexport const importAttributes = {\n  attributes: {\n    optional: true,\n    validate: arrayOfType(\"ImportAttribute\"),\n  },\n};\n\ndefineType(\"ExportAllDeclaration\", {\n  visitor: [\"source\", \"attributes\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ImportOrExportDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n    },\n    exportKind: validateOptional(assertOneOf(\"type\", \"value\")),\n    ...importAttributes,\n  },\n});\n\ndefineType(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ImportOrExportDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    declaration: validateType(\n      \"TSDeclareFunction\",\n      \"FunctionDeclaration\",\n      \"ClassDeclaration\",\n      \"Expression\",\n    ),\n    exportKind: validateOptional(assertOneOf(\"value\")),\n  },\n});\n\ndefineType(\"ExportNamedDeclaration\", {\n  builder: [\"declaration\", \"specifiers\", \"source\", \"attributes\"],\n  visitor: [\"declaration\", \"specifiers\", \"source\", \"attributes\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ImportOrExportDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    declaration: {\n      optional: true,\n      validate: chain(\n        assertNodeType(\"Declaration\"),\n        Object.assign(\n          function (node: t.ExportNamedDeclaration, key, val) {\n            // This validator isn't put at the top level because we can run it\n            // even if this node doesn't have a parent.\n\n            if (val && node.specifiers.length) {\n              throw new TypeError(\n                \"Only declaration or specifiers is allowed on ExportNamedDeclaration\",\n              );\n            }\n\n            // This validator isn't put at the top level because we can run it\n            // even if this node doesn't have a parent.\n\n            if (val && node.source) {\n              throw new TypeError(\"Cannot export a declaration from a source\");\n            }\n          } satisfies ValidatorImpl,\n          { oneOfNodeTypes: [\"Declaration\"] as const },\n        ) satisfies ValidatorOneOfNodeTypes,\n      ),\n    },\n    ...importAttributes,\n    specifiers: {\n      default: [],\n      validate: arrayOf(\n        (function () {\n          const sourced = assertNodeType(\n            \"ExportSpecifier\",\n            \"ExportDefaultSpecifier\",\n            \"ExportNamespaceSpecifier\",\n          );\n          const sourceless = assertNodeType(\"ExportSpecifier\");\n\n          return Object.assign(\n            function (node: t.ExportNamedDeclaration, key, val) {\n              const validator = node.source ? sourced : sourceless;\n              validator(node, key, val);\n            } satisfies ValidatorImpl,\n            {\n              oneOfNodeTypes: [\n                \"ExportSpecifier\",\n                \"ExportDefaultSpecifier\",\n                \"ExportNamespaceSpecifier\",\n              ] as const,\n            },\n          ) satisfies ValidatorOneOfNodeTypes;\n        })(),\n      ),\n    },\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n      optional: true,\n    },\n    exportKind: validateOptional(assertOneOf(\"type\", \"value\")),\n  },\n});\n\ndefineType(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    exported: {\n      validate: assertNodeType(\"Identifier\", \"StringLiteral\"),\n    },\n    exportKind: {\n      // And TypeScript's \"export { type foo } from\"\n      validate: assertOneOf(\"type\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\n    \"Scopable\",\n    \"Statement\",\n    \"For\",\n    \"BlockParent\",\n    \"Loop\",\n    \"ForXStatement\",\n  ],\n  fields: {\n    left: {\n      validate: (function () {\n        const declaration = assertNodeType(\"VariableDeclaration\");\n        const lval = assertNodeType(\n          \"Identifier\",\n          \"MemberExpression\",\n          \"ArrayPattern\",\n          \"ObjectPattern\",\n          \"TSAsExpression\",\n          \"TSSatisfiesExpression\",\n          \"TSTypeAssertion\",\n          \"TSNonNullExpression\",\n        );\n\n        return Object.assign(\n          function (node, key, val) {\n            if (is(\"VariableDeclaration\", val)) {\n              declaration(node, key, val);\n            } else {\n              lval(node, key, val);\n            }\n          } satisfies ValidatorImpl,\n          {\n            oneOfNodeTypes: [\n              \"VariableDeclaration\",\n              \"Identifier\",\n              \"MemberExpression\",\n              \"ArrayPattern\",\n              \"ObjectPattern\",\n              \"TSAsExpression\",\n              \"TSSatisfiesExpression\",\n              \"TSTypeAssertion\",\n              \"TSNonNullExpression\",\n            ] as const,\n          },\n        ) satisfies ValidatorOneOfNodeTypes;\n      })(),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n    await: {\n      default: false,\n    },\n  },\n});\n\ndefineType(\"ImportDeclaration\", {\n  builder: [\"specifiers\", \"source\", \"attributes\"],\n  visitor: [\"specifiers\", \"source\", \"attributes\"],\n  aliases: [\"Statement\", \"Declaration\", \"ImportOrExportDeclaration\"],\n  fields: {\n    ...importAttributes,\n    module: {\n      optional: true,\n      validate: assertValueType(\"boolean\"),\n    },\n    phase: {\n      default: null,\n      validate: assertOneOf(\"source\", \"defer\"),\n    },\n    specifiers: validateArrayOfType(\n      \"ImportSpecifier\",\n      \"ImportDefaultSpecifier\",\n      \"ImportNamespaceSpecifier\",\n    ),\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n    },\n    importKind: {\n      // Handle TypeScript/Flowtype's extension \"import type foo from\"\n      // TypeScript doesn't support typeof\n      validate: assertOneOf(\"type\", \"typeof\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"ImportSpecifier\", {\n  visitor: [\"imported\", \"local\"],\n  builder: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    imported: {\n      validate: assertNodeType(\"Identifier\", \"StringLiteral\"),\n    },\n    importKind: {\n      // Handle Flowtype's extension \"import {typeof foo} from\"\n      // And TypeScript's \"import { type foo } from\"\n      validate: assertOneOf(\"type\", \"typeof\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ImportExpression\", {\n  visitor: [\"source\", \"options\"],\n  aliases: [\"Expression\"],\n  fields: {\n    phase: {\n      default: null,\n      validate: assertOneOf(\"source\", \"defer\"),\n    },\n    source: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    options: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: chain(\n        assertNodeType(\"Identifier\"),\n        Object.assign(\n          function (node: t.MetaProperty, key, val) {\n            let property;\n            switch (val.name) {\n              case \"function\":\n                property = \"sent\";\n                break;\n              case \"new\":\n                property = \"target\";\n                break;\n              case \"import\":\n                property = \"meta\";\n                break;\n            }\n            if (!is(\"Identifier\", node.property, { name: property })) {\n              throw new TypeError(\"Unrecognised MetaProperty\");\n            }\n          } satisfies ValidatorImpl,\n          { oneOfNodeTypes: [\"Identifier\"] as const },\n        ) satisfies ValidatorOneOfNodeTypes,\n      ),\n    },\n    property: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\nexport const classMethodOrPropertyCommon = () => ({\n  abstract: {\n    validate: assertValueType(\"boolean\"),\n    default: false,\n    optional: true,\n  },\n  accessibility: {\n    validate: assertOneOf(\"public\", \"private\", \"protected\"),\n    optional: true,\n  },\n  static: {\n    default: false,\n  },\n  override: {\n    optional: true,\n    validate: assertValueType(\"boolean\"),\n    default: false,\n  },\n  computed: {\n    default: false,\n  },\n  optional: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  key: {\n    validate: chain(\n      (function () {\n        const normal = assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        );\n        const computed = assertNodeType(\"Expression\");\n\n        return function (\n          node: Extract<t.Node, { computed: boolean }>,\n          key,\n          val,\n        ) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        } satisfies ValidatorImpl;\n      })(),\n      assertNodeType(\n        \"Identifier\",\n        \"StringLiteral\",\n        \"NumericLiteral\",\n        \"BigIntLiteral\",\n        \"Expression\",\n      ),\n    ),\n  },\n});\n\nexport const classMethodOrDeclareMethodCommon = () => ({\n  ...functionCommon(),\n  ...classMethodOrPropertyCommon(),\n  params: validateArrayOfType(\"FunctionParameter\", \"TSParameterProperty\"),\n  kind: {\n    validate: assertOneOf(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\",\n  },\n  access: {\n    validate: chain(\n      assertValueType(\"string\"),\n      assertOneOf(\"public\", \"private\", \"protected\"),\n    ),\n    optional: true,\n  },\n  decorators: {\n    validate: arrayOfType(\"Decorator\"),\n    optional: true,\n  },\n});\n\ndefineType(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\n    \"kind\",\n    \"key\",\n    \"params\",\n    \"body\",\n    \"computed\",\n    \"static\",\n    \"generator\",\n    \"async\",\n  ],\n  visitor: [\n    \"decorators\",\n    \"key\",\n    \"typeParameters\",\n    \"params\",\n    \"returnType\",\n    \"body\",\n  ],\n  ...classMethodOrPropertyUnionShapeCommon(),\n  fields: {\n    ...classMethodOrDeclareMethodCommon(),\n    ...functionTypeAnnotationCommon(),\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"ObjectPattern\", {\n  visitor: [\n    \"decorators\" /* for legacy param decorators */,\n    \"properties\",\n    \"typeAnnotation\",\n  ],\n  builder: [\"properties\"],\n  aliases: [\"FunctionParameter\", \"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: {\n    ...patternLikeCommon(),\n    properties: validateArrayOfType(\"RestElement\", \"ObjectProperty\"),\n  },\n});\n\ndefineType(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\n  \"Super\",\n\n  undefined,\n);\n\ndefineType(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"typeArguments\", \"quasi\"],\n  builder: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    quasi: {\n      validate: assertNodeType(\"TemplateLiteral\"),\n    },\n    [\"typeArguments\"]: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: chain(\n        assertShape({\n          raw: {\n            validate: assertValueType(\"string\"),\n          },\n          cooked: {\n            validate: assertValueType(\"string\"),\n            optional: true,\n          },\n        }),\n        function templateElementCookedValidator(node: t.TemplateElement) {\n          const raw = node.value.raw;\n\n          let unterminatedCalled = false;\n\n          const error = () => {\n            // unreachable\n            throw new Error(\"Internal @babel/types error.\");\n          };\n          const { str, firstInvalidLoc } = readStringContents(\n            \"template\",\n            raw,\n            0,\n            0,\n            0,\n            {\n              unterminated() {\n                unterminatedCalled = true;\n              },\n              strictNumericEscape: error,\n              invalidEscapeSequence: error,\n              numericSeparatorInEscapeSequence: error,\n              unexpectedNumericSeparator: error,\n              invalidDigit: error,\n              invalidCodePoint: error,\n            },\n          );\n          if (!unterminatedCalled) throw new Error(\"Invalid raw\");\n\n          node.value.cooked = firstInvalidLoc ? null : str;\n        },\n      ),\n    },\n    tail: {\n      default: false,\n    },\n  },\n});\n\ndefineType(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: validateArrayOfType(\"TemplateElement\"),\n    expressions: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\n            \"Expression\",\n            // For TypeScript template literal types\n            \"TSType\",\n          ),\n        ),\n        function (node: t.TemplateLiteral, key, val) {\n          if (node.quasis.length !== val.length + 1) {\n            throw new TypeError(\n              `Number of ${\n                node.type\n              } quasis should be exactly one more than the number of expressions.\\nExpected ${\n                val.length + 1\n              } quasis but got ${node.quasis.length}`,\n            );\n          }\n        } satisfies ValidatorImpl,\n      ),\n    },\n  },\n});\n\ndefineType(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: chain(\n        assertValueType(\"boolean\"),\n        Object.assign(\n          function (node: t.YieldExpression, key, val) {\n            if (val && !node.argument) {\n              throw new TypeError(\n                \"Property delegate of YieldExpression cannot be true if there is no argument\",\n              );\n            }\n          } satisfies ValidatorImpl,\n          { type: \"boolean\" as const },\n        ) satisfies ValidatorType,\n      ),\n      default: false,\n    },\n    argument: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\n// --- ES2017 ---\ndefineType(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\n// --- ES2019 ---\ndefineType(\"Import\", {\n  aliases: [\"Expression\"],\n});\n\n// --- ES2020 ---\ndefineType(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"bigint\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  // todo: Add OptionalMemberExpression to LVal when optional-chaining-assign reaches stage 4\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    property: {\n      validate: (function () {\n        const normal = assertNodeType(\"Identifier\");\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: ValidatorOneOfNodeTypes = Object.assign(\n          function (node: t.OptionalMemberExpression, key, val) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          } satisfies ValidatorImpl,\n          // todo(ts): can be discriminated union by `computed` property\n          { oneOfNodeTypes: [\"Expression\", \"Identifier\"] as const },\n        );\n        return validator;\n      })(),\n    },\n    computed: {\n      default: false,\n    },\n    optional: {\n      validate: chain(assertValueType(\"boolean\"), assertOptionalChainStart()),\n    },\n  },\n});\n\ndefineType(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"typeArguments\", \"arguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    arguments: validateArrayOfType(\n      \"Expression\",\n      \"SpreadElement\",\n      \"ArgumentPlaceholder\",\n    ),\n    optional: {\n      validate: chain(assertValueType(\"boolean\"), assertOptionalChainStart()),\n    },\n    typeArguments: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n  },\n});\n\n// --- ES2022 ---\ndefineType(\"ClassProperty\", {\n  visitor: [\"decorators\", \"variance\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\n    \"key\",\n    \"value\",\n    \"typeAnnotation\",\n    \"decorators\",\n    \"computed\",\n    \"static\",\n  ],\n  aliases: [\"Property\"],\n  ...classMethodOrPropertyUnionShapeCommon(),\n  fields: {\n    ...classMethodOrPropertyCommon(),\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\"),\n\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassPrivateProperty\", {\n  visitor: [\"decorators\", \"variance\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\"key\", \"value\", \"decorators\", \"static\"],\n  aliases: [\"Property\", \"Private\"],\n  fields: {\n    key: {\n      validate: assertNodeType(\"PrivateName\"),\n    },\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\"),\n\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    static: {\n      validate: assertValueType(\"boolean\"),\n      default: false,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    optional: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassPrivateMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"static\"],\n  visitor: [\n    \"decorators\",\n    \"key\",\n    \"typeParameters\",\n    \"params\",\n    \"returnType\",\n    \"body\",\n  ],\n  aliases: [\n    \"Function\",\n    \"Scopable\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Method\",\n    \"Private\",\n  ],\n  // `computed` is not included in the `builder`\n  // ...classMethodOrPropertyUnionShapeCommon(),\n  fields: {\n    ...classMethodOrDeclareMethodCommon(),\n    ...functionTypeAnnotationCommon(),\n    kind: {\n      validate: assertOneOf(\"get\", \"set\", \"method\"),\n      default: \"method\",\n    },\n    key: {\n      validate: assertNodeType(\"PrivateName\"),\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"PrivateName\", {\n  visitor: [\"id\"],\n  aliases: [\"Private\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"StaticBlock\", {\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\"Statement\"),\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"FunctionParent\"],\n});\n\n// --- ES2025 ---\ndefineType(\"ImportAttribute\", {\n  visitor: [\"key\", \"value\"],\n  fields: {\n    key: {\n      validate: assertNodeType(\"Identifier\", \"StringLiteral\"),\n    },\n    value: {\n      validate: assertNodeType(\"StringLiteral\"),\n    },\n  },\n});\n","import { importAttributes } from \"./core.ts\";\nimport {\n  defineAliasedType,\n  arrayOfType,\n  assertOneOf,\n  assertValueType,\n  validate,\n  validateArrayOfType,\n  validateOptional,\n  validateOptionalType,\n  validateType,\n  validateDefault,\n} from \"./utils.ts\";\n\nconst defineType = defineAliasedType(\"Flow\");\n\nconst defineInterfaceishType = (\n  name: \"DeclareClass\" | \"DeclareInterface\" | \"InterfaceDeclaration\",\n) => {\n  const isDeclareClass = name === \"DeclareClass\";\n\n  defineType(name, {\n    builder: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n    visitor: [\n      \"id\",\n      \"typeParameters\",\n      \"extends\",\n      ...(isDeclareClass ? [\"mixins\", \"implements\"] : []),\n      \"body\",\n    ],\n    aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n    fields: {\n      id: validateType(\"Identifier\"),\n      typeParameters: validateOptionalType(\"TypeParameterDeclaration\"),\n      extends: validateOptional(arrayOfType(\"InterfaceExtends\")),\n      ...(isDeclareClass\n        ? {\n            mixins: validateOptional(arrayOfType(\"InterfaceExtends\")),\n            implements: validateOptional(arrayOfType(\"ClassImplements\")),\n          }\n        : {}),\n      body: validateType(\"ObjectTypeAnnotation\"),\n    },\n  });\n};\n\ndefineType(\"AnyTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"ArrayTypeAnnotation\", {\n  visitor: [\"elementType\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    elementType: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"BooleanTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"BooleanLiteralTypeAnnotation\", {\n  builder: [\"value\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    value: validate(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"NullLiteralTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"ClassImplements\", {\n  visitor: [\"id\", \"typeParameters\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterInstantiation\"),\n  },\n});\n\ndefineInterfaceishType(\"DeclareClass\");\n\ndefineType(\"DeclareFunction\", {\n  builder: [\"id\"],\n  visitor: [\"id\", \"predicate\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    predicate: validateOptionalType(\"DeclaredPredicate\"),\n  },\n});\n\ndefineInterfaceishType(\"DeclareInterface\");\n\ndefineType(\"DeclareModule\", {\n  builder: [\"id\", \"body\", \"kind\"],\n  visitor: [\"id\", \"body\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\", \"StringLiteral\"),\n    body: validateType(\"BlockStatement\"),\n    kind: validateOptional(assertOneOf(\"CommonJS\", \"ES\")),\n  },\n});\n\ndefineType(\"DeclareModuleExports\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    typeAnnotation: validateType(\"TypeAnnotation\"),\n  },\n});\n\ndefineType(\"DeclareTypeAlias\", {\n  visitor: [\"id\", \"typeParameters\", \"right\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterDeclaration\"),\n    right: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"DeclareOpaqueType\", {\n  visitor: [\"id\", \"typeParameters\", \"supertype\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterDeclaration\"),\n    supertype: validateOptionalType(\"FlowType\"),\n    impltype: validateOptionalType(\"FlowType\"),\n  },\n});\n\ndefineType(\"DeclareVariable\", {\n  visitor: [\"id\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n  },\n});\n\ndefineType(\"DeclareExportDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\", \"attributes\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    declaration: validateOptionalType(\"Flow\"),\n    specifiers: validateOptional(\n      arrayOfType(\"ExportSpecifier\", \"ExportNamespaceSpecifier\"),\n    ),\n    source: validateOptionalType(\"StringLiteral\"),\n    default: validateOptional(assertValueType(\"boolean\")),\n    ...importAttributes,\n  },\n});\n\ndefineType(\"DeclareExportAllDeclaration\", {\n  visitor: [\"source\", \"attributes\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    source: validateType(\"StringLiteral\"),\n    exportKind: validateOptional(assertOneOf(\"type\", \"value\")),\n    ...importAttributes,\n  },\n});\n\ndefineType(\"DeclaredPredicate\", {\n  visitor: [\"value\"],\n  aliases: [\"FlowPredicate\"],\n  fields: {\n    value: validateType(\"Flow\"),\n  },\n});\n\ndefineType(\"ExistsTypeAnnotation\", {\n  aliases: [\"FlowType\"],\n});\n\ndefineType(\"FunctionTypeAnnotation\", {\n  builder: [\"typeParameters\", \"params\", \"rest\", \"returnType\"],\n  visitor: [\"typeParameters\", \"this\", \"params\", \"rest\", \"returnType\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    typeParameters: validateOptionalType(\"TypeParameterDeclaration\"),\n    params: validateArrayOfType(\"FunctionTypeParam\"),\n    rest: validateOptionalType(\"FunctionTypeParam\"),\n    this: validateOptionalType(\"FunctionTypeParam\"),\n    returnType: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"FunctionTypeParam\", {\n  visitor: [\"name\", \"typeAnnotation\"],\n  fields: {\n    name: validateOptionalType(\"Identifier\"),\n    typeAnnotation: validateType(\"FlowType\"),\n    optional: validateOptional(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"GenericTypeAnnotation\", {\n  visitor: [\"id\", \"typeParameters\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    id: validateType(\"Identifier\", \"QualifiedTypeIdentifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"InferredPredicate\", {\n  aliases: [\"FlowPredicate\"],\n});\n\ndefineType(\"InterfaceExtends\", {\n  visitor: [\"id\", \"typeParameters\"],\n  fields: {\n    id: validateType(\"Identifier\", \"QualifiedTypeIdentifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterInstantiation\"),\n  },\n});\n\ndefineInterfaceishType(\"InterfaceDeclaration\");\n\ndefineType(\"InterfaceTypeAnnotation\", {\n  visitor: [\"extends\", \"body\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    extends: validateOptional(arrayOfType(\"InterfaceExtends\")),\n    body: validateType(\"ObjectTypeAnnotation\"),\n  },\n});\n\ndefineType(\"IntersectionTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    types: validate(arrayOfType(\"FlowType\")),\n  },\n});\n\ndefineType(\"MixedTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"EmptyTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"NullableTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    typeAnnotation: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"NumberLiteralTypeAnnotation\", {\n  builder: [\"value\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    value: validate(assertValueType(\"number\")),\n  },\n});\n\ndefineType(\"NumberTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"ObjectTypeAnnotation\", {\n  visitor: [\"properties\", \"indexers\", \"callProperties\", \"internalSlots\"],\n  aliases: [\"FlowType\"],\n  builder: [\n    \"properties\",\n    \"indexers\",\n    \"callProperties\",\n    \"internalSlots\",\n    \"exact\",\n  ],\n  fields: {\n    properties: validate(\n      arrayOfType(\"ObjectTypeProperty\", \"ObjectTypeSpreadProperty\"),\n    ),\n    indexers: {\n      validate: arrayOfType(\"ObjectTypeIndexer\"),\n      optional: false,\n      default: [],\n    },\n    callProperties: {\n      validate: arrayOfType(\"ObjectTypeCallProperty\"),\n      optional: false,\n      default: [],\n    },\n    internalSlots: {\n      validate: arrayOfType(\"ObjectTypeInternalSlot\"),\n      optional: false,\n      default: [],\n    },\n    exact: {\n      validate: assertValueType(\"boolean\"),\n      default: false,\n    },\n    // If the inexact flag is present then this is an object type, and not a\n    // declare class, declare interface, or interface. If it is true, the\n    // object uses ... to express that it is inexact.\n    inexact: validateOptional(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"ObjectTypeInternalSlot\", {\n  visitor: [\"id\", \"value\"],\n  builder: [\"id\", \"value\", \"optional\", \"static\", \"method\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    value: validateType(\"FlowType\"),\n    optional: validate(assertValueType(\"boolean\")),\n    static: validate(assertValueType(\"boolean\")),\n    method: validate(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"ObjectTypeCallProperty\", {\n  visitor: [\"value\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    value: validateType(\"FlowType\"),\n    static: validateDefault(assertValueType(\"boolean\"), false),\n  },\n});\n\ndefineType(\"ObjectTypeIndexer\", {\n  visitor: [\"variance\", \"id\", \"key\", \"value\"],\n  builder: [\"id\", \"key\", \"value\", \"variance\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    id: validateOptionalType(\"Identifier\"),\n    key: validateType(\"FlowType\"),\n    value: validateType(\"FlowType\"),\n    static: validateDefault(assertValueType(\"boolean\"), false),\n    variance: validateOptionalType(\"Variance\"),\n  },\n});\n\ndefineType(\"ObjectTypeProperty\", {\n  visitor: [\"key\", \"value\", \"variance\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    key: validateType(\"Identifier\", \"StringLiteral\"),\n    value: validateType(\"FlowType\"),\n    kind: {\n      validate: assertOneOf(\"init\", \"get\", \"set\"),\n      default: \"init\",\n      optional: false,\n    },\n    static: validateDefault(assertValueType(\"boolean\"), false),\n    proto: validateDefault(assertValueType(\"boolean\"), false),\n    optional: validateDefault(assertValueType(\"boolean\"), false),\n    variance: validateOptionalType(\"Variance\"),\n    method: validateDefault(assertValueType(\"boolean\"), false),\n  },\n});\n\ndefineType(\"ObjectTypeSpreadProperty\", {\n  visitor: [\"argument\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    argument: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"OpaqueType\", {\n  visitor: [\"id\", \"typeParameters\", \"supertype\", \"impltype\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterDeclaration\"),\n    supertype: validateOptionalType(\"FlowType\"),\n    impltype: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"QualifiedTypeIdentifier\", {\n  visitor: [\"qualification\", \"id\"],\n  builder: [\"id\", \"qualification\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    qualification: validateType(\"Identifier\", \"QualifiedTypeIdentifier\"),\n  },\n});\n\ndefineType(\"StringLiteralTypeAnnotation\", {\n  builder: [\"value\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    value: validate(assertValueType(\"string\")),\n  },\n});\n\ndefineType(\"StringTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"SymbolTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"ThisTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"TupleTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    types: validate(arrayOfType(\"FlowType\")),\n  },\n});\n\ndefineType(\"TypeofTypeAnnotation\", {\n  visitor: [\"argument\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    argument: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"TypeAlias\", {\n  visitor: [\"id\", \"typeParameters\", \"right\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterDeclaration\"),\n    right: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"TypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"TypeCastExpression\", {\n  visitor: [\"expression\", \"typeAnnotation\"],\n  aliases: [\"ExpressionWrapper\", \"Expression\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n    typeAnnotation: validateType(\"TypeAnnotation\"),\n  },\n});\n\ndefineType(\"TypeParameter\", {\n  builder: [\"name\", \"bound\", \"default\", \"variance\"],\n  visitor: [\"bound\", \"default\", \"variance\"],\n  fields: {\n    name: validate(assertValueType(\"string\")),\n    bound: validateOptionalType(\"TypeAnnotation\"),\n    default: validateOptionalType(\"FlowType\"),\n    variance: validateOptionalType(\"Variance\"),\n  },\n});\n\ndefineType(\"TypeParameterDeclaration\", {\n  visitor: [\"params\"],\n  fields: {\n    params: validate(arrayOfType(\"TypeParameter\")),\n  },\n});\n\ndefineType(\"TypeParameterInstantiation\", {\n  visitor: [\"params\"],\n  fields: {\n    params: validate(arrayOfType(\"FlowType\")),\n  },\n});\n\ndefineType(\"UnionTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    types: validate(arrayOfType(\"FlowType\")),\n  },\n});\n\ndefineType(\"Variance\", {\n  builder: [\"kind\"],\n  fields: {\n    kind: validate(assertOneOf(\"minus\", \"plus\")),\n  },\n});\n\ndefineType(\"VoidTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\n// Enums\ndefineType(\"EnumDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"body\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    body: validateType(\n      \"EnumBooleanBody\",\n      \"EnumNumberBody\",\n      \"EnumStringBody\",\n      \"EnumSymbolBody\",\n    ),\n  },\n});\n\nconst enumBodyBase = {\n  explicitType: validateDefault(assertValueType(\"boolean\"), false),\n  hasUnknownMembers: validateDefault(assertValueType(\"boolean\"), false),\n};\n\ndefineType(\"EnumBooleanBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    ...enumBodyBase,\n    members: validateArrayOfType(\"EnumBooleanMember\"),\n  },\n});\n\ndefineType(\"EnumNumberBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    ...enumBodyBase,\n    members: validateArrayOfType(\"EnumNumberMember\"),\n  },\n});\n\ndefineType(\"EnumStringBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    ...enumBodyBase,\n    members: validateArrayOfType(\"EnumStringMember\", \"EnumDefaultedMember\"),\n  },\n});\n\ndefineType(\"EnumSymbolBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    members: validateArrayOfType(\"EnumDefaultedMember\"),\n    hasUnknownMembers: validateDefault(assertValueType(\"boolean\"), false),\n  },\n});\n\ndefineType(\"EnumBooleanMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    init: validateType(\"BooleanLiteral\"),\n  },\n});\n\ndefineType(\"EnumNumberMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    init: validateType(\"NumericLiteral\"),\n  },\n});\n\ndefineType(\"EnumStringMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    init: validateType(\"StringLiteral\"),\n  },\n});\n\ndefineType(\"EnumDefaultedMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n  },\n});\n\ndefineType(\"IndexedAccessType\", {\n  visitor: [\"objectType\", \"indexType\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    objectType: validateType(\"FlowType\"),\n    indexType: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"OptionalIndexedAccessType\", {\n  visitor: [\"objectType\", \"indexType\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    objectType: validateType(\"FlowType\"),\n    indexType: validateType(\"FlowType\"),\n    optional: validateDefault(assertValueType(\"boolean\"), false),\n  },\n});\n","import {\n  defineAliasedType,\n  assertNodeType,\n  assertValueType,\n  validateArrayOfType,\n} from \"./utils.ts\";\n\nconst defineType = defineAliasedType(\"JSX\");\n\ndefineType(\"JSXAttribute\", {\n  visitor: [\"name\", \"value\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    name: {\n      validate: assertNodeType(\"JSXIdentifier\", \"JSXNamespacedName\"),\n    },\n    value: {\n      optional: true,\n      validate: assertNodeType(\n        \"JSXElement\",\n        \"JSXFragment\",\n        \"StringLiteral\",\n        \"JSXExpressionContainer\",\n      ),\n    },\n  },\n});\n\ndefineType(\"JSXClosingElement\", {\n  visitor: [\"name\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    name: {\n      validate: assertNodeType(\n        \"JSXIdentifier\",\n        \"JSXMemberExpression\",\n        \"JSXNamespacedName\",\n      ),\n    },\n  },\n});\n\ndefineType(\"JSXElement\", {\n  builder: [\"openingElement\", \"closingElement\", \"children\"],\n  visitor: [\"openingElement\", \"children\", \"closingElement\"],\n  aliases: [\"Immutable\", \"Expression\"],\n  fields: {\n    openingElement: {\n      validate: assertNodeType(\"JSXOpeningElement\"),\n    },\n    closingElement: {\n      optional: true,\n      validate: assertNodeType(\"JSXClosingElement\"),\n    },\n    children: validateArrayOfType(\n      \"JSXText\",\n      \"JSXExpressionContainer\",\n      \"JSXSpreadChild\",\n      \"JSXElement\",\n      \"JSXFragment\",\n    ),\n  },\n});\n\ndefineType(\"JSXEmptyExpression\", {});\n\ndefineType(\"JSXExpressionContainer\", {\n  visitor: [\"expression\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\", \"JSXEmptyExpression\"),\n    },\n  },\n});\n\ndefineType(\"JSXSpreadChild\", {\n  visitor: [\"expression\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"JSXIdentifier\", {\n  builder: [\"name\"],\n  fields: {\n    name: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n\ndefineType(\"JSXMemberExpression\", {\n  visitor: [\"object\", \"property\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"JSXMemberExpression\", \"JSXIdentifier\"),\n    },\n    property: {\n      validate: assertNodeType(\"JSXIdentifier\"),\n    },\n  },\n});\n\ndefineType(\"JSXNamespacedName\", {\n  visitor: [\"namespace\", \"name\"],\n  fields: {\n    namespace: {\n      validate: assertNodeType(\"JSXIdentifier\"),\n    },\n    name: {\n      validate: assertNodeType(\"JSXIdentifier\"),\n    },\n  },\n});\n\ndefineType(\"JSXOpeningElement\", {\n  builder: [\"name\", \"attributes\", \"selfClosing\"],\n  visitor: [\"name\", \"typeArguments\", \"attributes\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    name: {\n      validate: assertNodeType(\n        \"JSXIdentifier\",\n        \"JSXMemberExpression\",\n        \"JSXNamespacedName\",\n      ),\n    },\n    selfClosing: {\n      default: false,\n    },\n    attributes: validateArrayOfType(\"JSXAttribute\", \"JSXSpreadAttribute\"),\n    typeArguments: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"JSXSpreadAttribute\", {\n  visitor: [\"argument\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"JSXText\", {\n  aliases: [\"Immutable\"],\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n\ndefineType(\"JSXFragment\", {\n  builder: [\"openingFragment\", \"closingFragment\", \"children\"],\n  visitor: [\"openingFragment\", \"children\", \"closingFragment\"],\n  aliases: [\"Immutable\", \"Expression\"],\n  fields: {\n    openingFragment: {\n      validate: assertNodeType(\"JSXOpeningFragment\"),\n    },\n    closingFragment: {\n      validate: assertNodeType(\"JSXClosingFragment\"),\n    },\n    children: validateArrayOfType(\n      \"JSXText\",\n      \"JSXExpressionContainer\",\n      \"JSXSpreadChild\",\n      \"JSXElement\",\n      \"JSXFragment\",\n    ),\n  },\n});\n\ndefineType(\"JSXOpeningFragment\", {\n  aliases: [\"Immutable\"],\n});\n\ndefineType(\"JSXClosingFragment\", {\n  aliases: [\"Immutable\"],\n});\n","import { ALIAS_KEYS } from \"./utils.ts\";\n\nexport const PLACEHOLDERS = [\n  \"Identifier\",\n  \"StringLiteral\",\n  \"Expression\",\n  \"Statement\",\n  \"Declaration\",\n  \"BlockStatement\",\n  \"ClassBody\",\n  \"Pattern\",\n] as const;\n\nexport const PLACEHOLDERS_ALIAS: Record<string, string[]> = {\n  Declaration: [\"Statement\"],\n  Pattern: [\"PatternLike\", \"LVal\"],\n};\n\nfor (const type of PLACEHOLDERS) {\n  const alias = ALIAS_KEYS[type];\n  if (alias?.length) PLACEHOLDERS_ALIAS[type] = alias;\n}\n\nexport const PLACEHOLDERS_FLIPPED_ALIAS: Record<string, string[]> = {};\n\nObject.keys(PLACEHOLDERS_ALIAS).forEach(type => {\n  PLACEHOLDERS_ALIAS[type].forEach(alias => {\n    if (!Object.hasOwn(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {\n      PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];\n    }\n    PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);\n  });\n});\n","import {\n  defineAliasedType,\n  assertNodeType,\n  assertOneOf,\n  assertValueType,\n} from \"./utils.ts\";\nimport { PLACEHOLDERS } from \"./placeholders.ts\";\nimport { patternLikeCommon } from \"./core.ts\";\n\nconst defineType = defineAliasedType(\"Miscellaneous\");\n\ndefineType(\"Placeholder\", {\n  visitor: [],\n  builder: [\"expectedNode\", \"name\"],\n  // aliases: [], defined in placeholders.js\n  fields: {\n    name: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    expectedNode: {\n      validate: assertOneOf(...PLACEHOLDERS),\n    },\n    ...patternLikeCommon(),\n  },\n});\n\ndefineType(\"V8IntrinsicIdentifier\", {\n  builder: [\"name\"],\n  fields: {\n    name: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n","import {\n  classMethodOrPropertyUnionShapeCommon,\n  classMethodOrPropertyCommon,\n} from \"./core.ts\";\nimport type * as t from \"../index.ts\";\nimport defineType, {\n  arrayOfType,\n  assertNodeType,\n  assertValueType,\n  chain,\n  type ValidatorImpl,\n} from \"./utils.ts\";\n\n// https://github.com/tc39/proposal-partial-application\ndefineType(\"ArgumentPlaceholder\", {});\n\n// https://github.com/tc39/proposal-bind-operator\ndefineType(\"BindExpression\", {\n  visitor: [\"object\", \"callee\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    callee: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\n// https://github.com/tc39/proposal-decorators\ndefineType(\"ClassAccessorProperty\", {\n  visitor: [\"decorators\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\n    \"key\",\n    \"value\",\n    \"typeAnnotation\",\n    \"decorators\",\n    \"computed\",\n    \"static\",\n  ],\n  aliases: [\"Property\", \"Accessor\"],\n  ...classMethodOrPropertyUnionShapeCommon(true),\n  fields: {\n    ...classMethodOrPropertyCommon(),\n    key: {\n      validate: chain(\n        (function () {\n          const normal = assertNodeType(\n            \"Identifier\",\n            \"StringLiteral\",\n            \"NumericLiteral\",\n            \"BigIntLiteral\",\n            \"PrivateName\",\n          );\n          const computed = assertNodeType(\"Expression\");\n\n          return function (\n            node: t.ClassAccessorProperty,\n            key: string,\n            val: any,\n          ) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          } satisfies ValidatorImpl;\n        })(),\n        assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n          \"Expression\",\n          \"PrivateName\",\n        ),\n      ),\n    },\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\"),\n\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"Decorator\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\n// https://github.com/tc39/proposal-do-expressions\ndefineType(\"DoExpression\", {\n  visitor: [\"body\"],\n  builder: [\"body\", \"async\"],\n  aliases: [\"Expression\"],\n  fields: {\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n    async: {\n      validate: assertValueType(\"boolean\"),\n      default: false,\n    },\n  },\n});\n\n// https://github.com/tc39/proposal-export-default-from\ndefineType(\"ExportDefaultSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\n// https://github.com/tc39/proposal-js-module-blocks\ndefineType(\"ModuleExpression\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: assertNodeType(\"Program\"),\n    },\n  },\n  aliases: [\"Expression\"],\n});\n\n// https://github.com/tc39/proposal-pipeline-operator\ndefineType(\"TopicReference\", {\n  aliases: [\"Expression\"],\n});\n\n// https://github.com/tc39/proposal-discard-binding\ndefineType(\"VoidPattern\", {\n  aliases: [\"Pattern\", \"PatternLike\", \"FunctionParameter\"],\n});\n","import type * as t from \"../index.ts\";\nimport {\n  defineAliasedType,\n  arrayOfType,\n  assertEach,\n  assertNodeType,\n  assertOneOf,\n  assertValueType,\n  chain,\n  validateArrayOfType,\n  validateOptional,\n  validateOptionalType,\n  validateType,\n  type ValidatorImpl,\n  type ValidatorOneOfNodeTypes,\n} from \"./utils.ts\";\nimport {\n  functionDeclarationCommon,\n  classMethodOrDeclareMethodCommon,\n  classMethodOrPropertyUnionShapeCommon,\n} from \"./core.ts\";\nimport is from \"../validators/is.ts\";\n\nconst defineType = defineAliasedType(\"TypeScript\");\n\nconst bool = assertValueType(\"boolean\");\n\nconst tSFunctionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: assertNodeType(\"TSTypeAnnotation\"),\n\n    optional: true,\n  },\n  typeParameters: {\n    validate: assertNodeType(\"TSTypeParameterDeclaration\"),\n\n    optional: true,\n  },\n});\n\ndefineType(\"TSParameterProperty\", {\n  aliases: [],\n  visitor: [\"parameter\"],\n  fields: {\n    accessibility: {\n      validate: assertOneOf(\"public\", \"private\", \"protected\"),\n      optional: true,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    parameter: {\n      validate: assertNodeType(\"Identifier\", \"AssignmentPattern\"),\n    },\n    override: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TSDeclareFunction\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: {\n    ...functionDeclarationCommon(),\n    ...tSFunctionTypeAnnotationCommon(),\n  },\n});\n\ndefineType(\"TSDeclareMethod\", {\n  visitor: [\"decorators\", \"key\", \"typeParameters\", \"params\", \"returnType\"],\n  ...classMethodOrPropertyUnionShapeCommon(),\n  fields: {\n    ...classMethodOrDeclareMethodCommon(),\n    ...tSFunctionTypeAnnotationCommon(),\n  },\n});\n\ndefineType(\"TSQualifiedName\", {\n  aliases: [\"TSEntityName\"],\n  visitor: [\"left\", \"right\"],\n  fields: {\n    left: validateType(\"TSEntityName\"),\n    right: validateType(\"Identifier\"),\n  },\n});\n\nconst signatureDeclarationCommon = () => ({\n  typeParameters: validateOptionalType(\"TSTypeParameterDeclaration\"),\n  [\"params\"]: validateArrayOfType(\n    \"ArrayPattern\",\n    \"Identifier\",\n    \"ObjectPattern\",\n    \"RestElement\",\n  ),\n  [\"returnType\"]: validateOptionalType(\"TSTypeAnnotation\"),\n});\n\nconst callConstructSignatureDeclaration = {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"typeParameters\", \"params\", \"returnType\"],\n  fields: signatureDeclarationCommon(),\n};\n\ndefineType(\"TSCallSignatureDeclaration\", callConstructSignatureDeclaration);\ndefineType(\n  \"TSConstructSignatureDeclaration\",\n  callConstructSignatureDeclaration,\n);\n\nconst namedTypeElementCommon = () => ({\n  key: validateType(\"Expression\"),\n  computed: { default: false },\n  optional: validateOptional(bool),\n});\n\ndefineType(\"TSPropertySignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"key\", \"typeAnnotation\"],\n  fields: {\n    ...namedTypeElementCommon(),\n    readonly: validateOptional(bool),\n    typeAnnotation: validateOptionalType(\"TSTypeAnnotation\"),\n    kind: {\n      optional: true,\n      validate: assertOneOf(\"get\", \"set\"),\n    },\n  },\n});\n\ndefineType(\"TSMethodSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"key\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: {\n    ...signatureDeclarationCommon(),\n    ...namedTypeElementCommon(),\n    kind: {\n      validate: assertOneOf(\"method\", \"get\", \"set\"),\n      default: \"method\",\n    },\n  },\n});\n\ndefineType(\"TSIndexSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"parameters\", \"typeAnnotation\"],\n  fields: {\n    readonly: validateOptional(bool),\n    static: validateOptional(bool),\n    parameters: validateArrayOfType(\"Identifier\"), // Length must be 1\n    typeAnnotation: validateOptionalType(\"TSTypeAnnotation\"),\n  },\n});\n\nconst tsKeywordTypes = [\n  \"TSAnyKeyword\",\n  \"TSBooleanKeyword\",\n  \"TSBigIntKeyword\",\n  \"TSIntrinsicKeyword\",\n  \"TSNeverKeyword\",\n  \"TSNullKeyword\",\n  \"TSNumberKeyword\",\n  \"TSObjectKeyword\",\n  \"TSStringKeyword\",\n  \"TSSymbolKeyword\",\n  \"TSUndefinedKeyword\",\n  \"TSUnknownKeyword\",\n  \"TSVoidKeyword\",\n] as const;\n\nfor (const type of tsKeywordTypes) {\n  defineType(type, {\n    aliases: [\"TSType\", \"TSBaseType\"],\n    visitor: [],\n    fields: {},\n  });\n}\n\ndefineType(\"TSThisType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [],\n  fields: {},\n});\n\nconst fnOrCtrBase = {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameters\", \"params\", \"returnType\"],\n};\n\ndefineType(\"TSFunctionType\", {\n  ...fnOrCtrBase,\n  fields: signatureDeclarationCommon(),\n});\ndefineType(\"TSConstructorType\", {\n  ...fnOrCtrBase,\n  fields: {\n    ...signatureDeclarationCommon(),\n    abstract: validateOptional(bool),\n  },\n});\n\ndefineType(\"TSTypeReference\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeName\", \"typeArguments\"],\n  fields: {\n    typeName: validateType(\"TSEntityName\"),\n    [\"typeArguments\"]: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"TSTypePredicate\", {\n  aliases: [\"TSType\"],\n  visitor: [\"parameterName\", \"typeAnnotation\"],\n  builder: [\"parameterName\", \"typeAnnotation\", \"asserts\"],\n  fields: {\n    parameterName: validateType(\"Identifier\", \"TSThisType\"),\n    typeAnnotation: validateOptionalType(\"TSTypeAnnotation\"),\n    asserts: validateOptional(bool),\n  },\n});\n\ndefineType(\"TSTypeQuery\", {\n  aliases: [\"TSType\"],\n  visitor: [\"exprName\", \"typeArguments\"],\n  fields: {\n    exprName: validateType(\"TSEntityName\", \"TSImportType\"),\n    [\"typeArguments\"]: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"TSTypeLiteral\", {\n  aliases: [\"TSType\"],\n  visitor: [\"members\"],\n  fields: {\n    members: validateArrayOfType(\"TSTypeElement\"),\n  },\n});\n\ndefineType(\"TSArrayType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementType\"],\n  fields: {\n    elementType: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSTupleType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementTypes\"],\n  fields: {\n    elementTypes: validateArrayOfType(\"TSType\", \"TSNamedTupleMember\"),\n  },\n});\n\ndefineType(\"TSOptionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSRestType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSNamedTupleMember\", {\n  visitor: [\"label\", \"elementType\"],\n  builder: [\"label\", \"elementType\", \"optional\"],\n  fields: {\n    label: validateType(\"Identifier\"),\n    optional: {\n      validate: bool,\n      default: false,\n    },\n    elementType: validateType(\"TSType\"),\n  },\n});\n\nconst unionOrIntersection = {\n  aliases: [\"TSType\"],\n  visitor: [\"types\"],\n  fields: {\n    types: validateArrayOfType(\"TSType\"),\n  },\n};\n\ndefineType(\"TSUnionType\", unionOrIntersection);\ndefineType(\"TSIntersectionType\", unionOrIntersection);\n\ndefineType(\"TSConditionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"checkType\", \"extendsType\", \"trueType\", \"falseType\"],\n  fields: {\n    checkType: validateType(\"TSType\"),\n    extendsType: validateType(\"TSType\"),\n    trueType: validateType(\"TSType\"),\n    falseType: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSInferType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameter\"],\n  fields: {\n    typeParameter: validateType(\"TSTypeParameter\"),\n  },\n});\n\ndefineType(\"TSParenthesizedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSTypeOperator\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  builder: [\"typeAnnotation\", \"operator\"],\n  fields: {\n    operator: {\n      validate: assertOneOf(\"keyof\", \"readonly\", \"unique\"),\n      default: undefined,\n    },\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSIndexedAccessType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"objectType\", \"indexType\"],\n  fields: {\n    objectType: validateType(\"TSType\"),\n    indexType: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSMappedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"key\", \"constraint\", \"nameType\", \"typeAnnotation\"],\n  builder: [\"key\", \"constraint\", \"nameType\", \"typeAnnotation\"],\n  fields: {\n    key: validateType(\"Identifier\"),\n    constraint: validateType(\"TSType\"),\n\n    readonly: validateOptional(assertOneOf(true, false, \"+\", \"-\")),\n    optional: validateOptional(assertOneOf(true, false, \"+\", \"-\")),\n    typeAnnotation: validateOptionalType(\"TSType\"),\n    nameType: validateOptionalType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSTemplateLiteralType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [\"quasis\", \"types\"],\n  fields: {\n    quasis: validateArrayOfType(\"TemplateElement\"),\n    types: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"TSType\")),\n        function (node: t.TSTemplateLiteralType, key, val) {\n          if (node.quasis.length !== val.length + 1) {\n            throw new TypeError(\n              `Number of ${\n                node.type\n              } quasis should be exactly one more than the number of types.\\nExpected ${\n                val.length + 1\n              } quasis but got ${node.quasis.length}`,\n            );\n          }\n        } satisfies ValidatorImpl,\n      ),\n    },\n  },\n});\n\ndefineType(\"TSLiteralType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [\"literal\"],\n  fields: {\n    literal: {\n      validate: (function () {\n        const unaryExpression = assertNodeType(\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        );\n        const unaryOperator = assertOneOf(\"-\");\n\n        const literal = assertNodeType(\n          \"NumericLiteral\",\n          \"StringLiteral\",\n          \"BooleanLiteral\",\n          \"BigIntLiteral\",\n          \"TemplateLiteral\",\n        );\n        const validator: ValidatorOneOfNodeTypes = function validator(\n          parent: t.Node,\n          key: string,\n          node: t.Node,\n        ) {\n          // type A = -1 | 1;\n          if (is(\"UnaryExpression\", node)) {\n            // check operator first\n            unaryOperator(node, \"operator\", node.operator);\n            unaryExpression(node, \"argument\", node.argument);\n          } else {\n            // type A = 'foo' | 'bar' | false | 1;\n            literal(parent, key, node);\n          }\n        };\n\n        validator.oneOfNodeTypes = [\n          \"NumericLiteral\",\n          \"StringLiteral\",\n          \"BooleanLiteral\",\n          \"BigIntLiteral\",\n          \"TemplateLiteral\",\n          \"UnaryExpression\",\n        ];\n\n        return validator;\n      })(),\n    },\n  },\n});\n\ndefineType(\"TSClassImplements\", {\n  aliases: [\"TSType\"],\n  visitor: [\"expression\", \"typeArguments\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n    typeArguments: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\ndefineType(\"TSInterfaceHeritage\", {\n  aliases: [\"TSType\"],\n  visitor: [\"expression\", \"typeArguments\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n    typeArguments: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"TSInterfaceDeclaration\", {\n  // \"Statement\" alias prevents a semicolon from appearing after it in an export declaration.\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  fields: {\n    declare: validateOptional(bool),\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterDeclaration\"),\n    extends: validateOptional(arrayOfType(\"TSClassImplements\")),\n    body: validateType(\"TSInterfaceBody\"),\n  },\n});\n\ndefineType(\"TSInterfaceBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\"TSTypeElement\"),\n  },\n});\n\ndefineType(\"TSTypeAliasDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"typeAnnotation\"],\n  fields: {\n    declare: validateOptional(bool),\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterDeclaration\"),\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSInstantiationExpression\", {\n  aliases: [\"Expression\"],\n  visitor: [\"expression\", \"typeArguments\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n    [\"typeArguments\"]: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\nconst TSTypeExpression = {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"expression\", \"typeAnnotation\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n    typeAnnotation: validateType(\"TSType\"),\n  },\n};\n\ndefineType(\"TSAsExpression\", TSTypeExpression);\ndefineType(\"TSSatisfiesExpression\", TSTypeExpression);\n\ndefineType(\"TSTypeAssertion\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"typeAnnotation\", \"expression\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n    expression: validateType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSEnumBody\", {\n  visitor: [\"members\"],\n  fields: {\n    members: validateArrayOfType(\"TSEnumMember\"),\n  },\n});\n\ndefineType(\"TSEnumDeclaration\", {\n  // \"Statement\" alias prevents a semicolon from appearing after it in an export declaration.\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"body\"],\n  fields: {\n    declare: validateOptional(bool),\n    const: validateOptional(bool),\n    id: validateType(\"Identifier\"),\n\n    body: validateType(\"TSEnumBody\"),\n  },\n});\n\ndefineType(\"TSEnumMember\", {\n  visitor: [\"id\", \"initializer\"],\n  fields: {\n    id: validateType(\"Identifier\", \"StringLiteral\"),\n    initializer: validateOptionalType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSModuleDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"body\"],\n  fields: {\n    kind: {\n      validate: assertOneOf(\"global\", \"namespace\"),\n      default: \"namespace\",\n    },\n    declare: validateOptional(bool),\n    id: {\n      validate: chain(\n        assertNodeType(\"TSEntityName\", \"StringLiteral\"),\n        Object.assign(\n          function (\n            node: t.TSModuleDeclaration,\n            key: string,\n            val: t.TSEntityName | t.StringLiteral,\n          ) {\n            if (node.kind === \"namespace\" && is(\"StringLiteral\", val)) {\n              throw new TypeError(\n                `TSModuleDeclaration of kind 'namespace' cannot have a StringLiteral id.`,\n              );\n            }\n          } satisfies ValidatorImpl,\n          { oneOfNodeTypes: [\"TSEntityName\", \"StringLiteral\"] as const },\n        ) satisfies ValidatorOneOfNodeTypes,\n      ),\n    },\n    body: validateType(\"TSModuleBlock\"),\n  },\n});\n\ndefineType(\"TSModuleBlock\", {\n  aliases: [\"Scopable\", \"Block\", \"BlockParent\", \"FunctionParent\"],\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\"Statement\"),\n  },\n});\n\ndefineType(\"TSImportType\", {\n  aliases: [\"TSType\"],\n  builder: [\"source\", \"qualifier\", \"typeArguments\"],\n  visitor: [\"source\", \"options\", \"qualifier\", \"typeArguments\"],\n  fields: {\n    source: validateType(\"StringLiteral\"),\n    qualifier: validateOptionalType(\"TSEntityName\"),\n\n    typeArguments: validateOptionalType(\"TSTypeParameterInstantiation\"),\n\n    options: {\n      validate: assertNodeType(\"ObjectExpression\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TSImportEqualsDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"moduleReference\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    moduleReference: validateType(\"TSEntityName\", \"TSExternalModuleReference\"),\n    importKind: {\n      validate: assertOneOf(\"type\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TSExternalModuleReference\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: validateType(\"StringLiteral\"),\n  },\n});\n\ndefineType(\"TSNonNullExpression\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSExportAssignment\", {\n  aliases: [\"Statement\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSNamespaceExportDeclaration\", {\n  aliases: [\"Statement\"],\n  visitor: [\"id\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n  },\n});\n\ndefineType(\"TSTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: {\n      validate: assertNodeType(\"TSType\"),\n    },\n  },\n});\n\ndefineType(\"TSTypeParameterInstantiation\", {\n  visitor: [\"params\"],\n  fields: {\n    params: validateArrayOfType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSTypeParameterDeclaration\", {\n  visitor: [\"params\"],\n  fields: {\n    params: validateArrayOfType(\"TSTypeParameter\"),\n  },\n});\n\ndefineType(\"TSTypeParameter\", {\n  builder: [\"constraint\", \"default\", \"name\"],\n  visitor: [\"name\", \"constraint\", \"default\"],\n  fields: {\n    name: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    in: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    out: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    const: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    constraint: {\n      validate: assertNodeType(\"TSType\"),\n      optional: true,\n    },\n    default: {\n      validate: assertNodeType(\"TSType\"),\n      optional: true,\n    },\n  },\n});\n","export const DEPRECATED_ALIASES = {\n  ModuleDeclaration: \"ImportOrExportDeclaration\",\n};\n","import \"./core.ts\";\nimport \"./flow.ts\";\nimport \"./jsx.ts\";\nimport \"./misc.ts\";\nimport \"./experimental.ts\";\nimport \"./typescript.ts\";\nimport {\n  VISITOR_KEYS,\n  ALIAS_KEYS,\n  FLIPPED_ALIAS_KEYS,\n  NODE_FIELDS,\n  BUILDER_KEYS,\n  DEPRECATED_KEYS,\n  NODE_PARENT_VALIDATIONS,\n  NODE_UNION_SHAPES__PRIVATE,\n  allExpandedTypes,\n} from \"./utils.ts\";\nimport {\n  PLACEHOLDERS,\n  PLACEHOLDERS_ALIAS,\n  PLACEHOLDERS_FLIPPED_ALIAS,\n} from \"./placeholders.ts\";\nimport { DEPRECATED_ALIASES } from \"./deprecated-aliases.ts\";\n\n(\n  Object.keys(DEPRECATED_ALIASES) as (keyof typeof DEPRECATED_ALIASES)[]\n).forEach(deprecatedAlias => {\n  FLIPPED_ALIAS_KEYS[deprecatedAlias] =\n    FLIPPED_ALIAS_KEYS[DEPRECATED_ALIASES[deprecatedAlias]];\n});\n\nfor (const { types, set } of allExpandedTypes) {\n  for (const type of types) {\n    const aliases = FLIPPED_ALIAS_KEYS[type];\n    if (aliases) {\n      aliases.forEach(set.add, set);\n    } else {\n      set.add(type);\n    }\n  }\n}\n\nconst TYPES: string[] = ([] as string[]).concat(\n  Object.keys(VISITOR_KEYS),\n  Object.keys(FLIPPED_ALIAS_KEYS),\n  Object.keys(DEPRECATED_KEYS),\n);\n\n/**\n * @internal\n */\nexport { NODE_UNION_SHAPES__PRIVATE };\n\nexport {\n  VISITOR_KEYS,\n  ALIAS_KEYS,\n  FLIPPED_ALIAS_KEYS,\n  NODE_FIELDS,\n  BUILDER_KEYS,\n  DEPRECATED_ALIASES,\n  DEPRECATED_KEYS,\n  NODE_PARENT_VALIDATIONS,\n  PLACEHOLDERS,\n  PLACEHOLDERS_ALIAS,\n  PLACEHOLDERS_FLIPPED_ALIAS,\n  TYPES,\n};\n\nexport type { FieldOptions } from \"./utils.ts\";\n","import {\n  NODE_FIELDS,\n  NODE_PARENT_VALIDATIONS,\n  type FieldOptions,\n} from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function validate(\n  node: t.Node | undefined | null,\n  key: string,\n  val: unknown,\n): void {\n  if (!node) return;\n\n  const fields = NODE_FIELDS[node.type];\n  if (!fields) return;\n\n  const field = fields[key];\n  validateField(node, key, val, field);\n  validateChild(node, key, val);\n}\n\nexport function validateInternal(\n  field: FieldOptions,\n  node: t.Node | undefined | null,\n  key: string,\n  val: unknown,\n  maybeNode?: 1,\n): void {\n  if (!field?.validate) return;\n  if (field.optional && val == null) return;\n\n  field.validate(node, key, val);\n\n  if (maybeNode) {\n    const type = (val as t.Node).type;\n    if (type == null) return;\n    NODE_PARENT_VALIDATIONS[type]?.(node, key, val);\n  }\n}\n\nexport function validateField(\n  node: t.Node | undefined | null,\n  key: string,\n  val: unknown,\n  field: FieldOptions | undefined | null,\n): void {\n  if (!field?.validate) return;\n  if (field.optional && val == null) return;\n\n  field.validate(node, key, val);\n}\n\nexport function validateChild(\n  node: t.Node | undefined | null,\n  key: string | { toString(): string },\n  val?: unknown,\n) {\n  const type = (val as t.Node)?.type;\n  if (type == null) return;\n  NODE_PARENT_VALIDATIONS[type]?.(node, key, val);\n}\n","/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport * as _validate from \"../../validators/validate.ts\";\nimport type * as t from \"../../ast-types/generated/index.ts\";\nimport deprecationWarning from \"../../utils/deprecationWarning.ts\";\nimport * as utils from \"../../definitions/utils.ts\";\n\nconst { validateInternal: validate } = _validate;\nconst { NODE_FIELDS } = utils;\n\nexport function arrayExpression(\n  elements: (null | t.Expression | t.SpreadElement)[],\n): t.ArrayExpression {\n  const node: t.ArrayExpression = {\n    type: \"ArrayExpression\",\n    elements,\n  };\n  const defs = NODE_FIELDS.ArrayExpression;\n  validate(defs.elements, node, \"elements\", elements, 1);\n  return node;\n}\nexport function assignmentExpression(\n  operator:\n    | \"=\"\n    | \"+=\"\n    | \"-=\"\n    | \"/=\"\n    | \"%=\"\n    | \"*=\"\n    | \"**=\"\n    | \"&=\"\n    | \"|=\"\n    | \">>=\"\n    | \">>>=\"\n    | \"<<=\"\n    | \"^=\"\n    | \"||=\"\n    | \"&&=\"\n    | \"??=\",\n  left:\n    | t.Identifier\n    | t.MemberExpression\n    | t.OptionalMemberExpression\n    | t.ArrayPattern\n    | t.ObjectPattern\n    | t.TSAsExpression\n    | t.TSSatisfiesExpression\n    | t.TSTypeAssertion\n    | t.TSNonNullExpression,\n  right: t.Expression,\n): t.AssignmentExpression {\n  const node: t.AssignmentExpression = {\n    type: \"AssignmentExpression\",\n    operator,\n    left,\n    right,\n  };\n  const defs = NODE_FIELDS.AssignmentExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function binaryExpression(\n  operator:\n    | \"+\"\n    | \"-\"\n    | \"/\"\n    | \"%\"\n    | \"*\"\n    | \"**\"\n    | \"&\"\n    | \"|\"\n    | \">>\"\n    | \">>>\"\n    | \"<<\"\n    | \"^\"\n    | \"==\"\n    | \"===\"\n    | \"!=\"\n    | \"!==\"\n    | \"in\"\n    | \"instanceof\"\n    | \">\"\n    | \"<\"\n    | \">=\"\n    | \"<=\"\n    | \"|>\",\n  left: t.Expression | t.PrivateName,\n  right: t.Expression,\n): t.BinaryExpression {\n  const node: t.BinaryExpression = {\n    type: \"BinaryExpression\",\n    operator,\n    left,\n    right,\n  };\n  const defs = NODE_FIELDS.BinaryExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function interpreterDirective(value: string): t.InterpreterDirective {\n  const node: t.InterpreterDirective = {\n    type: \"InterpreterDirective\",\n    value,\n  };\n  const defs = NODE_FIELDS.InterpreterDirective;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function directive(value: t.DirectiveLiteral): t.Directive {\n  const node: t.Directive = {\n    type: \"Directive\",\n    value,\n  };\n  const defs = NODE_FIELDS.Directive;\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nexport function directiveLiteral(value: string): t.DirectiveLiteral {\n  const node: t.DirectiveLiteral = {\n    type: \"DirectiveLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.DirectiveLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function blockStatement(\n  body: t.Statement[],\n  directives: t.Directive[] = [],\n): t.BlockStatement {\n  const node: t.BlockStatement = {\n    type: \"BlockStatement\",\n    body,\n    directives,\n  };\n  const defs = NODE_FIELDS.BlockStatement;\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.directives, node, \"directives\", directives, 1);\n  return node;\n}\nexport function breakStatement(\n  label: t.Identifier | null = null,\n): t.BreakStatement {\n  const node: t.BreakStatement = {\n    type: \"BreakStatement\",\n    label,\n  };\n  const defs = NODE_FIELDS.BreakStatement;\n  validate(defs.label, node, \"label\", label, 1);\n  return node;\n}\nexport function callExpression(\n  callee: t.Expression | t.Super | t.V8IntrinsicIdentifier,\n  _arguments: (t.Expression | t.SpreadElement | t.ArgumentPlaceholder)[],\n): t.CallExpression {\n  const node: t.CallExpression = {\n    type: \"CallExpression\",\n    callee,\n    arguments: _arguments,\n  };\n  const defs = NODE_FIELDS.CallExpression;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  validate(defs.arguments, node, \"arguments\", _arguments, 1);\n  return node;\n}\nexport function catchClause(\n  param:\n    | t.Identifier\n    | t.ArrayPattern\n    | t.ObjectPattern\n    | null\n    | undefined = null,\n  body: t.BlockStatement,\n): t.CatchClause {\n  const node: t.CatchClause = {\n    type: \"CatchClause\",\n    param,\n    body,\n  };\n  const defs = NODE_FIELDS.CatchClause;\n  validate(defs.param, node, \"param\", param, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function conditionalExpression(\n  test: t.Expression,\n  consequent: t.Expression,\n  alternate: t.Expression,\n): t.ConditionalExpression {\n  const node: t.ConditionalExpression = {\n    type: \"ConditionalExpression\",\n    test,\n    consequent,\n    alternate,\n  };\n  const defs = NODE_FIELDS.ConditionalExpression;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.consequent, node, \"consequent\", consequent, 1);\n  validate(defs.alternate, node, \"alternate\", alternate, 1);\n  return node;\n}\nexport function continueStatement(\n  label: t.Identifier | null = null,\n): t.ContinueStatement {\n  const node: t.ContinueStatement = {\n    type: \"ContinueStatement\",\n    label,\n  };\n  const defs = NODE_FIELDS.ContinueStatement;\n  validate(defs.label, node, \"label\", label, 1);\n  return node;\n}\nexport function debuggerStatement(): t.DebuggerStatement {\n  return {\n    type: \"DebuggerStatement\",\n  };\n}\nexport function doWhileStatement(\n  test: t.Expression,\n  body: t.Statement,\n): t.DoWhileStatement {\n  const node: t.DoWhileStatement = {\n    type: \"DoWhileStatement\",\n    test,\n    body,\n  };\n  const defs = NODE_FIELDS.DoWhileStatement;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function emptyStatement(): t.EmptyStatement {\n  return {\n    type: \"EmptyStatement\",\n  };\n}\nexport function expressionStatement(\n  expression: t.Expression,\n): t.ExpressionStatement {\n  const node: t.ExpressionStatement = {\n    type: \"ExpressionStatement\",\n    expression,\n  };\n  const defs = NODE_FIELDS.ExpressionStatement;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function file(\n  program: t.Program,\n  comments: (t.CommentBlock | t.CommentLine)[] | null = null,\n  tokens: any[] | null = null,\n): t.File {\n  const node: t.File = {\n    type: \"File\",\n    program,\n    comments,\n    tokens,\n  };\n  const defs = NODE_FIELDS.File;\n  validate(defs.program, node, \"program\", program, 1);\n  validate(defs.comments, node, \"comments\", comments, 1);\n  validate(defs.tokens, node, \"tokens\", tokens);\n  return node;\n}\nexport function forInStatement(\n  left:\n    | t.VariableDeclaration\n    | t.Identifier\n    | t.MemberExpression\n    | t.ArrayPattern\n    | t.ObjectPattern\n    | t.TSAsExpression\n    | t.TSSatisfiesExpression\n    | t.TSTypeAssertion\n    | t.TSNonNullExpression,\n  right: t.Expression,\n  body: t.Statement,\n): t.ForInStatement {\n  const node: t.ForInStatement = {\n    type: \"ForInStatement\",\n    left,\n    right,\n    body,\n  };\n  const defs = NODE_FIELDS.ForInStatement;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function forStatement(\n  init: t.VariableDeclaration | t.Expression | null | undefined = null,\n  test: t.Expression | null | undefined = null,\n  update: t.Expression | null | undefined = null,\n  body: t.Statement,\n): t.ForStatement {\n  const node: t.ForStatement = {\n    type: \"ForStatement\",\n    init,\n    test,\n    update,\n    body,\n  };\n  const defs = NODE_FIELDS.ForStatement;\n  validate(defs.init, node, \"init\", init, 1);\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.update, node, \"update\", update, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function functionDeclaration(\n  id: t.Identifier | null | undefined = null,\n  params: t.FunctionParameter[],\n  body: t.BlockStatement,\n  generator: boolean = false,\n  async: boolean = false,\n): t.FunctionDeclaration {\n  const node: t.FunctionDeclaration = {\n    type: \"FunctionDeclaration\",\n    id,\n    params,\n    body,\n    generator,\n    async,\n  };\n  const defs = NODE_FIELDS.FunctionDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function functionExpression(\n  id: t.Identifier | null | undefined = null,\n  params: t.FunctionParameter[],\n  body: t.BlockStatement,\n  generator: boolean = false,\n  async: boolean = false,\n): t.FunctionExpression {\n  const node: t.FunctionExpression = {\n    type: \"FunctionExpression\",\n    id,\n    params,\n    body,\n    generator,\n    async,\n  };\n  const defs = NODE_FIELDS.FunctionExpression;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function identifier(name: string): t.Identifier {\n  const node: t.Identifier = {\n    type: \"Identifier\",\n    name,\n  };\n  const defs = NODE_FIELDS.Identifier;\n  validate(defs.name, node, \"name\", name);\n  return node;\n}\nexport function ifStatement(\n  test: t.Expression,\n  consequent: t.Statement,\n  alternate: t.Statement | null = null,\n): t.IfStatement {\n  const node: t.IfStatement = {\n    type: \"IfStatement\",\n    test,\n    consequent,\n    alternate,\n  };\n  const defs = NODE_FIELDS.IfStatement;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.consequent, node, \"consequent\", consequent, 1);\n  validate(defs.alternate, node, \"alternate\", alternate, 1);\n  return node;\n}\nexport function labeledStatement(\n  label: t.Identifier,\n  body: t.Statement,\n): t.LabeledStatement {\n  const node: t.LabeledStatement = {\n    type: \"LabeledStatement\",\n    label,\n    body,\n  };\n  const defs = NODE_FIELDS.LabeledStatement;\n  validate(defs.label, node, \"label\", label, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function stringLiteral(value: string): t.StringLiteral {\n  const node: t.StringLiteral = {\n    type: \"StringLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.StringLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function numericLiteral(value: number): t.NumericLiteral {\n  const node: t.NumericLiteral = {\n    type: \"NumericLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.NumericLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function nullLiteral(): t.NullLiteral {\n  return {\n    type: \"NullLiteral\",\n  };\n}\nexport function booleanLiteral(value: boolean): t.BooleanLiteral {\n  const node: t.BooleanLiteral = {\n    type: \"BooleanLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.BooleanLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function regExpLiteral(\n  pattern: string,\n  flags: string = \"\",\n): t.RegExpLiteral {\n  const node: t.RegExpLiteral = {\n    type: \"RegExpLiteral\",\n    pattern,\n    flags,\n  };\n  const defs = NODE_FIELDS.RegExpLiteral;\n  validate(defs.pattern, node, \"pattern\", pattern);\n  validate(defs.flags, node, \"flags\", flags);\n  return node;\n}\nexport function logicalExpression(\n  operator: \"||\" | \"&&\" | \"??\",\n  left: t.Expression,\n  right: t.Expression,\n): t.LogicalExpression {\n  const node: t.LogicalExpression = {\n    type: \"LogicalExpression\",\n    operator,\n    left,\n    right,\n  };\n  const defs = NODE_FIELDS.LogicalExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function memberExpression(\n  object: t.Expression | t.Super,\n  property: t.Expression,\n  computed?: true,\n): Extract<t.MemberExpression, { computed: true }>;\nexport function memberExpression(\n  object: t.Expression | t.Super,\n  property: t.Identifier | t.PrivateName,\n  computed?: false,\n): Extract<t.MemberExpression, { computed: false }>;\nexport function memberExpression(\n  object: t.Expression | t.Super,\n  property: t.Expression | t.Identifier | t.PrivateName,\n  computed?: boolean,\n): t.MemberExpression;\nexport function memberExpression(\n  object: t.Expression | t.Super,\n  property: t.Expression | t.Identifier | t.PrivateName,\n  computed: boolean = false,\n): t.MemberExpression {\n  const node = {\n    type: \"MemberExpression\",\n    object,\n    property,\n    computed,\n  } as t.MemberExpression;\n  const defs = NODE_FIELDS.MemberExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  return node;\n}\nexport function newExpression(\n  callee: t.Expression | t.Super | t.V8IntrinsicIdentifier,\n  _arguments: (t.Expression | t.SpreadElement | t.ArgumentPlaceholder)[],\n): t.NewExpression {\n  const node: t.NewExpression = {\n    type: \"NewExpression\",\n    callee,\n    arguments: _arguments,\n  };\n  const defs = NODE_FIELDS.NewExpression;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  validate(defs.arguments, node, \"arguments\", _arguments, 1);\n  return node;\n}\nexport function program(\n  body: t.Statement[],\n  directives: t.Directive[] = [],\n  sourceType: \"script\" | \"module\" = \"script\",\n  interpreter: t.InterpreterDirective | null = null,\n): t.Program {\n  const node: t.Program = {\n    type: \"Program\",\n    body,\n    directives,\n    sourceType,\n    interpreter,\n  };\n  const defs = NODE_FIELDS.Program;\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.directives, node, \"directives\", directives, 1);\n  validate(defs.sourceType, node, \"sourceType\", sourceType);\n  validate(defs.interpreter, node, \"interpreter\", interpreter, 1);\n  return node;\n}\nexport function objectExpression(\n  properties: (t.ObjectMethod | t.ObjectProperty | t.SpreadElement)[],\n): t.ObjectExpression {\n  const node: t.ObjectExpression = {\n    type: \"ObjectExpression\",\n    properties,\n  };\n  const defs = NODE_FIELDS.ObjectExpression;\n  validate(defs.properties, node, \"properties\", properties, 1);\n  return node;\n}\nexport function objectMethod(\n  kind: \"method\" | \"get\" | \"set\",\n  key: t.Expression,\n  params: t.FunctionParameter[],\n  body: t.BlockStatement,\n  computed?: true,\n  generator?: boolean,\n  async?: boolean,\n): Extract<t.ObjectMethod, { computed: true }>;\nexport function objectMethod(\n  kind: \"method\" | \"get\" | \"set\",\n  key: t.Identifier | t.StringLiteral | t.NumericLiteral | t.BigIntLiteral,\n  params: t.FunctionParameter[],\n  body: t.BlockStatement,\n  computed?: false,\n  generator?: boolean,\n  async?: boolean,\n): Extract<t.ObjectMethod, { computed: false }>;\nexport function objectMethod(\n  kind: \"method\" | \"get\" | \"set\",\n  key:\n    | t.Expression\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral,\n  params: t.FunctionParameter[],\n  body: t.BlockStatement,\n  computed?: boolean,\n  generator?: boolean,\n  async?: boolean,\n): t.ObjectMethod;\nexport function objectMethod(\n  kind: \"method\" | \"get\" | \"set\",\n  key:\n    | t.Expression\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral,\n  params: t.FunctionParameter[],\n  body: t.BlockStatement,\n  computed: boolean = false,\n  generator: boolean = false,\n  async: boolean = false,\n): t.ObjectMethod {\n  const node = {\n    type: \"ObjectMethod\",\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    generator,\n    async,\n  } as t.ObjectMethod;\n  const defs = NODE_FIELDS.ObjectMethod;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function objectProperty(\n  key: t.Expression,\n  value: t.Expression | t.PatternLike,\n  computed?: true,\n  shorthand?: boolean,\n): Extract<t.ObjectProperty, { computed: true }>;\nexport function objectProperty(\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.PrivateName,\n  value: t.Expression | t.PatternLike,\n  computed?: false,\n  shorthand?: boolean,\n): Extract<t.ObjectProperty, { computed: false }>;\nexport function objectProperty(\n  key:\n    | t.Expression\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.PrivateName,\n  value: t.Expression | t.PatternLike,\n  computed?: boolean,\n  shorthand?: boolean,\n): t.ObjectProperty;\nexport function objectProperty(\n  key:\n    | t.Expression\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.PrivateName,\n  value: t.Expression | t.PatternLike,\n  computed: boolean = false,\n  shorthand: boolean = false,\n): t.ObjectProperty {\n  const node = {\n    type: \"ObjectProperty\",\n    key,\n    value,\n    computed,\n    shorthand,\n  } as t.ObjectProperty;\n  const defs = NODE_FIELDS.ObjectProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.shorthand, node, \"shorthand\", shorthand);\n  return node;\n}\nexport function restElement(\n  argument:\n    | t.Identifier\n    | t.ArrayPattern\n    | t.ObjectPattern\n    | t.MemberExpression\n    | t.TSAsExpression\n    | t.TSSatisfiesExpression\n    | t.TSTypeAssertion\n    | t.TSNonNullExpression,\n): t.RestElement {\n  const node: t.RestElement = {\n    type: \"RestElement\",\n    argument,\n  };\n  const defs = NODE_FIELDS.RestElement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport function returnStatement(\n  argument: t.Expression | null = null,\n): t.ReturnStatement {\n  const node: t.ReturnStatement = {\n    type: \"ReturnStatement\",\n    argument,\n  };\n  const defs = NODE_FIELDS.ReturnStatement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport function sequenceExpression(\n  expressions: t.Expression[],\n): t.SequenceExpression {\n  const node: t.SequenceExpression = {\n    type: \"SequenceExpression\",\n    expressions,\n  };\n  const defs = NODE_FIELDS.SequenceExpression;\n  validate(defs.expressions, node, \"expressions\", expressions, 1);\n  return node;\n}\nexport function parenthesizedExpression(\n  expression: t.Expression,\n): t.ParenthesizedExpression {\n  const node: t.ParenthesizedExpression = {\n    type: \"ParenthesizedExpression\",\n    expression,\n  };\n  const defs = NODE_FIELDS.ParenthesizedExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function switchCase(\n  test: t.Expression | null | undefined = null,\n  consequent: t.Statement[],\n): t.SwitchCase {\n  const node: t.SwitchCase = {\n    type: \"SwitchCase\",\n    test,\n    consequent,\n  };\n  const defs = NODE_FIELDS.SwitchCase;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.consequent, node, \"consequent\", consequent, 1);\n  return node;\n}\nexport function switchStatement(\n  discriminant: t.Expression,\n  cases: t.SwitchCase[],\n): t.SwitchStatement {\n  const node: t.SwitchStatement = {\n    type: \"SwitchStatement\",\n    discriminant,\n    cases,\n  };\n  const defs = NODE_FIELDS.SwitchStatement;\n  validate(defs.discriminant, node, \"discriminant\", discriminant, 1);\n  validate(defs.cases, node, \"cases\", cases, 1);\n  return node;\n}\nexport function thisExpression(): t.ThisExpression {\n  return {\n    type: \"ThisExpression\",\n  };\n}\nexport function throwStatement(argument: t.Expression): t.ThrowStatement {\n  const node: t.ThrowStatement = {\n    type: \"ThrowStatement\",\n    argument,\n  };\n  const defs = NODE_FIELDS.ThrowStatement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport function tryStatement(\n  block: t.BlockStatement,\n  handler: t.CatchClause | null = null,\n  finalizer: t.BlockStatement | null = null,\n): t.TryStatement {\n  const node: t.TryStatement = {\n    type: \"TryStatement\",\n    block,\n    handler,\n    finalizer,\n  };\n  const defs = NODE_FIELDS.TryStatement;\n  validate(defs.block, node, \"block\", block, 1);\n  validate(defs.handler, node, \"handler\", handler, 1);\n  validate(defs.finalizer, node, \"finalizer\", finalizer, 1);\n  return node;\n}\nexport function unaryExpression(\n  operator: \"void\" | \"throw\" | \"delete\" | \"!\" | \"+\" | \"-\" | \"~\" | \"typeof\",\n  argument: t.Expression,\n  prefix: boolean = true,\n): t.UnaryExpression {\n  const node: t.UnaryExpression = {\n    type: \"UnaryExpression\",\n    operator,\n    argument,\n    prefix,\n  };\n  const defs = NODE_FIELDS.UnaryExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.prefix, node, \"prefix\", prefix);\n  return node;\n}\nexport function updateExpression(\n  operator: \"++\" | \"--\",\n  argument: t.Identifier | t.MemberExpression,\n  prefix: boolean = false,\n): t.UpdateExpression {\n  const node: t.UpdateExpression = {\n    type: \"UpdateExpression\",\n    operator,\n    argument,\n    prefix,\n  };\n  const defs = NODE_FIELDS.UpdateExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.prefix, node, \"prefix\", prefix);\n  return node;\n}\nexport function variableDeclaration(\n  kind: \"var\" | \"let\" | \"const\" | \"using\" | \"await using\",\n  declarations: t.VariableDeclarator[],\n): t.VariableDeclaration {\n  const node: t.VariableDeclaration = {\n    type: \"VariableDeclaration\",\n    kind,\n    declarations,\n  };\n  const defs = NODE_FIELDS.VariableDeclaration;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.declarations, node, \"declarations\", declarations, 1);\n  return node;\n}\nexport function variableDeclarator(\n  id: t.Identifier | t.ArrayPattern | t.ObjectPattern | t.VoidPattern,\n  init: t.Expression | null = null,\n): t.VariableDeclarator {\n  const node: t.VariableDeclarator = {\n    type: \"VariableDeclarator\",\n    id,\n    init,\n  };\n  const defs = NODE_FIELDS.VariableDeclarator;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.init, node, \"init\", init, 1);\n  return node;\n}\nexport function whileStatement(\n  test: t.Expression,\n  body: t.Statement,\n): t.WhileStatement {\n  const node: t.WhileStatement = {\n    type: \"WhileStatement\",\n    test,\n    body,\n  };\n  const defs = NODE_FIELDS.WhileStatement;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function withStatement(\n  object: t.Expression,\n  body: t.Statement,\n): t.WithStatement {\n  const node: t.WithStatement = {\n    type: \"WithStatement\",\n    object,\n    body,\n  };\n  const defs = NODE_FIELDS.WithStatement;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function assignmentPattern(\n  left:\n    | t.Identifier\n    | t.ObjectPattern\n    | t.ArrayPattern\n    | t.MemberExpression\n    | t.TSAsExpression\n    | t.TSSatisfiesExpression\n    | t.TSTypeAssertion\n    | t.TSNonNullExpression,\n  right: t.Expression,\n): t.AssignmentPattern {\n  const node: t.AssignmentPattern = {\n    type: \"AssignmentPattern\",\n    left,\n    right,\n  };\n  const defs = NODE_FIELDS.AssignmentPattern;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function arrayPattern(\n  elements: (null | t.PatternLike)[],\n): t.ArrayPattern {\n  const node: t.ArrayPattern = {\n    type: \"ArrayPattern\",\n    elements,\n  };\n  const defs = NODE_FIELDS.ArrayPattern;\n  validate(defs.elements, node, \"elements\", elements, 1);\n  return node;\n}\nexport function arrowFunctionExpression(\n  params: t.FunctionParameter[],\n  body: t.BlockStatement | t.Expression,\n  async: boolean = false,\n): t.ArrowFunctionExpression {\n  const node: t.ArrowFunctionExpression = {\n    type: \"ArrowFunctionExpression\",\n    params,\n    body,\n    async,\n    expression: body.type !== \"BlockStatement\",\n  };\n  const defs = NODE_FIELDS.ArrowFunctionExpression;\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function classBody(\n  body: (\n    | t.ClassMethod\n    | t.ClassPrivateMethod\n    | t.ClassProperty\n    | t.ClassPrivateProperty\n    | t.ClassAccessorProperty\n    | t.TSDeclareMethod\n    | t.TSIndexSignature\n    | t.StaticBlock\n  )[],\n): t.ClassBody {\n  const node: t.ClassBody = {\n    type: \"ClassBody\",\n    body,\n  };\n  const defs = NODE_FIELDS.ClassBody;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function classExpression(\n  id: t.Identifier | null | undefined = null,\n  superClass: t.Expression | null | undefined = null,\n  body: t.ClassBody,\n  decorators: t.Decorator[] | null = null,\n): t.ClassExpression {\n  const node: t.ClassExpression = {\n    type: \"ClassExpression\",\n    id,\n    superClass,\n    body,\n    decorators,\n  };\n  const defs = NODE_FIELDS.ClassExpression;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.superClass, node, \"superClass\", superClass, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  return node;\n}\nexport function classDeclaration(\n  id: t.Identifier | null | undefined = null,\n  superClass: t.Expression | null | undefined = null,\n  body: t.ClassBody,\n  decorators: t.Decorator[] | null = null,\n): t.ClassDeclaration {\n  const node: t.ClassDeclaration = {\n    type: \"ClassDeclaration\",\n    id,\n    superClass,\n    body,\n    decorators,\n  };\n  const defs = NODE_FIELDS.ClassDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.superClass, node, \"superClass\", superClass, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  return node;\n}\nexport function exportAllDeclaration(\n  source: t.StringLiteral,\n  attributes: t.ImportAttribute[] | null = null,\n): t.ExportAllDeclaration {\n  const node: t.ExportAllDeclaration = {\n    type: \"ExportAllDeclaration\",\n    source,\n    attributes,\n  };\n  const defs = NODE_FIELDS.ExportAllDeclaration;\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.attributes, node, \"attributes\", attributes, 1);\n  return node;\n}\nexport function exportDefaultDeclaration(\n  declaration:\n    | t.TSDeclareFunction\n    | t.FunctionDeclaration\n    | t.ClassDeclaration\n    | t.Expression,\n): t.ExportDefaultDeclaration {\n  const node: t.ExportDefaultDeclaration = {\n    type: \"ExportDefaultDeclaration\",\n    declaration,\n  };\n  const defs = NODE_FIELDS.ExportDefaultDeclaration;\n  validate(defs.declaration, node, \"declaration\", declaration, 1);\n  return node;\n}\nexport function exportNamedDeclaration(\n  declaration: t.Declaration | null = null,\n  specifiers: (\n    | t.ExportSpecifier\n    | t.ExportDefaultSpecifier\n    | t.ExportNamespaceSpecifier\n  )[] = [],\n  source: t.StringLiteral | null = null,\n  attributes: t.ImportAttribute[] | null = null,\n): t.ExportNamedDeclaration {\n  const node: t.ExportNamedDeclaration = {\n    type: \"ExportNamedDeclaration\",\n    declaration,\n    specifiers,\n    source,\n    attributes,\n  };\n  const defs = NODE_FIELDS.ExportNamedDeclaration;\n  validate(defs.declaration, node, \"declaration\", declaration, 1);\n  validate(defs.specifiers, node, \"specifiers\", specifiers, 1);\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.attributes, node, \"attributes\", attributes, 1);\n  return node;\n}\nexport function exportSpecifier(\n  local: t.Identifier,\n  exported: t.Identifier | t.StringLiteral,\n): t.ExportSpecifier {\n  const node: t.ExportSpecifier = {\n    type: \"ExportSpecifier\",\n    local,\n    exported,\n  };\n  const defs = NODE_FIELDS.ExportSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  validate(defs.exported, node, \"exported\", exported, 1);\n  return node;\n}\nexport function forOfStatement(\n  left:\n    | t.VariableDeclaration\n    | t.Identifier\n    | t.MemberExpression\n    | t.ArrayPattern\n    | t.ObjectPattern\n    | t.TSAsExpression\n    | t.TSSatisfiesExpression\n    | t.TSTypeAssertion\n    | t.TSNonNullExpression,\n  right: t.Expression,\n  body: t.Statement,\n  _await: boolean = false,\n): t.ForOfStatement {\n  const node: t.ForOfStatement = {\n    type: \"ForOfStatement\",\n    left,\n    right,\n    body,\n    await: _await,\n  };\n  const defs = NODE_FIELDS.ForOfStatement;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.await, node, \"await\", _await);\n  return node;\n}\nexport function importDeclaration(\n  specifiers: (\n    | t.ImportSpecifier\n    | t.ImportDefaultSpecifier\n    | t.ImportNamespaceSpecifier\n  )[],\n  source: t.StringLiteral,\n  attributes: t.ImportAttribute[] | null = null,\n): t.ImportDeclaration {\n  const node: t.ImportDeclaration = {\n    type: \"ImportDeclaration\",\n    specifiers,\n    source,\n    attributes,\n  };\n  const defs = NODE_FIELDS.ImportDeclaration;\n  validate(defs.specifiers, node, \"specifiers\", specifiers, 1);\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.attributes, node, \"attributes\", attributes, 1);\n  return node;\n}\nexport function importDefaultSpecifier(\n  local: t.Identifier,\n): t.ImportDefaultSpecifier {\n  const node: t.ImportDefaultSpecifier = {\n    type: \"ImportDefaultSpecifier\",\n    local,\n  };\n  const defs = NODE_FIELDS.ImportDefaultSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  return node;\n}\nexport function importNamespaceSpecifier(\n  local: t.Identifier,\n): t.ImportNamespaceSpecifier {\n  const node: t.ImportNamespaceSpecifier = {\n    type: \"ImportNamespaceSpecifier\",\n    local,\n  };\n  const defs = NODE_FIELDS.ImportNamespaceSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  return node;\n}\nexport function importSpecifier(\n  local: t.Identifier,\n  imported: t.Identifier | t.StringLiteral,\n): t.ImportSpecifier {\n  const node: t.ImportSpecifier = {\n    type: \"ImportSpecifier\",\n    local,\n    imported,\n  };\n  const defs = NODE_FIELDS.ImportSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  validate(defs.imported, node, \"imported\", imported, 1);\n  return node;\n}\nexport function importExpression(\n  source: t.Expression,\n  options: t.Expression | null = null,\n): t.ImportExpression {\n  const node: t.ImportExpression = {\n    type: \"ImportExpression\",\n    source,\n    options,\n  };\n  const defs = NODE_FIELDS.ImportExpression;\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.options, node, \"options\", options, 1);\n  return node;\n}\nexport function metaProperty(\n  meta: t.Identifier,\n  property: t.Identifier,\n): t.MetaProperty {\n  const node: t.MetaProperty = {\n    type: \"MetaProperty\",\n    meta,\n    property,\n  };\n  const defs = NODE_FIELDS.MetaProperty;\n  validate(defs.meta, node, \"meta\", meta, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  return node;\n}\nexport function classMethod(\n  kind: \"get\" | \"set\" | \"method\" | \"constructor\" | undefined,\n  key: t.Expression,\n  params: (t.FunctionParameter | t.TSParameterProperty)[],\n  body: t.BlockStatement,\n  computed?: true,\n  _static?: boolean,\n  generator?: boolean,\n  async?: boolean,\n): Extract<t.ClassMethod, { computed: true }>;\nexport function classMethod(\n  kind: \"get\" | \"set\" | \"method\" | \"constructor\" | undefined,\n  key: t.Identifier | t.StringLiteral | t.NumericLiteral | t.BigIntLiteral,\n  params: (t.FunctionParameter | t.TSParameterProperty)[],\n  body: t.BlockStatement,\n  computed?: false,\n  _static?: boolean,\n  generator?: boolean,\n  async?: boolean,\n): Extract<t.ClassMethod, { computed: false }>;\nexport function classMethod(\n  kind: \"get\" | \"set\" | \"method\" | \"constructor\" | undefined,\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  params: (t.FunctionParameter | t.TSParameterProperty)[],\n  body: t.BlockStatement,\n  computed?: boolean,\n  _static?: boolean,\n  generator?: boolean,\n  async?: boolean,\n): t.ClassMethod;\nexport function classMethod(\n  kind: \"get\" | \"set\" | \"method\" | \"constructor\" | undefined = \"method\",\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  params: (t.FunctionParameter | t.TSParameterProperty)[],\n  body: t.BlockStatement,\n  computed: boolean = false,\n  _static: boolean = false,\n  generator: boolean = false,\n  async: boolean = false,\n): t.ClassMethod {\n  const node = {\n    type: \"ClassMethod\",\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    static: _static,\n    generator,\n    async,\n  } as t.ClassMethod;\n  const defs = NODE_FIELDS.ClassMethod;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.static, node, \"static\", _static);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function objectPattern(\n  properties: (t.RestElement | t.ObjectProperty)[],\n): t.ObjectPattern {\n  const node: t.ObjectPattern = {\n    type: \"ObjectPattern\",\n    properties,\n  };\n  const defs = NODE_FIELDS.ObjectPattern;\n  validate(defs.properties, node, \"properties\", properties, 1);\n  return node;\n}\nexport function spreadElement(argument: t.Expression): t.SpreadElement {\n  const node: t.SpreadElement = {\n    type: \"SpreadElement\",\n    argument,\n  };\n  const defs = NODE_FIELDS.SpreadElement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction _super(): t.Super {\n  return {\n    type: \"Super\",\n  };\n}\nexport { _super as super };\nexport function taggedTemplateExpression(\n  tag: t.Expression,\n  quasi: t.TemplateLiteral,\n): t.TaggedTemplateExpression {\n  const node: t.TaggedTemplateExpression = {\n    type: \"TaggedTemplateExpression\",\n    tag,\n    quasi,\n  };\n  const defs = NODE_FIELDS.TaggedTemplateExpression;\n  validate(defs.tag, node, \"tag\", tag, 1);\n  validate(defs.quasi, node, \"quasi\", quasi, 1);\n  return node;\n}\nexport function templateElement(\n  value: { raw: string; cooked?: string | null },\n  tail: boolean = false,\n): t.TemplateElement {\n  const node: t.TemplateElement = {\n    type: \"TemplateElement\",\n    value,\n    tail,\n  };\n  const defs = NODE_FIELDS.TemplateElement;\n  validate(defs.value, node, \"value\", value);\n  validate(defs.tail, node, \"tail\", tail);\n  return node;\n}\nexport function templateLiteral(\n  quasis: t.TemplateElement[],\n  expressions: (t.Expression | t.TSType)[],\n): t.TemplateLiteral {\n  const node: t.TemplateLiteral = {\n    type: \"TemplateLiteral\",\n    quasis,\n    expressions,\n  };\n  const defs = NODE_FIELDS.TemplateLiteral;\n  validate(defs.quasis, node, \"quasis\", quasis, 1);\n  validate(defs.expressions, node, \"expressions\", expressions, 1);\n  return node;\n}\nexport function yieldExpression(\n  argument: t.Expression | null = null,\n  delegate: boolean = false,\n): t.YieldExpression {\n  const node: t.YieldExpression = {\n    type: \"YieldExpression\",\n    argument,\n    delegate,\n  };\n  const defs = NODE_FIELDS.YieldExpression;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.delegate, node, \"delegate\", delegate);\n  return node;\n}\nexport function awaitExpression(argument: t.Expression): t.AwaitExpression {\n  const node: t.AwaitExpression = {\n    type: \"AwaitExpression\",\n    argument,\n  };\n  const defs = NODE_FIELDS.AwaitExpression;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction _import(): t.Import {\n  return {\n    type: \"Import\",\n  };\n}\nexport { _import as import };\nexport function bigIntLiteral(value: bigint): t.BigIntLiteral {\n  const node: t.BigIntLiteral = {\n    type: \"BigIntLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.BigIntLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function exportNamespaceSpecifier(\n  exported: t.Identifier,\n): t.ExportNamespaceSpecifier {\n  const node: t.ExportNamespaceSpecifier = {\n    type: \"ExportNamespaceSpecifier\",\n    exported,\n  };\n  const defs = NODE_FIELDS.ExportNamespaceSpecifier;\n  validate(defs.exported, node, \"exported\", exported, 1);\n  return node;\n}\nexport function optionalMemberExpression(\n  object: t.Expression,\n  property: t.Expression | t.Identifier,\n  computed: boolean | undefined = false,\n  optional: boolean,\n): t.OptionalMemberExpression {\n  const node: t.OptionalMemberExpression = {\n    type: \"OptionalMemberExpression\",\n    object,\n    property,\n    computed,\n    optional,\n  };\n  const defs = NODE_FIELDS.OptionalMemberExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nexport function optionalCallExpression(\n  callee: t.Expression,\n  _arguments: (t.Expression | t.SpreadElement | t.ArgumentPlaceholder)[],\n  optional: boolean,\n): t.OptionalCallExpression {\n  const node: t.OptionalCallExpression = {\n    type: \"OptionalCallExpression\",\n    callee,\n    arguments: _arguments,\n    optional,\n  };\n  const defs = NODE_FIELDS.OptionalCallExpression;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  validate(defs.arguments, node, \"arguments\", _arguments, 1);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nexport function classProperty(\n  key: t.Expression,\n  value?: t.Expression | null,\n  typeAnnotation?: t.TypeAnnotation | t.TSTypeAnnotation | null,\n  decorators?: t.Decorator[] | null,\n  computed?: true,\n  _static?: boolean,\n): Extract<t.ClassProperty, { computed: true }>;\nexport function classProperty(\n  key: t.Identifier | t.StringLiteral | t.NumericLiteral | t.BigIntLiteral,\n  value?: t.Expression | null,\n  typeAnnotation?: t.TypeAnnotation | t.TSTypeAnnotation | null,\n  decorators?: t.Decorator[] | null,\n  computed?: false,\n  _static?: boolean,\n): Extract<t.ClassProperty, { computed: false }>;\nexport function classProperty(\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  value?: t.Expression | null,\n  typeAnnotation?: t.TypeAnnotation | t.TSTypeAnnotation | null,\n  decorators?: t.Decorator[] | null,\n  computed?: boolean,\n  _static?: boolean,\n): t.ClassProperty;\nexport function classProperty(\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  value: t.Expression | null = null,\n  typeAnnotation: t.TypeAnnotation | t.TSTypeAnnotation | null = null,\n  decorators: t.Decorator[] | null = null,\n  computed: boolean = false,\n  _static: boolean = false,\n): t.ClassProperty {\n  const node = {\n    type: \"ClassProperty\",\n    key,\n    value,\n    typeAnnotation,\n    decorators,\n    computed,\n    static: _static,\n  } as t.ClassProperty;\n  const defs = NODE_FIELDS.ClassProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nexport function classPrivateProperty(\n  key: t.PrivateName,\n  value: t.Expression | null = null,\n  decorators: t.Decorator[] | null = null,\n  _static: boolean = false,\n): t.ClassPrivateProperty {\n  const node: t.ClassPrivateProperty = {\n    type: \"ClassPrivateProperty\",\n    key,\n    value,\n    decorators,\n    static: _static,\n  };\n  const defs = NODE_FIELDS.ClassPrivateProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nexport function classPrivateMethod(\n  kind: \"get\" | \"set\" | \"method\" | undefined = \"method\",\n  key: t.PrivateName,\n  params: (t.FunctionParameter | t.TSParameterProperty)[],\n  body: t.BlockStatement,\n  _static: boolean = false,\n): t.ClassPrivateMethod {\n  const node: t.ClassPrivateMethod = {\n    type: \"ClassPrivateMethod\",\n    kind,\n    key,\n    params,\n    body,\n    static: _static,\n    async: false,\n    computed: false,\n    generator: false,\n  };\n  const defs = NODE_FIELDS.ClassPrivateMethod;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nexport function privateName(id: t.Identifier): t.PrivateName {\n  const node: t.PrivateName = {\n    type: \"PrivateName\",\n    id,\n  };\n  const defs = NODE_FIELDS.PrivateName;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nexport function staticBlock(body: t.Statement[]): t.StaticBlock {\n  const node: t.StaticBlock = {\n    type: \"StaticBlock\",\n    body,\n  };\n  const defs = NODE_FIELDS.StaticBlock;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function importAttribute(\n  key: t.Identifier | t.StringLiteral,\n  value: t.StringLiteral,\n): t.ImportAttribute {\n  const node: t.ImportAttribute = {\n    type: \"ImportAttribute\",\n    key,\n    value,\n  };\n  const defs = NODE_FIELDS.ImportAttribute;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nexport function anyTypeAnnotation(): t.AnyTypeAnnotation {\n  return {\n    type: \"AnyTypeAnnotation\",\n  };\n}\nexport function arrayTypeAnnotation(\n  elementType: t.FlowType,\n): t.ArrayTypeAnnotation {\n  const node: t.ArrayTypeAnnotation = {\n    type: \"ArrayTypeAnnotation\",\n    elementType,\n  };\n  const defs = NODE_FIELDS.ArrayTypeAnnotation;\n  validate(defs.elementType, node, \"elementType\", elementType, 1);\n  return node;\n}\nexport function booleanTypeAnnotation(): t.BooleanTypeAnnotation {\n  return {\n    type: \"BooleanTypeAnnotation\",\n  };\n}\nexport function booleanLiteralTypeAnnotation(\n  value: boolean,\n): t.BooleanLiteralTypeAnnotation {\n  const node: t.BooleanLiteralTypeAnnotation = {\n    type: \"BooleanLiteralTypeAnnotation\",\n    value,\n  };\n  const defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function nullLiteralTypeAnnotation(): t.NullLiteralTypeAnnotation {\n  return {\n    type: \"NullLiteralTypeAnnotation\",\n  };\n}\nexport function classImplements(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterInstantiation | null = null,\n): t.ClassImplements {\n  const node: t.ClassImplements = {\n    type: \"ClassImplements\",\n    id,\n    typeParameters,\n  };\n  const defs = NODE_FIELDS.ClassImplements;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nexport function declareClass(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  _extends: t.InterfaceExtends[] | null | undefined = null,\n  body: t.ObjectTypeAnnotation,\n): t.DeclareClass {\n  const node: t.DeclareClass = {\n    type: \"DeclareClass\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body,\n  };\n  const defs = NODE_FIELDS.DeclareClass;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function declareFunction(id: t.Identifier): t.DeclareFunction {\n  const node: t.DeclareFunction = {\n    type: \"DeclareFunction\",\n    id,\n  };\n  const defs = NODE_FIELDS.DeclareFunction;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nexport function declareInterface(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  _extends: t.InterfaceExtends[] | null | undefined = null,\n  body: t.ObjectTypeAnnotation,\n): t.DeclareInterface {\n  const node: t.DeclareInterface = {\n    type: \"DeclareInterface\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body,\n  };\n  const defs = NODE_FIELDS.DeclareInterface;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function declareModule(\n  id: t.Identifier | t.StringLiteral,\n  body: t.BlockStatement,\n  kind: \"CommonJS\" | \"ES\" | null = null,\n): t.DeclareModule {\n  const node: t.DeclareModule = {\n    type: \"DeclareModule\",\n    id,\n    body,\n    kind,\n  };\n  const defs = NODE_FIELDS.DeclareModule;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.kind, node, \"kind\", kind);\n  return node;\n}\nexport function declareModuleExports(\n  typeAnnotation: t.TypeAnnotation,\n): t.DeclareModuleExports {\n  const node: t.DeclareModuleExports = {\n    type: \"DeclareModuleExports\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.DeclareModuleExports;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function declareTypeAlias(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  right: t.FlowType,\n): t.DeclareTypeAlias {\n  const node: t.DeclareTypeAlias = {\n    type: \"DeclareTypeAlias\",\n    id,\n    typeParameters,\n    right,\n  };\n  const defs = NODE_FIELDS.DeclareTypeAlias;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function declareOpaqueType(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null = null,\n  supertype: t.FlowType | null = null,\n): t.DeclareOpaqueType {\n  const node: t.DeclareOpaqueType = {\n    type: \"DeclareOpaqueType\",\n    id,\n    typeParameters,\n    supertype,\n  };\n  const defs = NODE_FIELDS.DeclareOpaqueType;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.supertype, node, \"supertype\", supertype, 1);\n  return node;\n}\nexport function declareVariable(id: t.Identifier): t.DeclareVariable {\n  const node: t.DeclareVariable = {\n    type: \"DeclareVariable\",\n    id,\n  };\n  const defs = NODE_FIELDS.DeclareVariable;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nexport function declareExportDeclaration(\n  declaration: t.Flow | null = null,\n  specifiers: (t.ExportSpecifier | t.ExportNamespaceSpecifier)[] | null = null,\n  source: t.StringLiteral | null = null,\n  attributes: t.ImportAttribute[] | null = null,\n): t.DeclareExportDeclaration {\n  const node: t.DeclareExportDeclaration = {\n    type: \"DeclareExportDeclaration\",\n    declaration,\n    specifiers,\n    source,\n    attributes,\n  };\n  const defs = NODE_FIELDS.DeclareExportDeclaration;\n  validate(defs.declaration, node, \"declaration\", declaration, 1);\n  validate(defs.specifiers, node, \"specifiers\", specifiers, 1);\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.attributes, node, \"attributes\", attributes, 1);\n  return node;\n}\nexport function declareExportAllDeclaration(\n  source: t.StringLiteral,\n  attributes: t.ImportAttribute[] | null = null,\n): t.DeclareExportAllDeclaration {\n  const node: t.DeclareExportAllDeclaration = {\n    type: \"DeclareExportAllDeclaration\",\n    source,\n    attributes,\n  };\n  const defs = NODE_FIELDS.DeclareExportAllDeclaration;\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.attributes, node, \"attributes\", attributes, 1);\n  return node;\n}\nexport function declaredPredicate(value: t.Flow): t.DeclaredPredicate {\n  const node: t.DeclaredPredicate = {\n    type: \"DeclaredPredicate\",\n    value,\n  };\n  const defs = NODE_FIELDS.DeclaredPredicate;\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nexport function existsTypeAnnotation(): t.ExistsTypeAnnotation {\n  return {\n    type: \"ExistsTypeAnnotation\",\n  };\n}\nexport function functionTypeAnnotation(\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  params: t.FunctionTypeParam[],\n  rest: t.FunctionTypeParam | null | undefined = null,\n  returnType: t.FlowType,\n): t.FunctionTypeAnnotation {\n  const node: t.FunctionTypeAnnotation = {\n    type: \"FunctionTypeAnnotation\",\n    typeParameters,\n    params,\n    rest,\n    returnType,\n  };\n  const defs = NODE_FIELDS.FunctionTypeAnnotation;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.rest, node, \"rest\", rest, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nexport function functionTypeParam(\n  name: t.Identifier | null | undefined = null,\n  typeAnnotation: t.FlowType,\n): t.FunctionTypeParam {\n  const node: t.FunctionTypeParam = {\n    type: \"FunctionTypeParam\",\n    name,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.FunctionTypeParam;\n  validate(defs.name, node, \"name\", name, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function genericTypeAnnotation(\n  id: t.Identifier | t.QualifiedTypeIdentifier,\n  typeParameters: t.TypeParameterInstantiation | null = null,\n): t.GenericTypeAnnotation {\n  const node: t.GenericTypeAnnotation = {\n    type: \"GenericTypeAnnotation\",\n    id,\n    typeParameters,\n  };\n  const defs = NODE_FIELDS.GenericTypeAnnotation;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nexport function inferredPredicate(): t.InferredPredicate {\n  return {\n    type: \"InferredPredicate\",\n  };\n}\nexport function interfaceExtends(\n  id: t.Identifier | t.QualifiedTypeIdentifier,\n  typeParameters: t.TypeParameterInstantiation | null = null,\n): t.InterfaceExtends {\n  const node: t.InterfaceExtends = {\n    type: \"InterfaceExtends\",\n    id,\n    typeParameters,\n  };\n  const defs = NODE_FIELDS.InterfaceExtends;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nexport function interfaceDeclaration(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  _extends: t.InterfaceExtends[] | null | undefined = null,\n  body: t.ObjectTypeAnnotation,\n): t.InterfaceDeclaration {\n  const node: t.InterfaceDeclaration = {\n    type: \"InterfaceDeclaration\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body,\n  };\n  const defs = NODE_FIELDS.InterfaceDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function interfaceTypeAnnotation(\n  _extends: t.InterfaceExtends[] | null | undefined = null,\n  body: t.ObjectTypeAnnotation,\n): t.InterfaceTypeAnnotation {\n  const node: t.InterfaceTypeAnnotation = {\n    type: \"InterfaceTypeAnnotation\",\n    extends: _extends,\n    body,\n  };\n  const defs = NODE_FIELDS.InterfaceTypeAnnotation;\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function intersectionTypeAnnotation(\n  types: t.FlowType[],\n): t.IntersectionTypeAnnotation {\n  const node: t.IntersectionTypeAnnotation = {\n    type: \"IntersectionTypeAnnotation\",\n    types,\n  };\n  const defs = NODE_FIELDS.IntersectionTypeAnnotation;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nexport function mixedTypeAnnotation(): t.MixedTypeAnnotation {\n  return {\n    type: \"MixedTypeAnnotation\",\n  };\n}\nexport function emptyTypeAnnotation(): t.EmptyTypeAnnotation {\n  return {\n    type: \"EmptyTypeAnnotation\",\n  };\n}\nexport function nullableTypeAnnotation(\n  typeAnnotation: t.FlowType,\n): t.NullableTypeAnnotation {\n  const node: t.NullableTypeAnnotation = {\n    type: \"NullableTypeAnnotation\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.NullableTypeAnnotation;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function numberLiteralTypeAnnotation(\n  value: number,\n): t.NumberLiteralTypeAnnotation {\n  const node: t.NumberLiteralTypeAnnotation = {\n    type: \"NumberLiteralTypeAnnotation\",\n    value,\n  };\n  const defs = NODE_FIELDS.NumberLiteralTypeAnnotation;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function numberTypeAnnotation(): t.NumberTypeAnnotation {\n  return {\n    type: \"NumberTypeAnnotation\",\n  };\n}\nexport function objectTypeAnnotation(\n  properties: (t.ObjectTypeProperty | t.ObjectTypeSpreadProperty)[],\n  indexers: t.ObjectTypeIndexer[] = [],\n  callProperties: t.ObjectTypeCallProperty[] = [],\n  internalSlots: t.ObjectTypeInternalSlot[] = [],\n  exact: boolean = false,\n): t.ObjectTypeAnnotation {\n  const node: t.ObjectTypeAnnotation = {\n    type: \"ObjectTypeAnnotation\",\n    properties,\n    indexers,\n    callProperties,\n    internalSlots,\n    exact,\n  };\n  const defs = NODE_FIELDS.ObjectTypeAnnotation;\n  validate(defs.properties, node, \"properties\", properties, 1);\n  validate(defs.indexers, node, \"indexers\", indexers, 1);\n  validate(defs.callProperties, node, \"callProperties\", callProperties, 1);\n  validate(defs.internalSlots, node, \"internalSlots\", internalSlots, 1);\n  validate(defs.exact, node, \"exact\", exact);\n  return node;\n}\nexport function objectTypeInternalSlot(\n  id: t.Identifier,\n  value: t.FlowType,\n  optional: boolean,\n  _static: boolean,\n  method: boolean,\n): t.ObjectTypeInternalSlot {\n  const node: t.ObjectTypeInternalSlot = {\n    type: \"ObjectTypeInternalSlot\",\n    id,\n    value,\n    optional,\n    static: _static,\n    method,\n  };\n  const defs = NODE_FIELDS.ObjectTypeInternalSlot;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.optional, node, \"optional\", optional);\n  validate(defs.static, node, \"static\", _static);\n  validate(defs.method, node, \"method\", method);\n  return node;\n}\nexport function objectTypeCallProperty(\n  value: t.FlowType,\n): t.ObjectTypeCallProperty {\n  const node: t.ObjectTypeCallProperty = {\n    type: \"ObjectTypeCallProperty\",\n    value,\n    static: false,\n  };\n  const defs = NODE_FIELDS.ObjectTypeCallProperty;\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nexport function objectTypeIndexer(\n  id: t.Identifier | null | undefined = null,\n  key: t.FlowType,\n  value: t.FlowType,\n  variance: t.Variance | null = null,\n): t.ObjectTypeIndexer {\n  const node: t.ObjectTypeIndexer = {\n    type: \"ObjectTypeIndexer\",\n    id,\n    key,\n    value,\n    variance,\n    static: false,\n  };\n  const defs = NODE_FIELDS.ObjectTypeIndexer;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.variance, node, \"variance\", variance, 1);\n  return node;\n}\nexport function objectTypeProperty(\n  key: t.Identifier | t.StringLiteral,\n  value: t.FlowType,\n  variance: t.Variance | null = null,\n): t.ObjectTypeProperty {\n  const node: t.ObjectTypeProperty = {\n    type: \"ObjectTypeProperty\",\n    key,\n    value,\n    variance,\n    kind: \"init\",\n    method: false,\n    optional: false,\n    proto: false,\n    static: false,\n  };\n  const defs = NODE_FIELDS.ObjectTypeProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.variance, node, \"variance\", variance, 1);\n  return node;\n}\nexport function objectTypeSpreadProperty(\n  argument: t.FlowType,\n): t.ObjectTypeSpreadProperty {\n  const node: t.ObjectTypeSpreadProperty = {\n    type: \"ObjectTypeSpreadProperty\",\n    argument,\n  };\n  const defs = NODE_FIELDS.ObjectTypeSpreadProperty;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport function opaqueType(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  supertype: t.FlowType | null | undefined = null,\n  impltype: t.FlowType,\n): t.OpaqueType {\n  const node: t.OpaqueType = {\n    type: \"OpaqueType\",\n    id,\n    typeParameters,\n    supertype,\n    impltype,\n  };\n  const defs = NODE_FIELDS.OpaqueType;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.supertype, node, \"supertype\", supertype, 1);\n  validate(defs.impltype, node, \"impltype\", impltype, 1);\n  return node;\n}\nexport function qualifiedTypeIdentifier(\n  id: t.Identifier,\n  qualification: t.Identifier | t.QualifiedTypeIdentifier,\n): t.QualifiedTypeIdentifier {\n  const node: t.QualifiedTypeIdentifier = {\n    type: \"QualifiedTypeIdentifier\",\n    id,\n    qualification,\n  };\n  const defs = NODE_FIELDS.QualifiedTypeIdentifier;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.qualification, node, \"qualification\", qualification, 1);\n  return node;\n}\nexport function stringLiteralTypeAnnotation(\n  value: string,\n): t.StringLiteralTypeAnnotation {\n  const node: t.StringLiteralTypeAnnotation = {\n    type: \"StringLiteralTypeAnnotation\",\n    value,\n  };\n  const defs = NODE_FIELDS.StringLiteralTypeAnnotation;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function stringTypeAnnotation(): t.StringTypeAnnotation {\n  return {\n    type: \"StringTypeAnnotation\",\n  };\n}\nexport function symbolTypeAnnotation(): t.SymbolTypeAnnotation {\n  return {\n    type: \"SymbolTypeAnnotation\",\n  };\n}\nexport function thisTypeAnnotation(): t.ThisTypeAnnotation {\n  return {\n    type: \"ThisTypeAnnotation\",\n  };\n}\nexport function tupleTypeAnnotation(\n  types: t.FlowType[],\n): t.TupleTypeAnnotation {\n  const node: t.TupleTypeAnnotation = {\n    type: \"TupleTypeAnnotation\",\n    types,\n  };\n  const defs = NODE_FIELDS.TupleTypeAnnotation;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nexport function typeofTypeAnnotation(\n  argument: t.FlowType,\n): t.TypeofTypeAnnotation {\n  const node: t.TypeofTypeAnnotation = {\n    type: \"TypeofTypeAnnotation\",\n    argument,\n  };\n  const defs = NODE_FIELDS.TypeofTypeAnnotation;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport function typeAlias(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  right: t.FlowType,\n): t.TypeAlias {\n  const node: t.TypeAlias = {\n    type: \"TypeAlias\",\n    id,\n    typeParameters,\n    right,\n  };\n  const defs = NODE_FIELDS.TypeAlias;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function typeAnnotation(typeAnnotation: t.FlowType): t.TypeAnnotation {\n  const node: t.TypeAnnotation = {\n    type: \"TypeAnnotation\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TypeAnnotation;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function typeCastExpression(\n  expression: t.Expression,\n  typeAnnotation: t.TypeAnnotation,\n): t.TypeCastExpression {\n  const node: t.TypeCastExpression = {\n    type: \"TypeCastExpression\",\n    expression,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TypeCastExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function typeParameter(\n  name: string,\n  bound: t.TypeAnnotation | null = null,\n  _default: t.FlowType | null = null,\n  variance: t.Variance | null = null,\n): t.TypeParameter {\n  const node: t.TypeParameter = {\n    type: \"TypeParameter\",\n    name,\n    bound,\n    default: _default,\n    variance,\n  };\n  const defs = NODE_FIELDS.TypeParameter;\n  validate(defs.name, node, \"name\", name);\n  validate(defs.bound, node, \"bound\", bound, 1);\n  validate(defs.default, node, \"default\", _default, 1);\n  validate(defs.variance, node, \"variance\", variance, 1);\n  return node;\n}\nexport function typeParameterDeclaration(\n  params: t.TypeParameter[],\n): t.TypeParameterDeclaration {\n  const node: t.TypeParameterDeclaration = {\n    type: \"TypeParameterDeclaration\",\n    params,\n  };\n  const defs = NODE_FIELDS.TypeParameterDeclaration;\n  validate(defs.params, node, \"params\", params, 1);\n  return node;\n}\nexport function typeParameterInstantiation(\n  params: t.FlowType[],\n): t.TypeParameterInstantiation {\n  const node: t.TypeParameterInstantiation = {\n    type: \"TypeParameterInstantiation\",\n    params,\n  };\n  const defs = NODE_FIELDS.TypeParameterInstantiation;\n  validate(defs.params, node, \"params\", params, 1);\n  return node;\n}\nexport function unionTypeAnnotation(\n  types: t.FlowType[],\n): t.UnionTypeAnnotation {\n  const node: t.UnionTypeAnnotation = {\n    type: \"UnionTypeAnnotation\",\n    types,\n  };\n  const defs = NODE_FIELDS.UnionTypeAnnotation;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nexport function variance(kind: \"minus\" | \"plus\"): t.Variance {\n  const node: t.Variance = {\n    type: \"Variance\",\n    kind,\n  };\n  const defs = NODE_FIELDS.Variance;\n  validate(defs.kind, node, \"kind\", kind);\n  return node;\n}\nexport function voidTypeAnnotation(): t.VoidTypeAnnotation {\n  return {\n    type: \"VoidTypeAnnotation\",\n  };\n}\nexport function enumDeclaration(\n  id: t.Identifier,\n  body:\n    | t.EnumBooleanBody\n    | t.EnumNumberBody\n    | t.EnumStringBody\n    | t.EnumSymbolBody,\n): t.EnumDeclaration {\n  const node: t.EnumDeclaration = {\n    type: \"EnumDeclaration\",\n    id,\n    body,\n  };\n  const defs = NODE_FIELDS.EnumDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function enumBooleanBody(\n  members: t.EnumBooleanMember[],\n): t.EnumBooleanBody {\n  const node: t.EnumBooleanBody = {\n    type: \"EnumBooleanBody\",\n    members,\n    explicitType: false,\n    hasUnknownMembers: false,\n  };\n  const defs = NODE_FIELDS.EnumBooleanBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nexport function enumNumberBody(\n  members: t.EnumNumberMember[],\n): t.EnumNumberBody {\n  const node: t.EnumNumberBody = {\n    type: \"EnumNumberBody\",\n    members,\n    explicitType: false,\n    hasUnknownMembers: false,\n  };\n  const defs = NODE_FIELDS.EnumNumberBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nexport function enumStringBody(\n  members: (t.EnumStringMember | t.EnumDefaultedMember)[],\n): t.EnumStringBody {\n  const node: t.EnumStringBody = {\n    type: \"EnumStringBody\",\n    members,\n    explicitType: false,\n    hasUnknownMembers: false,\n  };\n  const defs = NODE_FIELDS.EnumStringBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nexport function enumSymbolBody(\n  members: t.EnumDefaultedMember[],\n): t.EnumSymbolBody {\n  const node: t.EnumSymbolBody = {\n    type: \"EnumSymbolBody\",\n    members,\n    hasUnknownMembers: false,\n  };\n  const defs = NODE_FIELDS.EnumSymbolBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nexport function enumBooleanMember(\n  id: t.Identifier,\n  init: t.BooleanLiteral,\n): t.EnumBooleanMember {\n  const node: t.EnumBooleanMember = {\n    type: \"EnumBooleanMember\",\n    id,\n    init,\n  };\n  const defs = NODE_FIELDS.EnumBooleanMember;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.init, node, \"init\", init, 1);\n  return node;\n}\nexport function enumNumberMember(\n  id: t.Identifier,\n  init: t.NumericLiteral,\n): t.EnumNumberMember {\n  const node: t.EnumNumberMember = {\n    type: \"EnumNumberMember\",\n    id,\n    init,\n  };\n  const defs = NODE_FIELDS.EnumNumberMember;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.init, node, \"init\", init, 1);\n  return node;\n}\nexport function enumStringMember(\n  id: t.Identifier,\n  init: t.StringLiteral,\n): t.EnumStringMember {\n  const node: t.EnumStringMember = {\n    type: \"EnumStringMember\",\n    id,\n    init,\n  };\n  const defs = NODE_FIELDS.EnumStringMember;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.init, node, \"init\", init, 1);\n  return node;\n}\nexport function enumDefaultedMember(id: t.Identifier): t.EnumDefaultedMember {\n  const node: t.EnumDefaultedMember = {\n    type: \"EnumDefaultedMember\",\n    id,\n  };\n  const defs = NODE_FIELDS.EnumDefaultedMember;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nexport function indexedAccessType(\n  objectType: t.FlowType,\n  indexType: t.FlowType,\n): t.IndexedAccessType {\n  const node: t.IndexedAccessType = {\n    type: \"IndexedAccessType\",\n    objectType,\n    indexType,\n  };\n  const defs = NODE_FIELDS.IndexedAccessType;\n  validate(defs.objectType, node, \"objectType\", objectType, 1);\n  validate(defs.indexType, node, \"indexType\", indexType, 1);\n  return node;\n}\nexport function optionalIndexedAccessType(\n  objectType: t.FlowType,\n  indexType: t.FlowType,\n): t.OptionalIndexedAccessType {\n  const node: t.OptionalIndexedAccessType = {\n    type: \"OptionalIndexedAccessType\",\n    objectType,\n    indexType,\n    optional: false,\n  };\n  const defs = NODE_FIELDS.OptionalIndexedAccessType;\n  validate(defs.objectType, node, \"objectType\", objectType, 1);\n  validate(defs.indexType, node, \"indexType\", indexType, 1);\n  return node;\n}\nexport function jsxAttribute(\n  name: t.JSXIdentifier | t.JSXNamespacedName,\n  value:\n    | t.JSXElement\n    | t.JSXFragment\n    | t.StringLiteral\n    | t.JSXExpressionContainer\n    | null = null,\n): t.JSXAttribute {\n  const node: t.JSXAttribute = {\n    type: \"JSXAttribute\",\n    name,\n    value,\n  };\n  const defs = NODE_FIELDS.JSXAttribute;\n  validate(defs.name, node, \"name\", name, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nexport function jsxClosingElement(\n  name: t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName,\n): t.JSXClosingElement {\n  const node: t.JSXClosingElement = {\n    type: \"JSXClosingElement\",\n    name,\n  };\n  const defs = NODE_FIELDS.JSXClosingElement;\n  validate(defs.name, node, \"name\", name, 1);\n  return node;\n}\nexport function jsxElement(\n  openingElement: t.JSXOpeningElement,\n  closingElement: t.JSXClosingElement | null | undefined = null,\n  children: (\n    | t.JSXText\n    | t.JSXExpressionContainer\n    | t.JSXSpreadChild\n    | t.JSXElement\n    | t.JSXFragment\n  )[],\n): t.JSXElement {\n  const node: t.JSXElement = {\n    type: \"JSXElement\",\n    openingElement,\n    closingElement,\n    children,\n  };\n  const defs = NODE_FIELDS.JSXElement;\n  validate(defs.openingElement, node, \"openingElement\", openingElement, 1);\n  validate(defs.closingElement, node, \"closingElement\", closingElement, 1);\n  validate(defs.children, node, \"children\", children, 1);\n  return node;\n}\nexport function jsxEmptyExpression(): t.JSXEmptyExpression {\n  return {\n    type: \"JSXEmptyExpression\",\n  };\n}\nexport function jsxExpressionContainer(\n  expression: t.Expression | t.JSXEmptyExpression,\n): t.JSXExpressionContainer {\n  const node: t.JSXExpressionContainer = {\n    type: \"JSXExpressionContainer\",\n    expression,\n  };\n  const defs = NODE_FIELDS.JSXExpressionContainer;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function jsxSpreadChild(expression: t.Expression): t.JSXSpreadChild {\n  const node: t.JSXSpreadChild = {\n    type: \"JSXSpreadChild\",\n    expression,\n  };\n  const defs = NODE_FIELDS.JSXSpreadChild;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function jsxIdentifier(name: string): t.JSXIdentifier {\n  const node: t.JSXIdentifier = {\n    type: \"JSXIdentifier\",\n    name,\n  };\n  const defs = NODE_FIELDS.JSXIdentifier;\n  validate(defs.name, node, \"name\", name);\n  return node;\n}\nexport function jsxMemberExpression(\n  object: t.JSXMemberExpression | t.JSXIdentifier,\n  property: t.JSXIdentifier,\n): t.JSXMemberExpression {\n  const node: t.JSXMemberExpression = {\n    type: \"JSXMemberExpression\",\n    object,\n    property,\n  };\n  const defs = NODE_FIELDS.JSXMemberExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  return node;\n}\nexport function jsxNamespacedName(\n  namespace: t.JSXIdentifier,\n  name: t.JSXIdentifier,\n): t.JSXNamespacedName {\n  const node: t.JSXNamespacedName = {\n    type: \"JSXNamespacedName\",\n    namespace,\n    name,\n  };\n  const defs = NODE_FIELDS.JSXNamespacedName;\n  validate(defs.namespace, node, \"namespace\", namespace, 1);\n  validate(defs.name, node, \"name\", name, 1);\n  return node;\n}\nexport function jsxOpeningElement(\n  name: t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName,\n  attributes: (t.JSXAttribute | t.JSXSpreadAttribute)[],\n  selfClosing: boolean = false,\n): t.JSXOpeningElement {\n  const node: t.JSXOpeningElement = {\n    type: \"JSXOpeningElement\",\n    name,\n    attributes,\n    selfClosing,\n  };\n  const defs = NODE_FIELDS.JSXOpeningElement;\n  validate(defs.name, node, \"name\", name, 1);\n  validate(defs.attributes, node, \"attributes\", attributes, 1);\n  validate(defs.selfClosing, node, \"selfClosing\", selfClosing);\n  return node;\n}\nexport function jsxSpreadAttribute(\n  argument: t.Expression,\n): t.JSXSpreadAttribute {\n  const node: t.JSXSpreadAttribute = {\n    type: \"JSXSpreadAttribute\",\n    argument,\n  };\n  const defs = NODE_FIELDS.JSXSpreadAttribute;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport function jsxText(value: string): t.JSXText {\n  const node: t.JSXText = {\n    type: \"JSXText\",\n    value,\n  };\n  const defs = NODE_FIELDS.JSXText;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function jsxFragment(\n  openingFragment: t.JSXOpeningFragment,\n  closingFragment: t.JSXClosingFragment,\n  children: (\n    | t.JSXText\n    | t.JSXExpressionContainer\n    | t.JSXSpreadChild\n    | t.JSXElement\n    | t.JSXFragment\n  )[],\n): t.JSXFragment {\n  const node: t.JSXFragment = {\n    type: \"JSXFragment\",\n    openingFragment,\n    closingFragment,\n    children,\n  };\n  const defs = NODE_FIELDS.JSXFragment;\n  validate(defs.openingFragment, node, \"openingFragment\", openingFragment, 1);\n  validate(defs.closingFragment, node, \"closingFragment\", closingFragment, 1);\n  validate(defs.children, node, \"children\", children, 1);\n  return node;\n}\nexport function jsxOpeningFragment(): t.JSXOpeningFragment {\n  return {\n    type: \"JSXOpeningFragment\",\n  };\n}\nexport function jsxClosingFragment(): t.JSXClosingFragment {\n  return {\n    type: \"JSXClosingFragment\",\n  };\n}\nexport function placeholder(\n  expectedNode:\n    | \"Identifier\"\n    | \"StringLiteral\"\n    | \"Expression\"\n    | \"Statement\"\n    | \"Declaration\"\n    | \"BlockStatement\"\n    | \"ClassBody\"\n    | \"Pattern\",\n  name: t.Identifier,\n): t.Placeholder {\n  const node: t.Placeholder = {\n    type: \"Placeholder\",\n    expectedNode,\n    name,\n  };\n  const defs = NODE_FIELDS.Placeholder;\n  validate(defs.expectedNode, node, \"expectedNode\", expectedNode);\n  validate(defs.name, node, \"name\", name, 1);\n  return node;\n}\nexport function v8IntrinsicIdentifier(name: string): t.V8IntrinsicIdentifier {\n  const node: t.V8IntrinsicIdentifier = {\n    type: \"V8IntrinsicIdentifier\",\n    name,\n  };\n  const defs = NODE_FIELDS.V8IntrinsicIdentifier;\n  validate(defs.name, node, \"name\", name);\n  return node;\n}\nexport function argumentPlaceholder(): t.ArgumentPlaceholder {\n  return {\n    type: \"ArgumentPlaceholder\",\n  };\n}\nexport function bindExpression(\n  object: t.Expression,\n  callee: t.Expression,\n): t.BindExpression {\n  const node: t.BindExpression = {\n    type: \"BindExpression\",\n    object,\n    callee,\n  };\n  const defs = NODE_FIELDS.BindExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.callee, node, \"callee\", callee, 1);\n  return node;\n}\nexport function classAccessorProperty(\n  key: t.Expression,\n  value?: t.Expression | null,\n  typeAnnotation?: t.TypeAnnotation | t.TSTypeAnnotation | null,\n  decorators?: t.Decorator[] | null,\n  computed?: true,\n  _static?: boolean,\n): Extract<t.ClassAccessorProperty, { computed: true }>;\nexport function classAccessorProperty(\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.PrivateName,\n  value?: t.Expression | null,\n  typeAnnotation?: t.TypeAnnotation | t.TSTypeAnnotation | null,\n  decorators?: t.Decorator[] | null,\n  computed?: false,\n  _static?: boolean,\n): Extract<t.ClassAccessorProperty, { computed: false }>;\nexport function classAccessorProperty(\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression\n    | t.PrivateName,\n  value?: t.Expression | null,\n  typeAnnotation?: t.TypeAnnotation | t.TSTypeAnnotation | null,\n  decorators?: t.Decorator[] | null,\n  computed?: boolean,\n  _static?: boolean,\n): t.ClassAccessorProperty;\nexport function classAccessorProperty(\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression\n    | t.PrivateName,\n  value: t.Expression | null = null,\n  typeAnnotation: t.TypeAnnotation | t.TSTypeAnnotation | null = null,\n  decorators: t.Decorator[] | null = null,\n  computed: boolean = false,\n  _static: boolean = false,\n): t.ClassAccessorProperty {\n  const node = {\n    type: \"ClassAccessorProperty\",\n    key,\n    value,\n    typeAnnotation,\n    decorators,\n    computed,\n    static: _static,\n  } as t.ClassAccessorProperty;\n  const defs = NODE_FIELDS.ClassAccessorProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nexport function decorator(expression: t.Expression): t.Decorator {\n  const node: t.Decorator = {\n    type: \"Decorator\",\n    expression,\n  };\n  const defs = NODE_FIELDS.Decorator;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function doExpression(\n  body: t.BlockStatement,\n  async: boolean = false,\n): t.DoExpression {\n  const node: t.DoExpression = {\n    type: \"DoExpression\",\n    body,\n    async,\n  };\n  const defs = NODE_FIELDS.DoExpression;\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function exportDefaultSpecifier(\n  exported: t.Identifier,\n): t.ExportDefaultSpecifier {\n  const node: t.ExportDefaultSpecifier = {\n    type: \"ExportDefaultSpecifier\",\n    exported,\n  };\n  const defs = NODE_FIELDS.ExportDefaultSpecifier;\n  validate(defs.exported, node, \"exported\", exported, 1);\n  return node;\n}\nexport function moduleExpression(body: t.Program): t.ModuleExpression {\n  const node: t.ModuleExpression = {\n    type: \"ModuleExpression\",\n    body,\n  };\n  const defs = NODE_FIELDS.ModuleExpression;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function topicReference(): t.TopicReference {\n  return {\n    type: \"TopicReference\",\n  };\n}\nexport function voidPattern(): t.VoidPattern {\n  return {\n    type: \"VoidPattern\",\n  };\n}\nexport function tsParameterProperty(\n  parameter: t.Identifier | t.AssignmentPattern,\n): t.TSParameterProperty {\n  const node: t.TSParameterProperty = {\n    type: \"TSParameterProperty\",\n    parameter,\n  };\n  const defs = NODE_FIELDS.TSParameterProperty;\n  validate(defs.parameter, node, \"parameter\", parameter, 1);\n  return node;\n}\nexport function tsDeclareFunction(\n  id: t.Identifier | null | undefined = null,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  params: t.FunctionParameter[],\n  returnType: t.TSTypeAnnotation | null = null,\n): t.TSDeclareFunction {\n  const node: t.TSDeclareFunction = {\n    type: \"TSDeclareFunction\",\n    id,\n    typeParameters,\n    params,\n    returnType,\n    async: false,\n    generator: false,\n  };\n  const defs = NODE_FIELDS.TSDeclareFunction;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nexport function tsDeclareMethod(\n  decorators: t.Decorator[] | null | undefined,\n  key: t.Expression,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined,\n  params: (t.FunctionParameter | t.TSParameterProperty)[],\n  returnType?: t.TSTypeAnnotation | null,\n): Extract<t.TSDeclareMethod, { computed: true }>;\nexport function tsDeclareMethod(\n  decorators: t.Decorator[] | null | undefined,\n  key: t.Identifier | t.StringLiteral | t.NumericLiteral | t.BigIntLiteral,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined,\n  params: (t.FunctionParameter | t.TSParameterProperty)[],\n  returnType?: t.TSTypeAnnotation | null,\n): Extract<t.TSDeclareMethod, { computed: false }>;\nexport function tsDeclareMethod(\n  decorators: t.Decorator[] | null | undefined,\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined,\n  params: (t.FunctionParameter | t.TSParameterProperty)[],\n  returnType?: t.TSTypeAnnotation | null,\n): t.TSDeclareMethod;\nexport function tsDeclareMethod(\n  decorators: t.Decorator[] | null | undefined = null,\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  params: (t.FunctionParameter | t.TSParameterProperty)[],\n  returnType: t.TSTypeAnnotation | null = null,\n): t.TSDeclareMethod {\n  const node = {\n    type: \"TSDeclareMethod\",\n    decorators,\n    key,\n    typeParameters,\n    params,\n    returnType,\n    async: false,\n    computed: false,\n    generator: false,\n    kind: \"method\",\n    static: false,\n  } as t.TSDeclareMethod;\n  const defs = NODE_FIELDS.TSDeclareMethod;\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nexport function tsQualifiedName(\n  left: t.TSEntityName,\n  right: t.Identifier,\n): t.TSQualifiedName {\n  const node: t.TSQualifiedName = {\n    type: \"TSQualifiedName\",\n    left,\n    right,\n  };\n  const defs = NODE_FIELDS.TSQualifiedName;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function tsCallSignatureDeclaration(\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  params: (t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement)[],\n  returnType: t.TSTypeAnnotation | null = null,\n): t.TSCallSignatureDeclaration {\n  const node: t.TSCallSignatureDeclaration = {\n    type: \"TSCallSignatureDeclaration\",\n    typeParameters,\n    params,\n    returnType,\n  };\n  const defs = NODE_FIELDS.TSCallSignatureDeclaration;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nexport function tsConstructSignatureDeclaration(\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  params: (t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement)[],\n  returnType: t.TSTypeAnnotation | null = null,\n): t.TSConstructSignatureDeclaration {\n  const node: t.TSConstructSignatureDeclaration = {\n    type: \"TSConstructSignatureDeclaration\",\n    typeParameters,\n    params,\n    returnType,\n  };\n  const defs = NODE_FIELDS.TSConstructSignatureDeclaration;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nexport function tsPropertySignature(\n  key: t.Expression,\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n): t.TSPropertySignature {\n  const node: t.TSPropertySignature = {\n    type: \"TSPropertySignature\",\n    key,\n    typeAnnotation,\n    computed: false,\n  };\n  const defs = NODE_FIELDS.TSPropertySignature;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function tsMethodSignature(\n  key: t.Expression,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  params: (t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement)[],\n  returnType: t.TSTypeAnnotation | null = null,\n): t.TSMethodSignature {\n  const node: t.TSMethodSignature = {\n    type: \"TSMethodSignature\",\n    key,\n    typeParameters,\n    params,\n    returnType,\n    computed: false,\n    kind: \"method\",\n  };\n  const defs = NODE_FIELDS.TSMethodSignature;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nexport function tsIndexSignature(\n  parameters: t.Identifier[],\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n): t.TSIndexSignature {\n  const node: t.TSIndexSignature = {\n    type: \"TSIndexSignature\",\n    parameters,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSIndexSignature;\n  validate(defs.parameters, node, \"parameters\", parameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function tsAnyKeyword(): t.TSAnyKeyword {\n  return {\n    type: \"TSAnyKeyword\",\n  };\n}\nexport function tsBooleanKeyword(): t.TSBooleanKeyword {\n  return {\n    type: \"TSBooleanKeyword\",\n  };\n}\nexport function tsBigIntKeyword(): t.TSBigIntKeyword {\n  return {\n    type: \"TSBigIntKeyword\",\n  };\n}\nexport function tsIntrinsicKeyword(): t.TSIntrinsicKeyword {\n  return {\n    type: \"TSIntrinsicKeyword\",\n  };\n}\nexport function tsNeverKeyword(): t.TSNeverKeyword {\n  return {\n    type: \"TSNeverKeyword\",\n  };\n}\nexport function tsNullKeyword(): t.TSNullKeyword {\n  return {\n    type: \"TSNullKeyword\",\n  };\n}\nexport function tsNumberKeyword(): t.TSNumberKeyword {\n  return {\n    type: \"TSNumberKeyword\",\n  };\n}\nexport function tsObjectKeyword(): t.TSObjectKeyword {\n  return {\n    type: \"TSObjectKeyword\",\n  };\n}\nexport function tsStringKeyword(): t.TSStringKeyword {\n  return {\n    type: \"TSStringKeyword\",\n  };\n}\nexport function tsSymbolKeyword(): t.TSSymbolKeyword {\n  return {\n    type: \"TSSymbolKeyword\",\n  };\n}\nexport function tsUndefinedKeyword(): t.TSUndefinedKeyword {\n  return {\n    type: \"TSUndefinedKeyword\",\n  };\n}\nexport function tsUnknownKeyword(): t.TSUnknownKeyword {\n  return {\n    type: \"TSUnknownKeyword\",\n  };\n}\nexport function tsVoidKeyword(): t.TSVoidKeyword {\n  return {\n    type: \"TSVoidKeyword\",\n  };\n}\nexport function tsThisType(): t.TSThisType {\n  return {\n    type: \"TSThisType\",\n  };\n}\nexport function tsFunctionType(\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  params: (t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement)[],\n  returnType: t.TSTypeAnnotation | null = null,\n): t.TSFunctionType {\n  const node: t.TSFunctionType = {\n    type: \"TSFunctionType\",\n    typeParameters,\n    params,\n    returnType,\n  };\n  const defs = NODE_FIELDS.TSFunctionType;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nexport function tsConstructorType(\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  params: (t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement)[],\n  returnType: t.TSTypeAnnotation | null = null,\n): t.TSConstructorType {\n  const node: t.TSConstructorType = {\n    type: \"TSConstructorType\",\n    typeParameters,\n    params,\n    returnType,\n  };\n  const defs = NODE_FIELDS.TSConstructorType;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nexport function tsTypeReference(\n  typeName: t.TSEntityName,\n  typeArguments: t.TSTypeParameterInstantiation | null = null,\n): t.TSTypeReference {\n  const node: t.TSTypeReference = {\n    type: \"TSTypeReference\",\n    typeName,\n    typeArguments,\n  };\n  const defs = NODE_FIELDS.TSTypeReference;\n  validate(defs.typeName, node, \"typeName\", typeName, 1);\n  validate(defs.typeArguments, node, \"typeArguments\", typeArguments, 1);\n  return node;\n}\nexport function tsTypePredicate(\n  parameterName: t.Identifier | t.TSThisType,\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n  asserts: boolean | null = null,\n): t.TSTypePredicate {\n  const node: t.TSTypePredicate = {\n    type: \"TSTypePredicate\",\n    parameterName,\n    typeAnnotation,\n    asserts,\n  };\n  const defs = NODE_FIELDS.TSTypePredicate;\n  validate(defs.parameterName, node, \"parameterName\", parameterName, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.asserts, node, \"asserts\", asserts);\n  return node;\n}\nexport function tsTypeQuery(\n  exprName: t.TSEntityName | t.TSImportType,\n  typeArguments: t.TSTypeParameterInstantiation | null = null,\n): t.TSTypeQuery {\n  const node: t.TSTypeQuery = {\n    type: \"TSTypeQuery\",\n    exprName,\n    typeArguments,\n  };\n  const defs = NODE_FIELDS.TSTypeQuery;\n  validate(defs.exprName, node, \"exprName\", exprName, 1);\n  validate(defs.typeArguments, node, \"typeArguments\", typeArguments, 1);\n  return node;\n}\nexport function tsTypeLiteral(members: t.TSTypeElement[]): t.TSTypeLiteral {\n  const node: t.TSTypeLiteral = {\n    type: \"TSTypeLiteral\",\n    members,\n  };\n  const defs = NODE_FIELDS.TSTypeLiteral;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nexport function tsArrayType(elementType: t.TSType): t.TSArrayType {\n  const node: t.TSArrayType = {\n    type: \"TSArrayType\",\n    elementType,\n  };\n  const defs = NODE_FIELDS.TSArrayType;\n  validate(defs.elementType, node, \"elementType\", elementType, 1);\n  return node;\n}\nexport function tsTupleType(\n  elementTypes: (t.TSType | t.TSNamedTupleMember)[],\n): t.TSTupleType {\n  const node: t.TSTupleType = {\n    type: \"TSTupleType\",\n    elementTypes,\n  };\n  const defs = NODE_FIELDS.TSTupleType;\n  validate(defs.elementTypes, node, \"elementTypes\", elementTypes, 1);\n  return node;\n}\nexport function tsOptionalType(typeAnnotation: t.TSType): t.TSOptionalType {\n  const node: t.TSOptionalType = {\n    type: \"TSOptionalType\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSOptionalType;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function tsRestType(typeAnnotation: t.TSType): t.TSRestType {\n  const node: t.TSRestType = {\n    type: \"TSRestType\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSRestType;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function tsNamedTupleMember(\n  label: t.Identifier,\n  elementType: t.TSType,\n  optional: boolean = false,\n): t.TSNamedTupleMember {\n  const node: t.TSNamedTupleMember = {\n    type: \"TSNamedTupleMember\",\n    label,\n    elementType,\n    optional,\n  };\n  const defs = NODE_FIELDS.TSNamedTupleMember;\n  validate(defs.label, node, \"label\", label, 1);\n  validate(defs.elementType, node, \"elementType\", elementType, 1);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nexport function tsUnionType(types: t.TSType[]): t.TSUnionType {\n  const node: t.TSUnionType = {\n    type: \"TSUnionType\",\n    types,\n  };\n  const defs = NODE_FIELDS.TSUnionType;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nexport function tsIntersectionType(types: t.TSType[]): t.TSIntersectionType {\n  const node: t.TSIntersectionType = {\n    type: \"TSIntersectionType\",\n    types,\n  };\n  const defs = NODE_FIELDS.TSIntersectionType;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nexport function tsConditionalType(\n  checkType: t.TSType,\n  extendsType: t.TSType,\n  trueType: t.TSType,\n  falseType: t.TSType,\n): t.TSConditionalType {\n  const node: t.TSConditionalType = {\n    type: \"TSConditionalType\",\n    checkType,\n    extendsType,\n    trueType,\n    falseType,\n  };\n  const defs = NODE_FIELDS.TSConditionalType;\n  validate(defs.checkType, node, \"checkType\", checkType, 1);\n  validate(defs.extendsType, node, \"extendsType\", extendsType, 1);\n  validate(defs.trueType, node, \"trueType\", trueType, 1);\n  validate(defs.falseType, node, \"falseType\", falseType, 1);\n  return node;\n}\nexport function tsInferType(typeParameter: t.TSTypeParameter): t.TSInferType {\n  const node: t.TSInferType = {\n    type: \"TSInferType\",\n    typeParameter,\n  };\n  const defs = NODE_FIELDS.TSInferType;\n  validate(defs.typeParameter, node, \"typeParameter\", typeParameter, 1);\n  return node;\n}\nexport function tsParenthesizedType(\n  typeAnnotation: t.TSType,\n): t.TSParenthesizedType {\n  const node: t.TSParenthesizedType = {\n    type: \"TSParenthesizedType\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSParenthesizedType;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function tsTypeOperator(\n  typeAnnotation: t.TSType,\n  operator: \"keyof\" | \"readonly\" | \"unique\",\n): t.TSTypeOperator {\n  const node: t.TSTypeOperator = {\n    type: \"TSTypeOperator\",\n    typeAnnotation,\n    operator,\n  };\n  const defs = NODE_FIELDS.TSTypeOperator;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.operator, node, \"operator\", operator);\n  return node;\n}\nexport function tsIndexedAccessType(\n  objectType: t.TSType,\n  indexType: t.TSType,\n): t.TSIndexedAccessType {\n  const node: t.TSIndexedAccessType = {\n    type: \"TSIndexedAccessType\",\n    objectType,\n    indexType,\n  };\n  const defs = NODE_FIELDS.TSIndexedAccessType;\n  validate(defs.objectType, node, \"objectType\", objectType, 1);\n  validate(defs.indexType, node, \"indexType\", indexType, 1);\n  return node;\n}\nexport function tsMappedType(\n  key: t.Identifier,\n  constraint: t.TSType,\n  nameType: t.TSType | null = null,\n  typeAnnotation: t.TSType | null = null,\n): t.TSMappedType {\n  const node: t.TSMappedType = {\n    type: \"TSMappedType\",\n    key,\n    constraint,\n    nameType,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSMappedType;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.constraint, node, \"constraint\", constraint, 1);\n  validate(defs.nameType, node, \"nameType\", nameType, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function tsTemplateLiteralType(\n  quasis: t.TemplateElement[],\n  types: t.TSType[],\n): t.TSTemplateLiteralType {\n  const node: t.TSTemplateLiteralType = {\n    type: \"TSTemplateLiteralType\",\n    quasis,\n    types,\n  };\n  const defs = NODE_FIELDS.TSTemplateLiteralType;\n  validate(defs.quasis, node, \"quasis\", quasis, 1);\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nexport function tsLiteralType(\n  literal:\n    | t.NumericLiteral\n    | t.StringLiteral\n    | t.BooleanLiteral\n    | t.BigIntLiteral\n    | t.TemplateLiteral\n    | t.UnaryExpression,\n): t.TSLiteralType {\n  const node: t.TSLiteralType = {\n    type: \"TSLiteralType\",\n    literal,\n  };\n  const defs = NODE_FIELDS.TSLiteralType;\n  validate(defs.literal, node, \"literal\", literal, 1);\n  return node;\n}\nexport function tsClassImplements(\n  expression: t.Expression,\n  typeArguments: t.TSTypeParameterInstantiation | null = null,\n): t.TSClassImplements {\n  const node: t.TSClassImplements = {\n    type: \"TSClassImplements\",\n    expression,\n    typeArguments,\n  };\n  const defs = NODE_FIELDS.TSClassImplements;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeArguments, node, \"typeArguments\", typeArguments, 1);\n  return node;\n}\nexport function tsInterfaceHeritage(\n  expression: t.Expression,\n  typeArguments: t.TSTypeParameterInstantiation | null = null,\n): t.TSInterfaceHeritage {\n  const node: t.TSInterfaceHeritage = {\n    type: \"TSInterfaceHeritage\",\n    expression,\n    typeArguments,\n  };\n  const defs = NODE_FIELDS.TSInterfaceHeritage;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeArguments, node, \"typeArguments\", typeArguments, 1);\n  return node;\n}\nexport function tsInterfaceDeclaration(\n  id: t.Identifier,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  _extends: t.TSClassImplements[] | null | undefined = null,\n  body: t.TSInterfaceBody,\n): t.TSInterfaceDeclaration {\n  const node: t.TSInterfaceDeclaration = {\n    type: \"TSInterfaceDeclaration\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body,\n  };\n  const defs = NODE_FIELDS.TSInterfaceDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function tsInterfaceBody(body: t.TSTypeElement[]): t.TSInterfaceBody {\n  const node: t.TSInterfaceBody = {\n    type: \"TSInterfaceBody\",\n    body,\n  };\n  const defs = NODE_FIELDS.TSInterfaceBody;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function tsTypeAliasDeclaration(\n  id: t.Identifier,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  typeAnnotation: t.TSType,\n): t.TSTypeAliasDeclaration {\n  const node: t.TSTypeAliasDeclaration = {\n    type: \"TSTypeAliasDeclaration\",\n    id,\n    typeParameters,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSTypeAliasDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function tsInstantiationExpression(\n  expression: t.Expression,\n  typeArguments: t.TSTypeParameterInstantiation | null = null,\n): t.TSInstantiationExpression {\n  const node: t.TSInstantiationExpression = {\n    type: \"TSInstantiationExpression\",\n    expression,\n    typeArguments,\n  };\n  const defs = NODE_FIELDS.TSInstantiationExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeArguments, node, \"typeArguments\", typeArguments, 1);\n  return node;\n}\nexport function tsAsExpression(\n  expression: t.Expression,\n  typeAnnotation: t.TSType,\n): t.TSAsExpression {\n  const node: t.TSAsExpression = {\n    type: \"TSAsExpression\",\n    expression,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSAsExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function tsSatisfiesExpression(\n  expression: t.Expression,\n  typeAnnotation: t.TSType,\n): t.TSSatisfiesExpression {\n  const node: t.TSSatisfiesExpression = {\n    type: \"TSSatisfiesExpression\",\n    expression,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSSatisfiesExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function tsTypeAssertion(\n  typeAnnotation: t.TSType,\n  expression: t.Expression,\n): t.TSTypeAssertion {\n  const node: t.TSTypeAssertion = {\n    type: \"TSTypeAssertion\",\n    typeAnnotation,\n    expression,\n  };\n  const defs = NODE_FIELDS.TSTypeAssertion;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function tsEnumBody(members: t.TSEnumMember[]): t.TSEnumBody {\n  const node: t.TSEnumBody = {\n    type: \"TSEnumBody\",\n    members,\n  };\n  const defs = NODE_FIELDS.TSEnumBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nexport function tsEnumDeclaration(\n  id: t.Identifier,\n  body: t.TSEnumBody,\n): t.TSEnumDeclaration {\n  const node: t.TSEnumDeclaration = {\n    type: \"TSEnumDeclaration\",\n    id,\n    body,\n  };\n  const defs = NODE_FIELDS.TSEnumDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function tsEnumMember(\n  id: t.Identifier | t.StringLiteral,\n  initializer: t.Expression | null = null,\n): t.TSEnumMember {\n  const node: t.TSEnumMember = {\n    type: \"TSEnumMember\",\n    id,\n    initializer,\n  };\n  const defs = NODE_FIELDS.TSEnumMember;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.initializer, node, \"initializer\", initializer, 1);\n  return node;\n}\nexport function tsModuleDeclaration(\n  id: t.TSEntityName | t.StringLiteral,\n  body: t.TSModuleBlock,\n): t.TSModuleDeclaration {\n  const node: t.TSModuleDeclaration = {\n    type: \"TSModuleDeclaration\",\n    id,\n    body,\n    kind: \"namespace\",\n  };\n  const defs = NODE_FIELDS.TSModuleDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function tsModuleBlock(body: t.Statement[]): t.TSModuleBlock {\n  const node: t.TSModuleBlock = {\n    type: \"TSModuleBlock\",\n    body,\n  };\n  const defs = NODE_FIELDS.TSModuleBlock;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function tsImportType(\n  source: t.StringLiteral,\n  qualifier: t.TSEntityName | null = null,\n  typeArguments: t.TSTypeParameterInstantiation | null = null,\n): t.TSImportType {\n  const node: t.TSImportType = {\n    type: \"TSImportType\",\n    source,\n    qualifier,\n    typeArguments,\n  };\n  const defs = NODE_FIELDS.TSImportType;\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.qualifier, node, \"qualifier\", qualifier, 1);\n  validate(defs.typeArguments, node, \"typeArguments\", typeArguments, 1);\n  return node;\n}\nexport function tsImportEqualsDeclaration(\n  id: t.Identifier,\n  moduleReference: t.TSEntityName | t.TSExternalModuleReference,\n): t.TSImportEqualsDeclaration {\n  const node: t.TSImportEqualsDeclaration = {\n    type: \"TSImportEqualsDeclaration\",\n    id,\n    moduleReference,\n  };\n  const defs = NODE_FIELDS.TSImportEqualsDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.moduleReference, node, \"moduleReference\", moduleReference, 1);\n  return node;\n}\nexport function tsExternalModuleReference(\n  expression: t.StringLiteral,\n): t.TSExternalModuleReference {\n  const node: t.TSExternalModuleReference = {\n    type: \"TSExternalModuleReference\",\n    expression,\n  };\n  const defs = NODE_FIELDS.TSExternalModuleReference;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function tsNonNullExpression(\n  expression: t.Expression,\n): t.TSNonNullExpression {\n  const node: t.TSNonNullExpression = {\n    type: \"TSNonNullExpression\",\n    expression,\n  };\n  const defs = NODE_FIELDS.TSNonNullExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function tsExportAssignment(\n  expression: t.Expression,\n): t.TSExportAssignment {\n  const node: t.TSExportAssignment = {\n    type: \"TSExportAssignment\",\n    expression,\n  };\n  const defs = NODE_FIELDS.TSExportAssignment;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function tsNamespaceExportDeclaration(\n  id: t.Identifier,\n): t.TSNamespaceExportDeclaration {\n  const node: t.TSNamespaceExportDeclaration = {\n    type: \"TSNamespaceExportDeclaration\",\n    id,\n  };\n  const defs = NODE_FIELDS.TSNamespaceExportDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nexport function tsTypeAnnotation(typeAnnotation: t.TSType): t.TSTypeAnnotation {\n  const node: t.TSTypeAnnotation = {\n    type: \"TSTypeAnnotation\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSTypeAnnotation;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function tsTypeParameterInstantiation(\n  params: t.TSType[],\n): t.TSTypeParameterInstantiation {\n  const node: t.TSTypeParameterInstantiation = {\n    type: \"TSTypeParameterInstantiation\",\n    params,\n  };\n  const defs = NODE_FIELDS.TSTypeParameterInstantiation;\n  validate(defs.params, node, \"params\", params, 1);\n  return node;\n}\nexport function tsTypeParameterDeclaration(\n  params: t.TSTypeParameter[],\n): t.TSTypeParameterDeclaration {\n  const node: t.TSTypeParameterDeclaration = {\n    type: \"TSTypeParameterDeclaration\",\n    params,\n  };\n  const defs = NODE_FIELDS.TSTypeParameterDeclaration;\n  validate(defs.params, node, \"params\", params, 1);\n  return node;\n}\nexport function tsTypeParameter(\n  constraint: t.TSType | null | undefined = null,\n  _default: t.TSType | null | undefined = null,\n  name: t.Identifier,\n): t.TSTypeParameter {\n  const node: t.TSTypeParameter = {\n    type: \"TSTypeParameter\",\n    constraint,\n    default: _default,\n    name,\n  };\n  const defs = NODE_FIELDS.TSTypeParameter;\n  validate(defs.constraint, node, \"constraint\", constraint, 1);\n  validate(defs.default, node, \"default\", _default, 1);\n  validate(defs.name, node, \"name\", name, 1);\n  return node;\n}\n/** @deprecated */\nfunction NumberLiteral(value: number) {\n  deprecationWarning(\"NumberLiteral\", \"NumericLiteral\", \"The node type \");\n  return numericLiteral(value);\n}\nexport { NumberLiteral as numberLiteral };\n/** @deprecated */\nfunction RegexLiteral(pattern: string, flags: string = \"\") {\n  deprecationWarning(\"RegexLiteral\", \"RegExpLiteral\", \"The node type \");\n  return regExpLiteral(pattern, flags);\n}\nexport { RegexLiteral as regexLiteral };\n/** @deprecated */\nfunction RestProperty(\n  argument:\n    | t.Identifier\n    | t.ArrayPattern\n    | t.ObjectPattern\n    | t.MemberExpression\n    | t.TSAsExpression\n    | t.TSSatisfiesExpression\n    | t.TSTypeAssertion\n    | t.TSNonNullExpression,\n) {\n  deprecationWarning(\"RestProperty\", \"RestElement\", \"The node type \");\n  return restElement(argument);\n}\nexport { RestProperty as restProperty };\n/** @deprecated */\nfunction SpreadProperty(argument: t.Expression) {\n  deprecationWarning(\"SpreadProperty\", \"SpreadElement\", \"The node type \");\n  return spreadElement(argument);\n}\nexport { SpreadProperty as spreadProperty };\n","/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\n\nimport * as b from \"./lowercase.ts\";\nimport deprecationWarning from \"../../utils/deprecationWarning.ts\";\n\nfunction alias<const N extends keyof typeof b>(lowercase: N): (typeof b)[N] {\n  return function () {\n    deprecationWarning(\n      lowercase.replace(/^(?:ts|jsx|[a-z])/, x => x.toUpperCase()),\n      lowercase,\n      \"Usage of builders starting with an uppercase letter such as \",\n      \"uppercase builders\",\n    );\n    return (b[lowercase] as any)(...arguments);\n  } as any;\n}\n\nexport const ArrayExpression = alias(\"arrayExpression\"),\n  AssignmentExpression = alias(\"assignmentExpression\"),\n  BinaryExpression = alias(\"binaryExpression\"),\n  InterpreterDirective = alias(\"interpreterDirective\"),\n  Directive = alias(\"directive\"),\n  DirectiveLiteral = alias(\"directiveLiteral\"),\n  BlockStatement = alias(\"blockStatement\"),\n  BreakStatement = alias(\"breakStatement\"),\n  CallExpression = alias(\"callExpression\"),\n  CatchClause = alias(\"catchClause\"),\n  ConditionalExpression = alias(\"conditionalExpression\"),\n  ContinueStatement = alias(\"continueStatement\"),\n  DebuggerStatement = alias(\"debuggerStatement\"),\n  DoWhileStatement = alias(\"doWhileStatement\"),\n  EmptyStatement = alias(\"emptyStatement\"),\n  ExpressionStatement = alias(\"expressionStatement\"),\n  File = alias(\"file\"),\n  ForInStatement = alias(\"forInStatement\"),\n  ForStatement = alias(\"forStatement\"),\n  FunctionDeclaration = alias(\"functionDeclaration\"),\n  FunctionExpression = alias(\"functionExpression\"),\n  Identifier = alias(\"identifier\"),\n  IfStatement = alias(\"ifStatement\"),\n  LabeledStatement = alias(\"labeledStatement\"),\n  StringLiteral = alias(\"stringLiteral\"),\n  NumericLiteral = alias(\"numericLiteral\"),\n  NullLiteral = alias(\"nullLiteral\"),\n  BooleanLiteral = alias(\"booleanLiteral\"),\n  RegExpLiteral = alias(\"regExpLiteral\"),\n  LogicalExpression = alias(\"logicalExpression\"),\n  MemberExpression = alias(\"memberExpression\"),\n  NewExpression = alias(\"newExpression\"),\n  Program = alias(\"program\"),\n  ObjectExpression = alias(\"objectExpression\"),\n  ObjectMethod = alias(\"objectMethod\"),\n  ObjectProperty = alias(\"objectProperty\"),\n  RestElement = alias(\"restElement\"),\n  ReturnStatement = alias(\"returnStatement\"),\n  SequenceExpression = alias(\"sequenceExpression\"),\n  ParenthesizedExpression = alias(\"parenthesizedExpression\"),\n  SwitchCase = alias(\"switchCase\"),\n  SwitchStatement = alias(\"switchStatement\"),\n  ThisExpression = alias(\"thisExpression\"),\n  ThrowStatement = alias(\"throwStatement\"),\n  TryStatement = alias(\"tryStatement\"),\n  UnaryExpression = alias(\"unaryExpression\"),\n  UpdateExpression = alias(\"updateExpression\"),\n  VariableDeclaration = alias(\"variableDeclaration\"),\n  VariableDeclarator = alias(\"variableDeclarator\"),\n  WhileStatement = alias(\"whileStatement\"),\n  WithStatement = alias(\"withStatement\"),\n  AssignmentPattern = alias(\"assignmentPattern\"),\n  ArrayPattern = alias(\"arrayPattern\"),\n  ArrowFunctionExpression = alias(\"arrowFunctionExpression\"),\n  ClassBody = alias(\"classBody\"),\n  ClassExpression = alias(\"classExpression\"),\n  ClassDeclaration = alias(\"classDeclaration\"),\n  ExportAllDeclaration = alias(\"exportAllDeclaration\"),\n  ExportDefaultDeclaration = alias(\"exportDefaultDeclaration\"),\n  ExportNamedDeclaration = alias(\"exportNamedDeclaration\"),\n  ExportSpecifier = alias(\"exportSpecifier\"),\n  ForOfStatement = alias(\"forOfStatement\"),\n  ImportDeclaration = alias(\"importDeclaration\"),\n  ImportDefaultSpecifier = alias(\"importDefaultSpecifier\"),\n  ImportNamespaceSpecifier = alias(\"importNamespaceSpecifier\"),\n  ImportSpecifier = alias(\"importSpecifier\"),\n  ImportExpression = alias(\"importExpression\"),\n  MetaProperty = alias(\"metaProperty\"),\n  ClassMethod = alias(\"classMethod\"),\n  ObjectPattern = alias(\"objectPattern\"),\n  SpreadElement = alias(\"spreadElement\"),\n  Super = alias(\"super\"),\n  TaggedTemplateExpression = alias(\"taggedTemplateExpression\"),\n  TemplateElement = alias(\"templateElement\"),\n  TemplateLiteral = alias(\"templateLiteral\"),\n  YieldExpression = alias(\"yieldExpression\"),\n  AwaitExpression = alias(\"awaitExpression\"),\n  Import = alias(\"import\"),\n  BigIntLiteral = alias(\"bigIntLiteral\"),\n  ExportNamespaceSpecifier = alias(\"exportNamespaceSpecifier\"),\n  OptionalMemberExpression = alias(\"optionalMemberExpression\"),\n  OptionalCallExpression = alias(\"optionalCallExpression\"),\n  ClassProperty = alias(\"classProperty\"),\n  ClassPrivateProperty = alias(\"classPrivateProperty\"),\n  ClassPrivateMethod = alias(\"classPrivateMethod\"),\n  PrivateName = alias(\"privateName\"),\n  StaticBlock = alias(\"staticBlock\"),\n  ImportAttribute = alias(\"importAttribute\"),\n  AnyTypeAnnotation = alias(\"anyTypeAnnotation\"),\n  ArrayTypeAnnotation = alias(\"arrayTypeAnnotation\"),\n  BooleanTypeAnnotation = alias(\"booleanTypeAnnotation\"),\n  BooleanLiteralTypeAnnotation = alias(\"booleanLiteralTypeAnnotation\"),\n  NullLiteralTypeAnnotation = alias(\"nullLiteralTypeAnnotation\"),\n  ClassImplements = alias(\"classImplements\"),\n  DeclareClass = alias(\"declareClass\"),\n  DeclareFunction = alias(\"declareFunction\"),\n  DeclareInterface = alias(\"declareInterface\"),\n  DeclareModule = alias(\"declareModule\"),\n  DeclareModuleExports = alias(\"declareModuleExports\"),\n  DeclareTypeAlias = alias(\"declareTypeAlias\"),\n  DeclareOpaqueType = alias(\"declareOpaqueType\"),\n  DeclareVariable = alias(\"declareVariable\"),\n  DeclareExportDeclaration = alias(\"declareExportDeclaration\"),\n  DeclareExportAllDeclaration = alias(\"declareExportAllDeclaration\"),\n  DeclaredPredicate = alias(\"declaredPredicate\"),\n  ExistsTypeAnnotation = alias(\"existsTypeAnnotation\"),\n  FunctionTypeAnnotation = alias(\"functionTypeAnnotation\"),\n  FunctionTypeParam = alias(\"functionTypeParam\"),\n  GenericTypeAnnotation = alias(\"genericTypeAnnotation\"),\n  InferredPredicate = alias(\"inferredPredicate\"),\n  InterfaceExtends = alias(\"interfaceExtends\"),\n  InterfaceDeclaration = alias(\"interfaceDeclaration\"),\n  InterfaceTypeAnnotation = alias(\"interfaceTypeAnnotation\"),\n  IntersectionTypeAnnotation = alias(\"intersectionTypeAnnotation\"),\n  MixedTypeAnnotation = alias(\"mixedTypeAnnotation\"),\n  EmptyTypeAnnotation = alias(\"emptyTypeAnnotation\"),\n  NullableTypeAnnotation = alias(\"nullableTypeAnnotation\"),\n  NumberLiteralTypeAnnotation = alias(\"numberLiteralTypeAnnotation\"),\n  NumberTypeAnnotation = alias(\"numberTypeAnnotation\"),\n  ObjectTypeAnnotation = alias(\"objectTypeAnnotation\"),\n  ObjectTypeInternalSlot = alias(\"objectTypeInternalSlot\"),\n  ObjectTypeCallProperty = alias(\"objectTypeCallProperty\"),\n  ObjectTypeIndexer = alias(\"objectTypeIndexer\"),\n  ObjectTypeProperty = alias(\"objectTypeProperty\"),\n  ObjectTypeSpreadProperty = alias(\"objectTypeSpreadProperty\"),\n  OpaqueType = alias(\"opaqueType\"),\n  QualifiedTypeIdentifier = alias(\"qualifiedTypeIdentifier\"),\n  StringLiteralTypeAnnotation = alias(\"stringLiteralTypeAnnotation\"),\n  StringTypeAnnotation = alias(\"stringTypeAnnotation\"),\n  SymbolTypeAnnotation = alias(\"symbolTypeAnnotation\"),\n  ThisTypeAnnotation = alias(\"thisTypeAnnotation\"),\n  TupleTypeAnnotation = alias(\"tupleTypeAnnotation\"),\n  TypeofTypeAnnotation = alias(\"typeofTypeAnnotation\"),\n  TypeAlias = alias(\"typeAlias\"),\n  TypeAnnotation = alias(\"typeAnnotation\"),\n  TypeCastExpression = alias(\"typeCastExpression\"),\n  TypeParameter = alias(\"typeParameter\"),\n  TypeParameterDeclaration = alias(\"typeParameterDeclaration\"),\n  TypeParameterInstantiation = alias(\"typeParameterInstantiation\"),\n  UnionTypeAnnotation = alias(\"unionTypeAnnotation\"),\n  Variance = alias(\"variance\"),\n  VoidTypeAnnotation = alias(\"voidTypeAnnotation\"),\n  EnumDeclaration = alias(\"enumDeclaration\"),\n  EnumBooleanBody = alias(\"enumBooleanBody\"),\n  EnumNumberBody = alias(\"enumNumberBody\"),\n  EnumStringBody = alias(\"enumStringBody\"),\n  EnumSymbolBody = alias(\"enumSymbolBody\"),\n  EnumBooleanMember = alias(\"enumBooleanMember\"),\n  EnumNumberMember = alias(\"enumNumberMember\"),\n  EnumStringMember = alias(\"enumStringMember\"),\n  EnumDefaultedMember = alias(\"enumDefaultedMember\"),\n  IndexedAccessType = alias(\"indexedAccessType\"),\n  OptionalIndexedAccessType = alias(\"optionalIndexedAccessType\"),\n  JSXAttribute = alias(\"jsxAttribute\"),\n  JSXClosingElement = alias(\"jsxClosingElement\"),\n  JSXElement = alias(\"jsxElement\"),\n  JSXEmptyExpression = alias(\"jsxEmptyExpression\"),\n  JSXExpressionContainer = alias(\"jsxExpressionContainer\"),\n  JSXSpreadChild = alias(\"jsxSpreadChild\"),\n  JSXIdentifier = alias(\"jsxIdentifier\"),\n  JSXMemberExpression = alias(\"jsxMemberExpression\"),\n  JSXNamespacedName = alias(\"jsxNamespacedName\"),\n  JSXOpeningElement = alias(\"jsxOpeningElement\"),\n  JSXSpreadAttribute = alias(\"jsxSpreadAttribute\"),\n  JSXText = alias(\"jsxText\"),\n  JSXFragment = alias(\"jsxFragment\"),\n  JSXOpeningFragment = alias(\"jsxOpeningFragment\"),\n  JSXClosingFragment = alias(\"jsxClosingFragment\"),\n  Placeholder = alias(\"placeholder\"),\n  V8IntrinsicIdentifier = alias(\"v8IntrinsicIdentifier\"),\n  ArgumentPlaceholder = alias(\"argumentPlaceholder\"),\n  BindExpression = alias(\"bindExpression\"),\n  ClassAccessorProperty = alias(\"classAccessorProperty\"),\n  Decorator = alias(\"decorator\"),\n  DoExpression = alias(\"doExpression\"),\n  ExportDefaultSpecifier = alias(\"exportDefaultSpecifier\"),\n  ModuleExpression = alias(\"moduleExpression\"),\n  TopicReference = alias(\"topicReference\"),\n  VoidPattern = alias(\"voidPattern\"),\n  TSParameterProperty = alias(\"tsParameterProperty\"),\n  TSDeclareFunction = alias(\"tsDeclareFunction\"),\n  TSDeclareMethod = alias(\"tsDeclareMethod\"),\n  TSQualifiedName = alias(\"tsQualifiedName\"),\n  TSCallSignatureDeclaration = alias(\"tsCallSignatureDeclaration\"),\n  TSConstructSignatureDeclaration = alias(\"tsConstructSignatureDeclaration\"),\n  TSPropertySignature = alias(\"tsPropertySignature\"),\n  TSMethodSignature = alias(\"tsMethodSignature\"),\n  TSIndexSignature = alias(\"tsIndexSignature\"),\n  TSAnyKeyword = alias(\"tsAnyKeyword\"),\n  TSBooleanKeyword = alias(\"tsBooleanKeyword\"),\n  TSBigIntKeyword = alias(\"tsBigIntKeyword\"),\n  TSIntrinsicKeyword = alias(\"tsIntrinsicKeyword\"),\n  TSNeverKeyword = alias(\"tsNeverKeyword\"),\n  TSNullKeyword = alias(\"tsNullKeyword\"),\n  TSNumberKeyword = alias(\"tsNumberKeyword\"),\n  TSObjectKeyword = alias(\"tsObjectKeyword\"),\n  TSStringKeyword = alias(\"tsStringKeyword\"),\n  TSSymbolKeyword = alias(\"tsSymbolKeyword\"),\n  TSUndefinedKeyword = alias(\"tsUndefinedKeyword\"),\n  TSUnknownKeyword = alias(\"tsUnknownKeyword\"),\n  TSVoidKeyword = alias(\"tsVoidKeyword\"),\n  TSThisType = alias(\"tsThisType\"),\n  TSFunctionType = alias(\"tsFunctionType\"),\n  TSConstructorType = alias(\"tsConstructorType\"),\n  TSTypeReference = alias(\"tsTypeReference\"),\n  TSTypePredicate = alias(\"tsTypePredicate\"),\n  TSTypeQuery = alias(\"tsTypeQuery\"),\n  TSTypeLiteral = alias(\"tsTypeLiteral\"),\n  TSArrayType = alias(\"tsArrayType\"),\n  TSTupleType = alias(\"tsTupleType\"),\n  TSOptionalType = alias(\"tsOptionalType\"),\n  TSRestType = alias(\"tsRestType\"),\n  TSNamedTupleMember = alias(\"tsNamedTupleMember\"),\n  TSUnionType = alias(\"tsUnionType\"),\n  TSIntersectionType = alias(\"tsIntersectionType\"),\n  TSConditionalType = alias(\"tsConditionalType\"),\n  TSInferType = alias(\"tsInferType\"),\n  TSParenthesizedType = alias(\"tsParenthesizedType\"),\n  TSTypeOperator = alias(\"tsTypeOperator\"),\n  TSIndexedAccessType = alias(\"tsIndexedAccessType\"),\n  TSMappedType = alias(\"tsMappedType\"),\n  TSTemplateLiteralType = alias(\"tsTemplateLiteralType\"),\n  TSLiteralType = alias(\"tsLiteralType\"),\n  TSClassImplements = alias(\"tsClassImplements\"),\n  TSInterfaceHeritage = alias(\"tsInterfaceHeritage\"),\n  TSInterfaceDeclaration = alias(\"tsInterfaceDeclaration\"),\n  TSInterfaceBody = alias(\"tsInterfaceBody\"),\n  TSTypeAliasDeclaration = alias(\"tsTypeAliasDeclaration\"),\n  TSInstantiationExpression = alias(\"tsInstantiationExpression\"),\n  TSAsExpression = alias(\"tsAsExpression\"),\n  TSSatisfiesExpression = alias(\"tsSatisfiesExpression\"),\n  TSTypeAssertion = alias(\"tsTypeAssertion\"),\n  TSEnumBody = alias(\"tsEnumBody\"),\n  TSEnumDeclaration = alias(\"tsEnumDeclaration\"),\n  TSEnumMember = alias(\"tsEnumMember\"),\n  TSModuleDeclaration = alias(\"tsModuleDeclaration\"),\n  TSModuleBlock = alias(\"tsModuleBlock\"),\n  TSImportType = alias(\"tsImportType\"),\n  TSImportEqualsDeclaration = alias(\"tsImportEqualsDeclaration\"),\n  TSExternalModuleReference = alias(\"tsExternalModuleReference\"),\n  TSNonNullExpression = alias(\"tsNonNullExpression\"),\n  TSExportAssignment = alias(\"tsExportAssignment\"),\n  TSNamespaceExportDeclaration = alias(\"tsNamespaceExportDeclaration\"),\n  TSTypeAnnotation = alias(\"tsTypeAnnotation\"),\n  TSTypeParameterInstantiation = alias(\"tsTypeParameterInstantiation\"),\n  TSTypeParameterDeclaration = alias(\"tsTypeParameterDeclaration\"),\n  TSTypeParameter = alias(\"tsTypeParameter\");\n","import { stringLiteral } from \"../../builders/generated/index.ts\";\nimport type * as t from \"../../index.ts\";\nimport { inherits } from \"../../index.ts\";\n\nexport default function cleanJSXElementLiteralChild(\n  child: t.JSXText,\n  args: t.Node[],\n) {\n  const lines = child.value.split(/\\r\\n|\\n|\\r/);\n\n  let lastNonEmptyLine = 0;\n\n  for (let i = 0; i < lines.length; i++) {\n    if (/[^ \\t]/.exec(lines[i])) {\n      lastNonEmptyLine = i;\n    }\n  }\n\n  let str = \"\";\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n\n    const isFirstLine = i === 0;\n    const isLastLine = i === lines.length - 1;\n    const isLastNonEmptyLine = i === lastNonEmptyLine;\n\n    // replace rendered whitespace tabs with spaces\n    let trimmedLine = line.replace(/\\t/g, \" \");\n\n    // trim whitespace touching a newline\n    if (!isFirstLine) {\n      trimmedLine = trimmedLine.replace(/^ +/, \"\");\n    }\n\n    // trim whitespace touching an endline\n    if (!isLastLine) {\n      trimmedLine = trimmedLine.replace(/ +$/, \"\");\n    }\n\n    if (trimmedLine) {\n      if (!isLastNonEmptyLine) {\n        trimmedLine += \" \";\n      }\n\n      str += trimmedLine;\n    }\n  }\n\n  if (str) args.push(inherits(stringLiteral(str), child));\n}\n","import {\n  isJSXText,\n  isJSXExpressionContainer,\n  isJSXEmptyExpression,\n} from \"../../validators/generated/index.ts\";\nimport cleanJSXElementLiteralChild from \"../../utils/react/cleanJSXElementLiteralChild.ts\";\nimport type * as t from \"../../index.ts\";\n\ntype ReturnedChild =\n  | t.JSXSpreadChild\n  | t.JSXElement\n  | t.JSXFragment\n  | t.Expression;\n\nexport default function buildChildren(\n  node: t.JSXElement | t.JSXFragment,\n): ReturnedChild[] {\n  const elements = [];\n\n  for (let i = 0; i < node.children.length; i++) {\n    let child: any = node.children[i];\n\n    if (isJSXText(child)) {\n      cleanJSXElementLiteralChild(child, elements);\n      continue;\n    }\n\n    if (isJSXExpressionContainer(child)) child = child.expression;\n    if (isJSXEmptyExpression(child)) continue;\n\n    elements.push(child);\n  }\n\n  return elements;\n}\n","import { VISITOR_KEYS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function isNode(node: any): node is t.Node {\n  return !!(node && VISITOR_KEYS[node.type]);\n}\n","import isNode from \"../validators/isNode.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function assertNode(node?: any): asserts node is t.Node {\n  if (!isNode(node)) {\n    const type = node?.type ?? JSON.stringify(node);\n    throw new TypeError(`Not a valid node of type \"${type}\"`);\n  }\n}\n","/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport is from \"../../validators/is.ts\";\nimport type * as t from \"../../index.ts\";\nimport deprecationWarning from \"../../utils/deprecationWarning.ts\";\n\nfunction assert(type: string, node: any, opts?: any): void {\n  if (!is(type, node, opts)) {\n    throw new Error(\n      `Expected type \"${type}\" with option ${JSON.stringify(opts)}, ` +\n        `but instead got \"${node.type}\".`,\n    );\n  }\n}\n\nexport function assertArrayExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ArrayExpression {\n  assert(\"ArrayExpression\", node, opts);\n}\nexport function assertAssignmentExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.AssignmentExpression {\n  assert(\"AssignmentExpression\", node, opts);\n}\nexport function assertBinaryExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BinaryExpression {\n  assert(\"BinaryExpression\", node, opts);\n}\nexport function assertInterpreterDirective(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.InterpreterDirective {\n  assert(\"InterpreterDirective\", node, opts);\n}\nexport function assertDirective(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Directive {\n  assert(\"Directive\", node, opts);\n}\nexport function assertDirectiveLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DirectiveLiteral {\n  assert(\"DirectiveLiteral\", node, opts);\n}\nexport function assertBlockStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BlockStatement {\n  assert(\"BlockStatement\", node, opts);\n}\nexport function assertBreakStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BreakStatement {\n  assert(\"BreakStatement\", node, opts);\n}\nexport function assertCallExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.CallExpression {\n  assert(\"CallExpression\", node, opts);\n}\nexport function assertCatchClause(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.CatchClause {\n  assert(\"CatchClause\", node, opts);\n}\nexport function assertConditionalExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ConditionalExpression {\n  assert(\"ConditionalExpression\", node, opts);\n}\nexport function assertContinueStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ContinueStatement {\n  assert(\"ContinueStatement\", node, opts);\n}\nexport function assertDebuggerStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DebuggerStatement {\n  assert(\"DebuggerStatement\", node, opts);\n}\nexport function assertDoWhileStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DoWhileStatement {\n  assert(\"DoWhileStatement\", node, opts);\n}\nexport function assertEmptyStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EmptyStatement {\n  assert(\"EmptyStatement\", node, opts);\n}\nexport function assertExpressionStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExpressionStatement {\n  assert(\"ExpressionStatement\", node, opts);\n}\nexport function assertFile(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.File {\n  assert(\"File\", node, opts);\n}\nexport function assertForInStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ForInStatement {\n  assert(\"ForInStatement\", node, opts);\n}\nexport function assertForStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ForStatement {\n  assert(\"ForStatement\", node, opts);\n}\nexport function assertFunctionDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FunctionDeclaration {\n  assert(\"FunctionDeclaration\", node, opts);\n}\nexport function assertFunctionExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FunctionExpression {\n  assert(\"FunctionExpression\", node, opts);\n}\nexport function assertIdentifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Identifier {\n  assert(\"Identifier\", node, opts);\n}\nexport function assertIfStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.IfStatement {\n  assert(\"IfStatement\", node, opts);\n}\nexport function assertLabeledStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.LabeledStatement {\n  assert(\"LabeledStatement\", node, opts);\n}\nexport function assertStringLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.StringLiteral {\n  assert(\"StringLiteral\", node, opts);\n}\nexport function assertNumericLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NumericLiteral {\n  assert(\"NumericLiteral\", node, opts);\n}\nexport function assertNullLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NullLiteral {\n  assert(\"NullLiteral\", node, opts);\n}\nexport function assertBooleanLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BooleanLiteral {\n  assert(\"BooleanLiteral\", node, opts);\n}\nexport function assertRegExpLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.RegExpLiteral {\n  assert(\"RegExpLiteral\", node, opts);\n}\nexport function assertLogicalExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.LogicalExpression {\n  assert(\"LogicalExpression\", node, opts);\n}\nexport function assertMemberExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.MemberExpression {\n  assert(\"MemberExpression\", node, opts);\n}\nexport function assertNewExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NewExpression {\n  assert(\"NewExpression\", node, opts);\n}\nexport function assertProgram(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Program {\n  assert(\"Program\", node, opts);\n}\nexport function assertObjectExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectExpression {\n  assert(\"ObjectExpression\", node, opts);\n}\nexport function assertObjectMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectMethod {\n  assert(\"ObjectMethod\", node, opts);\n}\nexport function assertObjectProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectProperty {\n  assert(\"ObjectProperty\", node, opts);\n}\nexport function assertRestElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.RestElement {\n  assert(\"RestElement\", node, opts);\n}\nexport function assertReturnStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ReturnStatement {\n  assert(\"ReturnStatement\", node, opts);\n}\nexport function assertSequenceExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.SequenceExpression {\n  assert(\"SequenceExpression\", node, opts);\n}\nexport function assertParenthesizedExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ParenthesizedExpression {\n  assert(\"ParenthesizedExpression\", node, opts);\n}\nexport function assertSwitchCase(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.SwitchCase {\n  assert(\"SwitchCase\", node, opts);\n}\nexport function assertSwitchStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.SwitchStatement {\n  assert(\"SwitchStatement\", node, opts);\n}\nexport function assertThisExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ThisExpression {\n  assert(\"ThisExpression\", node, opts);\n}\nexport function assertThrowStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ThrowStatement {\n  assert(\"ThrowStatement\", node, opts);\n}\nexport function assertTryStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TryStatement {\n  assert(\"TryStatement\", node, opts);\n}\nexport function assertUnaryExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.UnaryExpression {\n  assert(\"UnaryExpression\", node, opts);\n}\nexport function assertUpdateExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.UpdateExpression {\n  assert(\"UpdateExpression\", node, opts);\n}\nexport function assertVariableDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.VariableDeclaration {\n  assert(\"VariableDeclaration\", node, opts);\n}\nexport function assertVariableDeclarator(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.VariableDeclarator {\n  assert(\"VariableDeclarator\", node, opts);\n}\nexport function assertWhileStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.WhileStatement {\n  assert(\"WhileStatement\", node, opts);\n}\nexport function assertWithStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.WithStatement {\n  assert(\"WithStatement\", node, opts);\n}\nexport function assertAssignmentPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.AssignmentPattern {\n  assert(\"AssignmentPattern\", node, opts);\n}\nexport function assertArrayPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ArrayPattern {\n  assert(\"ArrayPattern\", node, opts);\n}\nexport function assertArrowFunctionExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ArrowFunctionExpression {\n  assert(\"ArrowFunctionExpression\", node, opts);\n}\nexport function assertClassBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassBody {\n  assert(\"ClassBody\", node, opts);\n}\nexport function assertClassExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassExpression {\n  assert(\"ClassExpression\", node, opts);\n}\nexport function assertClassDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassDeclaration {\n  assert(\"ClassDeclaration\", node, opts);\n}\nexport function assertExportAllDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportAllDeclaration {\n  assert(\"ExportAllDeclaration\", node, opts);\n}\nexport function assertExportDefaultDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportDefaultDeclaration {\n  assert(\"ExportDefaultDeclaration\", node, opts);\n}\nexport function assertExportNamedDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportNamedDeclaration {\n  assert(\"ExportNamedDeclaration\", node, opts);\n}\nexport function assertExportSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportSpecifier {\n  assert(\"ExportSpecifier\", node, opts);\n}\nexport function assertForOfStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ForOfStatement {\n  assert(\"ForOfStatement\", node, opts);\n}\nexport function assertImportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportDeclaration {\n  assert(\"ImportDeclaration\", node, opts);\n}\nexport function assertImportDefaultSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportDefaultSpecifier {\n  assert(\"ImportDefaultSpecifier\", node, opts);\n}\nexport function assertImportNamespaceSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportNamespaceSpecifier {\n  assert(\"ImportNamespaceSpecifier\", node, opts);\n}\nexport function assertImportSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportSpecifier {\n  assert(\"ImportSpecifier\", node, opts);\n}\nexport function assertImportExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportExpression {\n  assert(\"ImportExpression\", node, opts);\n}\nexport function assertMetaProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.MetaProperty {\n  assert(\"MetaProperty\", node, opts);\n}\nexport function assertClassMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassMethod {\n  assert(\"ClassMethod\", node, opts);\n}\nexport function assertObjectPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectPattern {\n  assert(\"ObjectPattern\", node, opts);\n}\nexport function assertSpreadElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.SpreadElement {\n  assert(\"SpreadElement\", node, opts);\n}\nexport function assertSuper(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Super {\n  assert(\"Super\", node, opts);\n}\nexport function assertTaggedTemplateExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TaggedTemplateExpression {\n  assert(\"TaggedTemplateExpression\", node, opts);\n}\nexport function assertTemplateElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TemplateElement {\n  assert(\"TemplateElement\", node, opts);\n}\nexport function assertTemplateLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TemplateLiteral {\n  assert(\"TemplateLiteral\", node, opts);\n}\nexport function assertYieldExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.YieldExpression {\n  assert(\"YieldExpression\", node, opts);\n}\nexport function assertAwaitExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.AwaitExpression {\n  assert(\"AwaitExpression\", node, opts);\n}\nexport function assertImport(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Import {\n  assert(\"Import\", node, opts);\n}\nexport function assertBigIntLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BigIntLiteral {\n  assert(\"BigIntLiteral\", node, opts);\n}\nexport function assertExportNamespaceSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportNamespaceSpecifier {\n  assert(\"ExportNamespaceSpecifier\", node, opts);\n}\nexport function assertOptionalMemberExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.OptionalMemberExpression {\n  assert(\"OptionalMemberExpression\", node, opts);\n}\nexport function assertOptionalCallExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.OptionalCallExpression {\n  assert(\"OptionalCallExpression\", node, opts);\n}\nexport function assertClassProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassProperty {\n  assert(\"ClassProperty\", node, opts);\n}\nexport function assertClassPrivateProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassPrivateProperty {\n  assert(\"ClassPrivateProperty\", node, opts);\n}\nexport function assertClassPrivateMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassPrivateMethod {\n  assert(\"ClassPrivateMethod\", node, opts);\n}\nexport function assertPrivateName(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.PrivateName {\n  assert(\"PrivateName\", node, opts);\n}\nexport function assertStaticBlock(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.StaticBlock {\n  assert(\"StaticBlock\", node, opts);\n}\nexport function assertImportAttribute(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportAttribute {\n  assert(\"ImportAttribute\", node, opts);\n}\nexport function assertAnyTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.AnyTypeAnnotation {\n  assert(\"AnyTypeAnnotation\", node, opts);\n}\nexport function assertArrayTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ArrayTypeAnnotation {\n  assert(\"ArrayTypeAnnotation\", node, opts);\n}\nexport function assertBooleanTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BooleanTypeAnnotation {\n  assert(\"BooleanTypeAnnotation\", node, opts);\n}\nexport function assertBooleanLiteralTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BooleanLiteralTypeAnnotation {\n  assert(\"BooleanLiteralTypeAnnotation\", node, opts);\n}\nexport function assertNullLiteralTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NullLiteralTypeAnnotation {\n  assert(\"NullLiteralTypeAnnotation\", node, opts);\n}\nexport function assertClassImplements(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassImplements {\n  assert(\"ClassImplements\", node, opts);\n}\nexport function assertDeclareClass(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareClass {\n  assert(\"DeclareClass\", node, opts);\n}\nexport function assertDeclareFunction(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareFunction {\n  assert(\"DeclareFunction\", node, opts);\n}\nexport function assertDeclareInterface(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareInterface {\n  assert(\"DeclareInterface\", node, opts);\n}\nexport function assertDeclareModule(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareModule {\n  assert(\"DeclareModule\", node, opts);\n}\nexport function assertDeclareModuleExports(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareModuleExports {\n  assert(\"DeclareModuleExports\", node, opts);\n}\nexport function assertDeclareTypeAlias(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareTypeAlias {\n  assert(\"DeclareTypeAlias\", node, opts);\n}\nexport function assertDeclareOpaqueType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareOpaqueType {\n  assert(\"DeclareOpaqueType\", node, opts);\n}\nexport function assertDeclareVariable(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareVariable {\n  assert(\"DeclareVariable\", node, opts);\n}\nexport function assertDeclareExportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareExportDeclaration {\n  assert(\"DeclareExportDeclaration\", node, opts);\n}\nexport function assertDeclareExportAllDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareExportAllDeclaration {\n  assert(\"DeclareExportAllDeclaration\", node, opts);\n}\nexport function assertDeclaredPredicate(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclaredPredicate {\n  assert(\"DeclaredPredicate\", node, opts);\n}\nexport function assertExistsTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExistsTypeAnnotation {\n  assert(\"ExistsTypeAnnotation\", node, opts);\n}\nexport function assertFunctionTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FunctionTypeAnnotation {\n  assert(\"FunctionTypeAnnotation\", node, opts);\n}\nexport function assertFunctionTypeParam(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FunctionTypeParam {\n  assert(\"FunctionTypeParam\", node, opts);\n}\nexport function assertGenericTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.GenericTypeAnnotation {\n  assert(\"GenericTypeAnnotation\", node, opts);\n}\nexport function assertInferredPredicate(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.InferredPredicate {\n  assert(\"InferredPredicate\", node, opts);\n}\nexport function assertInterfaceExtends(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.InterfaceExtends {\n  assert(\"InterfaceExtends\", node, opts);\n}\nexport function assertInterfaceDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.InterfaceDeclaration {\n  assert(\"InterfaceDeclaration\", node, opts);\n}\nexport function assertInterfaceTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.InterfaceTypeAnnotation {\n  assert(\"InterfaceTypeAnnotation\", node, opts);\n}\nexport function assertIntersectionTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.IntersectionTypeAnnotation {\n  assert(\"IntersectionTypeAnnotation\", node, opts);\n}\nexport function assertMixedTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.MixedTypeAnnotation {\n  assert(\"MixedTypeAnnotation\", node, opts);\n}\nexport function assertEmptyTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EmptyTypeAnnotation {\n  assert(\"EmptyTypeAnnotation\", node, opts);\n}\nexport function assertNullableTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NullableTypeAnnotation {\n  assert(\"NullableTypeAnnotation\", node, opts);\n}\nexport function assertNumberLiteralTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NumberLiteralTypeAnnotation {\n  assert(\"NumberLiteralTypeAnnotation\", node, opts);\n}\nexport function assertNumberTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NumberTypeAnnotation {\n  assert(\"NumberTypeAnnotation\", node, opts);\n}\nexport function assertObjectTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectTypeAnnotation {\n  assert(\"ObjectTypeAnnotation\", node, opts);\n}\nexport function assertObjectTypeInternalSlot(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectTypeInternalSlot {\n  assert(\"ObjectTypeInternalSlot\", node, opts);\n}\nexport function assertObjectTypeCallProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectTypeCallProperty {\n  assert(\"ObjectTypeCallProperty\", node, opts);\n}\nexport function assertObjectTypeIndexer(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectTypeIndexer {\n  assert(\"ObjectTypeIndexer\", node, opts);\n}\nexport function assertObjectTypeProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectTypeProperty {\n  assert(\"ObjectTypeProperty\", node, opts);\n}\nexport function assertObjectTypeSpreadProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectTypeSpreadProperty {\n  assert(\"ObjectTypeSpreadProperty\", node, opts);\n}\nexport function assertOpaqueType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.OpaqueType {\n  assert(\"OpaqueType\", node, opts);\n}\nexport function assertQualifiedTypeIdentifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.QualifiedTypeIdentifier {\n  assert(\"QualifiedTypeIdentifier\", node, opts);\n}\nexport function assertStringLiteralTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.StringLiteralTypeAnnotation {\n  assert(\"StringLiteralTypeAnnotation\", node, opts);\n}\nexport function assertStringTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.StringTypeAnnotation {\n  assert(\"StringTypeAnnotation\", node, opts);\n}\nexport function assertSymbolTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.SymbolTypeAnnotation {\n  assert(\"SymbolTypeAnnotation\", node, opts);\n}\nexport function assertThisTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ThisTypeAnnotation {\n  assert(\"ThisTypeAnnotation\", node, opts);\n}\nexport function assertTupleTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TupleTypeAnnotation {\n  assert(\"TupleTypeAnnotation\", node, opts);\n}\nexport function assertTypeofTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeofTypeAnnotation {\n  assert(\"TypeofTypeAnnotation\", node, opts);\n}\nexport function assertTypeAlias(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeAlias {\n  assert(\"TypeAlias\", node, opts);\n}\nexport function assertTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeAnnotation {\n  assert(\"TypeAnnotation\", node, opts);\n}\nexport function assertTypeCastExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeCastExpression {\n  assert(\"TypeCastExpression\", node, opts);\n}\nexport function assertTypeParameter(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeParameter {\n  assert(\"TypeParameter\", node, opts);\n}\nexport function assertTypeParameterDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeParameterDeclaration {\n  assert(\"TypeParameterDeclaration\", node, opts);\n}\nexport function assertTypeParameterInstantiation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeParameterInstantiation {\n  assert(\"TypeParameterInstantiation\", node, opts);\n}\nexport function assertUnionTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.UnionTypeAnnotation {\n  assert(\"UnionTypeAnnotation\", node, opts);\n}\nexport function assertVariance(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Variance {\n  assert(\"Variance\", node, opts);\n}\nexport function assertVoidTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.VoidTypeAnnotation {\n  assert(\"VoidTypeAnnotation\", node, opts);\n}\nexport function assertEnumDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumDeclaration {\n  assert(\"EnumDeclaration\", node, opts);\n}\nexport function assertEnumBooleanBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumBooleanBody {\n  assert(\"EnumBooleanBody\", node, opts);\n}\nexport function assertEnumNumberBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumNumberBody {\n  assert(\"EnumNumberBody\", node, opts);\n}\nexport function assertEnumStringBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumStringBody {\n  assert(\"EnumStringBody\", node, opts);\n}\nexport function assertEnumSymbolBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumSymbolBody {\n  assert(\"EnumSymbolBody\", node, opts);\n}\nexport function assertEnumBooleanMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumBooleanMember {\n  assert(\"EnumBooleanMember\", node, opts);\n}\nexport function assertEnumNumberMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumNumberMember {\n  assert(\"EnumNumberMember\", node, opts);\n}\nexport function assertEnumStringMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumStringMember {\n  assert(\"EnumStringMember\", node, opts);\n}\nexport function assertEnumDefaultedMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumDefaultedMember {\n  assert(\"EnumDefaultedMember\", node, opts);\n}\nexport function assertIndexedAccessType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.IndexedAccessType {\n  assert(\"IndexedAccessType\", node, opts);\n}\nexport function assertOptionalIndexedAccessType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.OptionalIndexedAccessType {\n  assert(\"OptionalIndexedAccessType\", node, opts);\n}\nexport function assertJSXAttribute(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXAttribute {\n  assert(\"JSXAttribute\", node, opts);\n}\nexport function assertJSXClosingElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXClosingElement {\n  assert(\"JSXClosingElement\", node, opts);\n}\nexport function assertJSXElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXElement {\n  assert(\"JSXElement\", node, opts);\n}\nexport function assertJSXEmptyExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXEmptyExpression {\n  assert(\"JSXEmptyExpression\", node, opts);\n}\nexport function assertJSXExpressionContainer(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXExpressionContainer {\n  assert(\"JSXExpressionContainer\", node, opts);\n}\nexport function assertJSXSpreadChild(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXSpreadChild {\n  assert(\"JSXSpreadChild\", node, opts);\n}\nexport function assertJSXIdentifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXIdentifier {\n  assert(\"JSXIdentifier\", node, opts);\n}\nexport function assertJSXMemberExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXMemberExpression {\n  assert(\"JSXMemberExpression\", node, opts);\n}\nexport function assertJSXNamespacedName(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXNamespacedName {\n  assert(\"JSXNamespacedName\", node, opts);\n}\nexport function assertJSXOpeningElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXOpeningElement {\n  assert(\"JSXOpeningElement\", node, opts);\n}\nexport function assertJSXSpreadAttribute(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXSpreadAttribute {\n  assert(\"JSXSpreadAttribute\", node, opts);\n}\nexport function assertJSXText(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXText {\n  assert(\"JSXText\", node, opts);\n}\nexport function assertJSXFragment(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXFragment {\n  assert(\"JSXFragment\", node, opts);\n}\nexport function assertJSXOpeningFragment(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXOpeningFragment {\n  assert(\"JSXOpeningFragment\", node, opts);\n}\nexport function assertJSXClosingFragment(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXClosingFragment {\n  assert(\"JSXClosingFragment\", node, opts);\n}\nexport function assertPlaceholder(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Placeholder {\n  assert(\"Placeholder\", node, opts);\n}\nexport function assertV8IntrinsicIdentifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.V8IntrinsicIdentifier {\n  assert(\"V8IntrinsicIdentifier\", node, opts);\n}\nexport function assertArgumentPlaceholder(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ArgumentPlaceholder {\n  assert(\"ArgumentPlaceholder\", node, opts);\n}\nexport function assertBindExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BindExpression {\n  assert(\"BindExpression\", node, opts);\n}\nexport function assertClassAccessorProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassAccessorProperty {\n  assert(\"ClassAccessorProperty\", node, opts);\n}\nexport function assertDecorator(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Decorator {\n  assert(\"Decorator\", node, opts);\n}\nexport function assertDoExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DoExpression {\n  assert(\"DoExpression\", node, opts);\n}\nexport function assertExportDefaultSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportDefaultSpecifier {\n  assert(\"ExportDefaultSpecifier\", node, opts);\n}\nexport function assertModuleExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ModuleExpression {\n  assert(\"ModuleExpression\", node, opts);\n}\nexport function assertTopicReference(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TopicReference {\n  assert(\"TopicReference\", node, opts);\n}\nexport function assertVoidPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.VoidPattern {\n  assert(\"VoidPattern\", node, opts);\n}\nexport function assertTSParameterProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSParameterProperty {\n  assert(\"TSParameterProperty\", node, opts);\n}\nexport function assertTSDeclareFunction(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSDeclareFunction {\n  assert(\"TSDeclareFunction\", node, opts);\n}\nexport function assertTSDeclareMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSDeclareMethod {\n  assert(\"TSDeclareMethod\", node, opts);\n}\nexport function assertTSQualifiedName(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSQualifiedName {\n  assert(\"TSQualifiedName\", node, opts);\n}\nexport function assertTSCallSignatureDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSCallSignatureDeclaration {\n  assert(\"TSCallSignatureDeclaration\", node, opts);\n}\nexport function assertTSConstructSignatureDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSConstructSignatureDeclaration {\n  assert(\"TSConstructSignatureDeclaration\", node, opts);\n}\nexport function assertTSPropertySignature(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSPropertySignature {\n  assert(\"TSPropertySignature\", node, opts);\n}\nexport function assertTSMethodSignature(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSMethodSignature {\n  assert(\"TSMethodSignature\", node, opts);\n}\nexport function assertTSIndexSignature(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSIndexSignature {\n  assert(\"TSIndexSignature\", node, opts);\n}\nexport function assertTSAnyKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSAnyKeyword {\n  assert(\"TSAnyKeyword\", node, opts);\n}\nexport function assertTSBooleanKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSBooleanKeyword {\n  assert(\"TSBooleanKeyword\", node, opts);\n}\nexport function assertTSBigIntKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSBigIntKeyword {\n  assert(\"TSBigIntKeyword\", node, opts);\n}\nexport function assertTSIntrinsicKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSIntrinsicKeyword {\n  assert(\"TSIntrinsicKeyword\", node, opts);\n}\nexport function assertTSNeverKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSNeverKeyword {\n  assert(\"TSNeverKeyword\", node, opts);\n}\nexport function assertTSNullKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSNullKeyword {\n  assert(\"TSNullKeyword\", node, opts);\n}\nexport function assertTSNumberKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSNumberKeyword {\n  assert(\"TSNumberKeyword\", node, opts);\n}\nexport function assertTSObjectKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSObjectKeyword {\n  assert(\"TSObjectKeyword\", node, opts);\n}\nexport function assertTSStringKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSStringKeyword {\n  assert(\"TSStringKeyword\", node, opts);\n}\nexport function assertTSSymbolKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSSymbolKeyword {\n  assert(\"TSSymbolKeyword\", node, opts);\n}\nexport function assertTSUndefinedKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSUndefinedKeyword {\n  assert(\"TSUndefinedKeyword\", node, opts);\n}\nexport function assertTSUnknownKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSUnknownKeyword {\n  assert(\"TSUnknownKeyword\", node, opts);\n}\nexport function assertTSVoidKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSVoidKeyword {\n  assert(\"TSVoidKeyword\", node, opts);\n}\nexport function assertTSThisType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSThisType {\n  assert(\"TSThisType\", node, opts);\n}\nexport function assertTSFunctionType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSFunctionType {\n  assert(\"TSFunctionType\", node, opts);\n}\nexport function assertTSConstructorType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSConstructorType {\n  assert(\"TSConstructorType\", node, opts);\n}\nexport function assertTSTypeReference(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeReference {\n  assert(\"TSTypeReference\", node, opts);\n}\nexport function assertTSTypePredicate(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypePredicate {\n  assert(\"TSTypePredicate\", node, opts);\n}\nexport function assertTSTypeQuery(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeQuery {\n  assert(\"TSTypeQuery\", node, opts);\n}\nexport function assertTSTypeLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeLiteral {\n  assert(\"TSTypeLiteral\", node, opts);\n}\nexport function assertTSArrayType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSArrayType {\n  assert(\"TSArrayType\", node, opts);\n}\nexport function assertTSTupleType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTupleType {\n  assert(\"TSTupleType\", node, opts);\n}\nexport function assertTSOptionalType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSOptionalType {\n  assert(\"TSOptionalType\", node, opts);\n}\nexport function assertTSRestType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSRestType {\n  assert(\"TSRestType\", node, opts);\n}\nexport function assertTSNamedTupleMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSNamedTupleMember {\n  assert(\"TSNamedTupleMember\", node, opts);\n}\nexport function assertTSUnionType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSUnionType {\n  assert(\"TSUnionType\", node, opts);\n}\nexport function assertTSIntersectionType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSIntersectionType {\n  assert(\"TSIntersectionType\", node, opts);\n}\nexport function assertTSConditionalType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSConditionalType {\n  assert(\"TSConditionalType\", node, opts);\n}\nexport function assertTSInferType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSInferType {\n  assert(\"TSInferType\", node, opts);\n}\nexport function assertTSParenthesizedType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSParenthesizedType {\n  assert(\"TSParenthesizedType\", node, opts);\n}\nexport function assertTSTypeOperator(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeOperator {\n  assert(\"TSTypeOperator\", node, opts);\n}\nexport function assertTSIndexedAccessType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSIndexedAccessType {\n  assert(\"TSIndexedAccessType\", node, opts);\n}\nexport function assertTSMappedType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSMappedType {\n  assert(\"TSMappedType\", node, opts);\n}\nexport function assertTSTemplateLiteralType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTemplateLiteralType {\n  assert(\"TSTemplateLiteralType\", node, opts);\n}\nexport function assertTSLiteralType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSLiteralType {\n  assert(\"TSLiteralType\", node, opts);\n}\nexport function assertTSClassImplements(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSClassImplements {\n  assert(\"TSClassImplements\", node, opts);\n}\nexport function assertTSInterfaceHeritage(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSInterfaceHeritage {\n  assert(\"TSInterfaceHeritage\", node, opts);\n}\nexport function assertTSInterfaceDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSInterfaceDeclaration {\n  assert(\"TSInterfaceDeclaration\", node, opts);\n}\nexport function assertTSInterfaceBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSInterfaceBody {\n  assert(\"TSInterfaceBody\", node, opts);\n}\nexport function assertTSTypeAliasDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeAliasDeclaration {\n  assert(\"TSTypeAliasDeclaration\", node, opts);\n}\nexport function assertTSInstantiationExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSInstantiationExpression {\n  assert(\"TSInstantiationExpression\", node, opts);\n}\nexport function assertTSAsExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSAsExpression {\n  assert(\"TSAsExpression\", node, opts);\n}\nexport function assertTSSatisfiesExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSSatisfiesExpression {\n  assert(\"TSSatisfiesExpression\", node, opts);\n}\nexport function assertTSTypeAssertion(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeAssertion {\n  assert(\"TSTypeAssertion\", node, opts);\n}\nexport function assertTSEnumBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSEnumBody {\n  assert(\"TSEnumBody\", node, opts);\n}\nexport function assertTSEnumDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSEnumDeclaration {\n  assert(\"TSEnumDeclaration\", node, opts);\n}\nexport function assertTSEnumMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSEnumMember {\n  assert(\"TSEnumMember\", node, opts);\n}\nexport function assertTSModuleDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSModuleDeclaration {\n  assert(\"TSModuleDeclaration\", node, opts);\n}\nexport function assertTSModuleBlock(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSModuleBlock {\n  assert(\"TSModuleBlock\", node, opts);\n}\nexport function assertTSImportType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSImportType {\n  assert(\"TSImportType\", node, opts);\n}\nexport function assertTSImportEqualsDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSImportEqualsDeclaration {\n  assert(\"TSImportEqualsDeclaration\", node, opts);\n}\nexport function assertTSExternalModuleReference(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSExternalModuleReference {\n  assert(\"TSExternalModuleReference\", node, opts);\n}\nexport function assertTSNonNullExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSNonNullExpression {\n  assert(\"TSNonNullExpression\", node, opts);\n}\nexport function assertTSExportAssignment(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSExportAssignment {\n  assert(\"TSExportAssignment\", node, opts);\n}\nexport function assertTSNamespaceExportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSNamespaceExportDeclaration {\n  assert(\"TSNamespaceExportDeclaration\", node, opts);\n}\nexport function assertTSTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeAnnotation {\n  assert(\"TSTypeAnnotation\", node, opts);\n}\nexport function assertTSTypeParameterInstantiation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeParameterInstantiation {\n  assert(\"TSTypeParameterInstantiation\", node, opts);\n}\nexport function assertTSTypeParameterDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeParameterDeclaration {\n  assert(\"TSTypeParameterDeclaration\", node, opts);\n}\nexport function assertTSTypeParameter(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeParameter {\n  assert(\"TSTypeParameter\", node, opts);\n}\nexport function assertStandardized(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Standardized {\n  assert(\"Standardized\", node, opts);\n}\nexport function assertExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Expression {\n  assert(\"Expression\", node, opts);\n}\nexport function assertBinary(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Binary {\n  assert(\"Binary\", node, opts);\n}\nexport function assertScopable(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Scopable {\n  assert(\"Scopable\", node, opts);\n}\nexport function assertBlockParent(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BlockParent {\n  assert(\"BlockParent\", node, opts);\n}\nexport function assertBlock(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Block {\n  assert(\"Block\", node, opts);\n}\nexport function assertStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Statement {\n  assert(\"Statement\", node, opts);\n}\nexport function assertTerminatorless(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Terminatorless {\n  assert(\"Terminatorless\", node, opts);\n}\nexport function assertCompletionStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.CompletionStatement {\n  assert(\"CompletionStatement\", node, opts);\n}\nexport function assertConditional(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Conditional {\n  assert(\"Conditional\", node, opts);\n}\nexport function assertLoop(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Loop {\n  assert(\"Loop\", node, opts);\n}\nexport function assertWhile(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.While {\n  assert(\"While\", node, opts);\n}\nexport function assertExpressionWrapper(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExpressionWrapper {\n  assert(\"ExpressionWrapper\", node, opts);\n}\nexport function assertFor(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.For {\n  assert(\"For\", node, opts);\n}\nexport function assertForXStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ForXStatement {\n  assert(\"ForXStatement\", node, opts);\n}\nexport function assertFunction(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Function {\n  assert(\"Function\", node, opts);\n}\nexport function assertFunctionParent(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FunctionParent {\n  assert(\"FunctionParent\", node, opts);\n}\nexport function assertPureish(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Pureish {\n  assert(\"Pureish\", node, opts);\n}\nexport function assertDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Declaration {\n  assert(\"Declaration\", node, opts);\n}\nexport function assertFunctionParameter(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FunctionParameter {\n  assert(\"FunctionParameter\", node, opts);\n}\nexport function assertPatternLike(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.PatternLike {\n  assert(\"PatternLike\", node, opts);\n}\nexport function assertLVal(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.LVal {\n  assert(\"LVal\", node, opts);\n}\nexport function assertTSEntityName(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSEntityName {\n  assert(\"TSEntityName\", node, opts);\n}\nexport function assertLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Literal {\n  assert(\"Literal\", node, opts);\n}\nexport function assertImmutable(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Immutable {\n  assert(\"Immutable\", node, opts);\n}\nexport function assertUserWhitespacable(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.UserWhitespacable {\n  assert(\"UserWhitespacable\", node, opts);\n}\nexport function assertMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Method {\n  assert(\"Method\", node, opts);\n}\nexport function assertObjectMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectMember {\n  assert(\"ObjectMember\", node, opts);\n}\nexport function assertProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Property {\n  assert(\"Property\", node, opts);\n}\nexport function assertUnaryLike(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.UnaryLike {\n  assert(\"UnaryLike\", node, opts);\n}\nexport function assertPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Pattern {\n  assert(\"Pattern\", node, opts);\n}\nexport function assertClass(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Class {\n  assert(\"Class\", node, opts);\n}\nexport function assertImportOrExportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportOrExportDeclaration {\n  assert(\"ImportOrExportDeclaration\", node, opts);\n}\nexport function assertExportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportDeclaration {\n  assert(\"ExportDeclaration\", node, opts);\n}\nexport function assertModuleSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ModuleSpecifier {\n  assert(\"ModuleSpecifier\", node, opts);\n}\nexport function assertPrivate(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Private {\n  assert(\"Private\", node, opts);\n}\nexport function assertFlow(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Flow {\n  assert(\"Flow\", node, opts);\n}\nexport function assertFlowType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FlowType {\n  assert(\"FlowType\", node, opts);\n}\nexport function assertFlowBaseAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FlowBaseAnnotation {\n  assert(\"FlowBaseAnnotation\", node, opts);\n}\nexport function assertFlowDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FlowDeclaration {\n  assert(\"FlowDeclaration\", node, opts);\n}\nexport function assertFlowPredicate(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FlowPredicate {\n  assert(\"FlowPredicate\", node, opts);\n}\nexport function assertEnumBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumBody {\n  assert(\"EnumBody\", node, opts);\n}\nexport function assertEnumMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumMember {\n  assert(\"EnumMember\", node, opts);\n}\nexport function assertJSX(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSX {\n  assert(\"JSX\", node, opts);\n}\nexport function assertMiscellaneous(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Miscellaneous {\n  assert(\"Miscellaneous\", node, opts);\n}\nexport function assertAccessor(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Accessor {\n  assert(\"Accessor\", node, opts);\n}\nexport function assertTypeScript(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeScript {\n  assert(\"TypeScript\", node, opts);\n}\nexport function assertTSTypeElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeElement {\n  assert(\"TSTypeElement\", node, opts);\n}\nexport function assertTSType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSType {\n  assert(\"TSType\", node, opts);\n}\nexport function assertTSBaseType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSBaseType {\n  assert(\"TSBaseType\", node, opts);\n}\nexport function assertNumberLiteral(node: any, opts: any): void {\n  deprecationWarning(\"assertNumberLiteral\", \"assertNumericLiteral\");\n  assert(\"NumberLiteral\", node, opts);\n}\nexport function assertRegexLiteral(node: any, opts: any): void {\n  deprecationWarning(\"assertRegexLiteral\", \"assertRegExpLiteral\");\n  assert(\"RegexLiteral\", node, opts);\n}\nexport function assertRestProperty(node: any, opts: any): void {\n  deprecationWarning(\"assertRestProperty\", \"assertRestElement\");\n  assert(\"RestProperty\", node, opts);\n}\nexport function assertSpreadProperty(node: any, opts: any): void {\n  deprecationWarning(\"assertSpreadProperty\", \"assertSpreadElement\");\n  assert(\"SpreadProperty\", node, opts);\n}\nexport function assertModuleDeclaration(node: any, opts: any): void {\n  deprecationWarning(\n    \"assertModuleDeclaration\",\n    \"assertImportOrExportDeclaration\",\n  );\n  assert(\"ModuleDeclaration\", node, opts);\n}\n","import {\n  anyTypeAnnotation,\n  stringTypeAnnotation,\n  numberTypeAnnotation,\n  voidTypeAnnotation,\n  booleanTypeAnnotation,\n  genericTypeAnnotation,\n  identifier,\n} from \"../generated/index.ts\";\nimport type * as t from \"../../index.ts\";\n\nexport default createTypeAnnotationBasedOnTypeof as {\n  (type: \"string\"): t.StringTypeAnnotation;\n  (type: \"number\"): t.NumberTypeAnnotation;\n  (type: \"undefined\"): t.VoidTypeAnnotation;\n  (type: \"boolean\"): t.BooleanTypeAnnotation;\n  (type: \"function\"): t.GenericTypeAnnotation;\n  (type: \"object\"): t.GenericTypeAnnotation;\n  (type: \"symbol\"): t.GenericTypeAnnotation;\n  (type: \"bigint\"): t.AnyTypeAnnotation;\n};\n\n/**\n * Create a type annotation based on typeof expression.\n */\nfunction createTypeAnnotationBasedOnTypeof(type: string): t.FlowType {\n  switch (type) {\n    case \"string\":\n      return stringTypeAnnotation();\n    case \"number\":\n      return numberTypeAnnotation();\n    case \"undefined\":\n      return voidTypeAnnotation();\n    case \"boolean\":\n      return booleanTypeAnnotation();\n    case \"function\":\n      return genericTypeAnnotation(identifier(\"Function\"));\n    case \"object\":\n      return genericTypeAnnotation(identifier(\"Object\"));\n    case \"symbol\":\n      return genericTypeAnnotation(identifier(\"Symbol\"));\n    case \"bigint\":\n      // todo: use BigInt annotation when Flow supports BigInt\n      // https://github.com/facebook/flow/issues/6639\n      return anyTypeAnnotation();\n  }\n  throw new Error(\"Invalid typeof value: \" + type);\n}\n","import {\n  isAnyTypeAnnotation,\n  isGenericTypeAnnotation,\n  isUnionTypeAnnotation,\n  isFlowBaseAnnotation,\n  isIdentifier,\n} from \"../../validators/generated/index.ts\";\nimport type * as t from \"../../index.ts\";\n\nfunction getQualifiedName(node: t.GenericTypeAnnotation[\"id\"]): string {\n  return isIdentifier(node)\n    ? node.name\n    : `${node.id.name}.${getQualifiedName(node.qualification)}`;\n}\n\n/**\n * Dedupe type annotations.\n */\nexport default function removeTypeDuplicates(\n  nodesIn: readonly (t.FlowType | false | null | undefined)[],\n): t.FlowType[] {\n  const nodes = Array.from(nodesIn);\n\n  const generics = new Map<string, t.GenericTypeAnnotation>();\n  const bases = new Map<t.FlowBaseAnnotation[\"type\"], t.FlowBaseAnnotation>();\n\n  // store union type groups to circular references\n  const typeGroups = new Set<t.FlowType[]>();\n\n  const types: t.FlowType[] = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n\n    // detect duplicates\n    if (types.includes(node)) {\n      continue;\n    }\n\n    // this type matches anything\n    if (isAnyTypeAnnotation(node)) {\n      return [node];\n    }\n\n    if (isFlowBaseAnnotation(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n\n    if (isUnionTypeAnnotation(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push(...node.types);\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n\n    // find a matching generic type and merge and deduplicate the type parameters\n    if (isGenericTypeAnnotation(node)) {\n      const name = getQualifiedName(node.id);\n\n      if (generics.has(name)) {\n        let existing: t.Flow = generics.get(name)!;\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params.push(...node.typeParameters.params);\n            existing.typeParameters.params = removeTypeDuplicates(\n              existing.typeParameters.params,\n            );\n          }\n        } else {\n          existing = node.typeParameters!;\n        }\n      } else {\n        generics.set(name, node);\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  // add back in bases\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n\n  // add back in generics\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n\n  return types;\n}\n","import { unionTypeAnnotation } from \"../generated/index.ts\";\nimport removeTypeDuplicates from \"../../modifications/flow/removeTypeDuplicates.ts\";\nimport type * as t from \"../../index.ts\";\n\n/**\n * Takes an array of `types` and flattens them, removing duplicates and\n * returns a `UnionTypeAnnotation` node containing them.\n */\nexport default function createFlowUnionType<T extends t.FlowType>(\n  types: [T] | T[],\n): T | t.UnionTypeAnnotation {\n  const flattened = removeTypeDuplicates(types);\n\n  if (flattened.length === 1) {\n    return flattened[0] as T;\n  } else {\n    return unionTypeAnnotation(flattened);\n  }\n}\n","import {\n  isIdentifier,\n  isThisExpression,\n  isTSAnyKeyword,\n  isTSTypeReference,\n  isTSUnionType,\n  isTSBaseType,\n} from \"../../validators/generated/index.ts\";\nimport type * as t from \"../../index.ts\";\n\nfunction getQualifiedName(node: t.TSTypeReference[\"typeName\"]): string {\n  return isIdentifier(node)\n    ? node.name\n    : isThisExpression(node)\n      ? \"this\"\n      : `${node.right.name}.${getQualifiedName(node.left)}`;\n}\n\n/**\n * Dedupe type annotations.\n */\nexport default function removeTypeDuplicates(\n  nodesIn: readonly t.TSType[],\n): t.TSType[] {\n  const nodes = Array.from(nodesIn);\n\n  const generics = new Map<string, t.TSTypeReference>();\n  const bases = new Map<t.TSBaseType[\"type\"], t.TSBaseType>();\n\n  // store union type groups to circular references\n  const typeGroups = new Set<t.TSType[]>();\n\n  const types: t.TSType[] = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n\n    // detect duplicates\n    if (types.includes(node)) {\n      continue;\n    }\n\n    // this type matches anything\n    if (isTSAnyKeyword(node)) {\n      return [node];\n    }\n\n    // Analogue of FlowBaseAnnotation\n    if (isTSBaseType(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n\n    if (isTSUnionType(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push(...node.types);\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n\n    // todo: support merging tuples: number[]\n    const typeArgumentsKey = \"typeArguments\";\n    if (isTSTypeReference(node) && node[typeArgumentsKey]) {\n      const typeArguments = node[typeArgumentsKey];\n      const name = getQualifiedName(node.typeName);\n\n      if (generics.has(name)) {\n        let existing: t.TypeScript = generics.get(name)!;\n\n        const existingTypeArguments = existing[typeArgumentsKey];\n        if (existingTypeArguments) {\n          existingTypeArguments.params.push(...typeArguments.params);\n          existingTypeArguments.params = removeTypeDuplicates(\n            existingTypeArguments.params,\n          );\n        } else {\n          existing = typeArguments;\n        }\n      } else {\n        generics.set(name, node);\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  // add back in bases\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n\n  // add back in generics\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n\n  return types;\n}\n","import { tsUnionType } from \"../generated/index.ts\";\nimport removeTypeDuplicates from \"../../modifications/typescript/removeTypeDuplicates.ts\";\nimport { isTSTypeAnnotation } from \"../../validators/generated/index.ts\";\nimport type * as t from \"../../index.ts\";\n\n/**\n * Takes an array of `types` and flattens them, removing duplicates and\n * returns a `UnionTypeAnnotation` node containing them.\n */\nexport default function createTSUnionType(\n  typeAnnotations: (t.TSTypeAnnotation | t.TSType)[],\n): t.TSType {\n  const types = typeAnnotations.map(type => {\n    return isTSTypeAnnotation(type) ? type.typeAnnotation : type;\n  });\n  const flattened = removeTypeDuplicates(types);\n\n  if (flattened.length === 1) {\n    return flattened[0];\n  } else {\n    return tsUnionType(flattened);\n  }\n}\n","import { numericLiteral, unaryExpression } from \"./generated/index.ts\";\n\nexport function buildUndefinedNode() {\n  return unaryExpression(\"void\", numericLiteral(0), true);\n}\n","import { NODE_FIELDS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\nimport { isFile, isIdentifier } from \"../validators/generated/index.ts\";\n\nconst { hasOwn } = Object;\ntype CommentCache = Map<t.Comment, t.Comment>;\n\n// This function will never be called for comments, only for real nodes.\nfunction cloneIfNode(\n  obj: t.Node | undefined | null,\n  deep: boolean,\n  withoutLoc: boolean,\n  commentsCache: CommentCache,\n) {\n  if (obj && typeof obj.type === \"string\") {\n    return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);\n  }\n\n  return obj;\n}\n\nfunction cloneIfNodeOrArray(\n  obj: t.Node | undefined | null | (t.Node | undefined | null)[],\n  deep: boolean,\n  withoutLoc: boolean,\n  commentsCache: CommentCache,\n) {\n  if (Array.isArray(obj)) {\n    return obj.map(node => cloneIfNode(node, deep, withoutLoc, commentsCache));\n  }\n  return cloneIfNode(obj, deep, withoutLoc, commentsCache);\n}\n\n/**\n * Create a clone of a `node` including only properties belonging to the node.\n * If the second parameter is `false`, cloneNode performs a shallow clone.\n * If the third parameter is true, the cloned nodes exclude location properties.\n */\nexport default function cloneNode<T extends t.Node>(\n  node: T,\n  deep: boolean = true,\n  withoutLoc: boolean = false,\n): T {\n  return cloneNodeInternal(node, deep, withoutLoc, new Map());\n}\n\nfunction cloneNodeInternal<T extends t.Node>(\n  node: T,\n  deep: boolean = true,\n  withoutLoc: boolean = false,\n  commentsCache: CommentCache,\n): T {\n  if (!node) return node;\n\n  const { type } = node;\n  const newNode: any = { type: node.type };\n\n  // Special-case identifiers since they are the most cloned nodes.\n  if (isIdentifier(node)) {\n    newNode.name = node.name;\n\n    if (hasOwn(node, \"optional\") && typeof node.optional === \"boolean\") {\n      newNode.optional = node.optional;\n    }\n\n    if (hasOwn(node, \"typeAnnotation\")) {\n      newNode.typeAnnotation = deep\n        ? cloneIfNodeOrArray(\n            node.typeAnnotation,\n            true,\n            withoutLoc,\n            commentsCache,\n          )\n        : node.typeAnnotation;\n    }\n\n    if (hasOwn(node, \"decorators\")) {\n      newNode.decorators = deep\n        ? cloneIfNodeOrArray(node.decorators, true, withoutLoc, commentsCache)\n        : node.decorators;\n    }\n  } else if (!hasOwn(NODE_FIELDS, type)) {\n    throw new Error(`Unknown node type: \"${type}\"`);\n  } else {\n    for (const field of Object.keys(NODE_FIELDS[type])) {\n      if (hasOwn(node, field)) {\n        if (deep) {\n          newNode[field] =\n            isFile(node) && field === \"comments\"\n              ? maybeCloneComments(\n                  node.comments,\n                  deep,\n                  withoutLoc,\n                  commentsCache,\n                )\n              : cloneIfNodeOrArray(\n                  // @ts-expect-error node[field] has been guarded by has check\n                  node[field],\n                  true,\n                  withoutLoc,\n                  commentsCache,\n                );\n        } else {\n          newNode[field] =\n            // @ts-expect-error node[field] has been guarded by has check\n            node[field];\n        }\n      }\n    }\n  }\n\n  if (hasOwn(node, \"loc\")) {\n    if (withoutLoc) {\n      newNode.loc = null;\n    } else {\n      newNode.loc = node.loc;\n    }\n  }\n  if (hasOwn(node, \"leadingComments\")) {\n    newNode.leadingComments = maybeCloneComments(\n      node.leadingComments,\n      deep,\n      withoutLoc,\n      commentsCache,\n    );\n  }\n  if (hasOwn(node, \"innerComments\")) {\n    newNode.innerComments = maybeCloneComments(\n      node.innerComments,\n      deep,\n      withoutLoc,\n      commentsCache,\n    );\n  }\n  if (hasOwn(node, \"trailingComments\")) {\n    newNode.trailingComments = maybeCloneComments(\n      node.trailingComments,\n      deep,\n      withoutLoc,\n      commentsCache,\n    );\n  }\n  if (hasOwn(node, \"extra\")) {\n    newNode.extra = {\n      ...node.extra,\n    };\n  }\n\n  return newNode;\n}\n\nfunction maybeCloneComments<T extends t.Comment>(\n  comments: readonly T[] | null | undefined,\n  deep: boolean,\n  withoutLoc: boolean,\n  commentsCache: Map<T, T>,\n): readonly T[] | null | undefined {\n  if (!comments || !deep) {\n    return comments;\n  }\n  return comments.map(comment => {\n    const cache = commentsCache.get(comment);\n    if (cache) return cache;\n\n    const { type, value, loc } = comment;\n\n    const ret = { type, value, loc } as T;\n    if (withoutLoc) {\n      ret.loc = undefined;\n    }\n\n    commentsCache.set(comment, ret);\n\n    return ret;\n  });\n}\n","import cloneNode from \"./cloneNode.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Create a shallow clone of a `node`, including only\n * properties belonging to the node.\n * @deprecated Use t.cloneNode instead.\n */\nexport default function clone<T extends t.Node>(node: T): T {\n  return cloneNode(node, /* deep */ false);\n}\n","import cloneNode from \"./cloneNode.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Create a deep clone of a `node` and all of it's child nodes\n * including only properties belonging to the node.\n * @deprecated Use t.cloneNode instead.\n */\nexport default function cloneDeep<T extends t.Node>(node: T): T {\n  return cloneNode(node);\n}\n","import cloneNode from \"./cloneNode.ts\";\nimport type * as t from \"../index.ts\";\n/**\n * Create a deep clone of a `node` and all of it's child nodes\n * including only properties belonging to the node.\n * excluding `_private` and location properties.\n */\nexport default function cloneDeepWithoutLoc<T extends t.Node>(node: T): T {\n  return cloneNode(node, /* deep */ true, /* withoutLoc */ true);\n}\n","import cloneNode from \"./cloneNode.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Create a shallow clone of a `node` excluding `_private` and location properties.\n */\nexport default function cloneWithoutLoc<T extends t.Node>(node: T): T {\n  return cloneNode(node, /* deep */ false, /* withoutLoc */ true);\n}\n","import type * as t from \"../index.ts\";\n\n/**\n * Add comments of certain type to a node.\n */\nexport default function addComments<T extends t.Node>(\n  node: T,\n  type: t.CommentTypeShorthand,\n  comments: t.Comment[],\n): T {\n  if (!comments || !node) return node;\n\n  const key = `${type}Comments` as const;\n\n  if (node[key]) {\n    if (type === \"leading\") {\n      node[key] = comments.concat(node[key]);\n    } else {\n      node[key].push(...comments);\n    }\n  } else {\n    node[key] = comments;\n  }\n\n  return node;\n}\n","import addComments from \"./addComments.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Add comment of certain type to a node.\n */\nexport default function addComment<T extends t.Node>(\n  node: T,\n  type: t.CommentTypeShorthand,\n  content: string,\n  line?: boolean,\n): T {\n  return addComments(node, type, [\n    {\n      type: line ? \"CommentLine\" : \"CommentBlock\",\n      value: content,\n    } as t.Comment,\n  ]);\n}\n","import type * as t from \"../index.ts\";\n\nexport default function inherit<C extends t.Node, P extends t.Node>(\n  key: keyof C & keyof P,\n  child: C,\n  parent: P,\n): void {\n  if (child && parent) {\n    // @ts-expect-error Could further refine key definitions\n    child[key] = Array.from(\n      new Set(([] as any[]).concat(child[key], parent[key]).filter(Boolean)),\n    );\n  }\n}\n","import inherit from \"../utils/inherit.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function inheritInnerComments(\n  child: t.Node,\n  parent: t.Node,\n): void {\n  inherit(\"innerComments\", child, parent);\n}\n","import inherit from \"../utils/inherit.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function inheritLeadingComments(\n  child: t.Node | null,\n  parent: t.Node | null,\n): void {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  inherit(\"leadingComments\", child!, parent!);\n}\n","import inherit from \"../utils/inherit.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function inheritTrailingComments(\n  child: t.Node | null,\n  parent: t.Node | null,\n): void {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  inherit(\"trailingComments\", child!, parent!);\n}\n","import inheritTrailingComments from \"./inheritTrailingComments.ts\";\nimport inheritLeadingComments from \"./inheritLeadingComments.ts\";\nimport inheritInnerComments from \"./inheritInnerComments.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Inherit all unique comments from `parent` node to `child` node.\n */\nexport default function inheritsComments<T extends t.Node>(\n  child: T,\n  parent: t.Node,\n): T {\n  inheritTrailingComments(child, parent);\n  inheritLeadingComments(child, parent);\n  inheritInnerComments(child, parent);\n\n  return child;\n}\n","import { COMMENT_KEYS } from \"../constants/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Remove comment properties from a node.\n */\nexport default function removeComments<T extends t.Node>(node: T): T {\n  COMMENT_KEYS.forEach(key => {\n    node[key] = null;\n  });\n\n  return node;\n}\n","/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport { FLIPPED_ALIAS_KEYS } from \"../../definitions/index.ts\";\n\nexport const STANDARDIZED_TYPES = FLIPPED_ALIAS_KEYS[\"Standardized\"];\nexport const EXPRESSION_TYPES = FLIPPED_ALIAS_KEYS[\"Expression\"];\nexport const BINARY_TYPES = FLIPPED_ALIAS_KEYS[\"Binary\"];\nexport const SCOPABLE_TYPES = FLIPPED_ALIAS_KEYS[\"Scopable\"];\nexport const BLOCKPARENT_TYPES = FLIPPED_ALIAS_KEYS[\"BlockParent\"];\nexport const BLOCK_TYPES = FLIPPED_ALIAS_KEYS[\"Block\"];\nexport const STATEMENT_TYPES = FLIPPED_ALIAS_KEYS[\"Statement\"];\nexport const TERMINATORLESS_TYPES = FLIPPED_ALIAS_KEYS[\"Terminatorless\"];\nexport const COMPLETIONSTATEMENT_TYPES =\n  FLIPPED_ALIAS_KEYS[\"CompletionStatement\"];\nexport const CONDITIONAL_TYPES = FLIPPED_ALIAS_KEYS[\"Conditional\"];\nexport const LOOP_TYPES = FLIPPED_ALIAS_KEYS[\"Loop\"];\nexport const WHILE_TYPES = FLIPPED_ALIAS_KEYS[\"While\"];\nexport const EXPRESSIONWRAPPER_TYPES = FLIPPED_ALIAS_KEYS[\"ExpressionWrapper\"];\nexport const FOR_TYPES = FLIPPED_ALIAS_KEYS[\"For\"];\nexport const FORXSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS[\"ForXStatement\"];\nexport const FUNCTION_TYPES = FLIPPED_ALIAS_KEYS[\"Function\"];\nexport const FUNCTIONPARENT_TYPES = FLIPPED_ALIAS_KEYS[\"FunctionParent\"];\nexport const PUREISH_TYPES = FLIPPED_ALIAS_KEYS[\"Pureish\"];\nexport const DECLARATION_TYPES = FLIPPED_ALIAS_KEYS[\"Declaration\"];\nexport const FUNCTIONPARAMETER_TYPES = FLIPPED_ALIAS_KEYS[\"FunctionParameter\"];\nexport const PATTERNLIKE_TYPES = FLIPPED_ALIAS_KEYS[\"PatternLike\"];\nexport const LVAL_TYPES = FLIPPED_ALIAS_KEYS[\"LVal\"];\nexport const TSENTITYNAME_TYPES = FLIPPED_ALIAS_KEYS[\"TSEntityName\"];\nexport const LITERAL_TYPES = FLIPPED_ALIAS_KEYS[\"Literal\"];\nexport const IMMUTABLE_TYPES = FLIPPED_ALIAS_KEYS[\"Immutable\"];\nexport const USERWHITESPACABLE_TYPES = FLIPPED_ALIAS_KEYS[\"UserWhitespacable\"];\nexport const METHOD_TYPES = FLIPPED_ALIAS_KEYS[\"Method\"];\nexport const OBJECTMEMBER_TYPES = FLIPPED_ALIAS_KEYS[\"ObjectMember\"];\nexport const PROPERTY_TYPES = FLIPPED_ALIAS_KEYS[\"Property\"];\nexport const UNARYLIKE_TYPES = FLIPPED_ALIAS_KEYS[\"UnaryLike\"];\nexport const PATTERN_TYPES = FLIPPED_ALIAS_KEYS[\"Pattern\"];\nexport const CLASS_TYPES = FLIPPED_ALIAS_KEYS[\"Class\"];\nexport const IMPORTOREXPORTDECLARATION_TYPES =\n  FLIPPED_ALIAS_KEYS[\"ImportOrExportDeclaration\"];\nexport const EXPORTDECLARATION_TYPES = FLIPPED_ALIAS_KEYS[\"ExportDeclaration\"];\nexport const MODULESPECIFIER_TYPES = FLIPPED_ALIAS_KEYS[\"ModuleSpecifier\"];\nexport const PRIVATE_TYPES = FLIPPED_ALIAS_KEYS[\"Private\"];\nexport const FLOW_TYPES = FLIPPED_ALIAS_KEYS[\"Flow\"];\nexport const FLOWTYPE_TYPES = FLIPPED_ALIAS_KEYS[\"FlowType\"];\nexport const FLOWBASEANNOTATION_TYPES =\n  FLIPPED_ALIAS_KEYS[\"FlowBaseAnnotation\"];\nexport const FLOWDECLARATION_TYPES = FLIPPED_ALIAS_KEYS[\"FlowDeclaration\"];\nexport const FLOWPREDICATE_TYPES = FLIPPED_ALIAS_KEYS[\"FlowPredicate\"];\nexport const ENUMBODY_TYPES = FLIPPED_ALIAS_KEYS[\"EnumBody\"];\nexport const ENUMMEMBER_TYPES = FLIPPED_ALIAS_KEYS[\"EnumMember\"];\nexport const JSX_TYPES = FLIPPED_ALIAS_KEYS[\"JSX\"];\nexport const MISCELLANEOUS_TYPES = FLIPPED_ALIAS_KEYS[\"Miscellaneous\"];\nexport const ACCESSOR_TYPES = FLIPPED_ALIAS_KEYS[\"Accessor\"];\nexport const TYPESCRIPT_TYPES = FLIPPED_ALIAS_KEYS[\"TypeScript\"];\nexport const TSTYPEELEMENT_TYPES = FLIPPED_ALIAS_KEYS[\"TSTypeElement\"];\nexport const TSTYPE_TYPES = FLIPPED_ALIAS_KEYS[\"TSType\"];\nexport const TSBASETYPE_TYPES = FLIPPED_ALIAS_KEYS[\"TSBaseType\"];\n/**\n * @deprecated migrate to IMPORTOREXPORTDECLARATION_TYPES.\n */\nexport const MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;\n","import {\n  isBlockStatement,\n  isFunction,\n  isEmptyStatement,\n  isStatement,\n} from \"../validators/generated/index.ts\";\nimport {\n  returnStatement,\n  expressionStatement,\n  blockStatement,\n} from \"../builders/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function toBlock(\n  node: t.Statement | t.Expression,\n  parent?: t.Node,\n): t.BlockStatement {\n  if (isBlockStatement(node)) {\n    return node;\n  }\n\n  let blockNodes: t.Statement[] = [];\n\n  if (isEmptyStatement(node)) {\n    blockNodes = [];\n  } else {\n    if (!isStatement(node)) {\n      if (isFunction(parent)) {\n        node = returnStatement(node);\n      } else {\n        node = expressionStatement(node);\n      }\n    }\n\n    blockNodes = [node];\n  }\n\n  return blockStatement(blockNodes);\n}\n","import toBlock from \"./toBlock.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Ensure the `key` (defaults to \"body\") of a `node` is a block.\n * Casting it to a block if it is not.\n *\n * Returns the BlockStatement\n */\nexport default function ensureBlock(\n  node: t.Node,\n  key: string = \"body\",\n): t.BlockStatement {\n  // @ts-expect-error Fixme: key may not exist in node, consider remove key = \"body\"\n  const result = toBlock(node[key], node);\n  // @ts-expect-error Fixme: key may not exist in node, consider remove key = \"body\"\n  node[key] = result;\n  return result;\n}\n","import isValidIdentifier from \"../validators/isValidIdentifier.ts\";\nimport { isIdentifierChar } from \"@babel/helper-validator-identifier\";\n\nexport default function toIdentifier(input: string): string {\n  input = input + \"\";\n\n  // replace all non-valid identifiers with dashes\n  let name = \"\";\n  for (const c of input) {\n    name += isIdentifierChar(c.codePointAt(0)!) ? c : \"-\";\n  }\n\n  // remove all dashes and numbers from start of name\n  name = name.replace(/^[-0-9]+/, \"\");\n\n  // camel case\n  name = name.replace(/[-\\s]+(.)?/g, function (match, c) {\n    return c ? c.toUpperCase() : \"\";\n  });\n\n  if (!isValidIdentifier(name)) {\n    name = `_${name}`;\n  }\n\n  return name || \"_\";\n}\n","import toIdentifier from \"./toIdentifier.ts\";\n\nexport default function toBindingIdentifierName(name: string): string {\n  name = toIdentifier(name);\n  if (name === \"eval\" || name === \"arguments\") name = \"_\" + name;\n\n  return name;\n}\n","import { isIdentifier } from \"../validators/generated/index.ts\";\nimport { stringLiteral } from \"../builders/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function toComputedKey(\n  node:\n    | t.ObjectMember\n    | t.ObjectProperty\n    | t.ClassMethod\n    | t.ClassProperty\n    | t.ClassAccessorProperty\n    | t.MemberExpression\n    | t.OptionalMemberExpression,\n  // @ts-expect-error todo(flow->ts): maybe check the type of node before accessing .key and .property\n  key: t.Expression | t.PrivateName = node.key || node.property,\n) {\n  if (!node.computed && isIdentifier(key)) key = stringLiteral(key.name);\n\n  return key;\n}\n","import {\n  isExpression,\n  isFunction,\n  isClass,\n  isExpressionStatement,\n} from \"../validators/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default toExpression as {\n  (node: t.Function): t.FunctionExpression;\n  (node: t.Class): t.ClassExpression;\n  (\n    node: t.ExpressionStatement | t.Expression | t.Class | t.Function,\n  ): t.Expression;\n};\n\nfunction toExpression(\n  node: t.ExpressionStatement | t.Expression | t.Class | t.Function,\n): t.Expression {\n  if (isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  // return unmodified node\n  // important for things like ArrowFunctions where\n  // type change from ArrowFunction to FunctionExpression\n  // produces bugs like -> `()=>a` to `function () a`\n  // without generating a BlockStatement for it\n  // ref: https://github.com/babel/babili/issues/130\n  if (isExpression(node)) {\n    return node;\n  }\n\n  // convert all classes and functions\n  // ClassDeclaration -> ClassExpression\n  // FunctionDeclaration, ObjectMethod, ClassMethod -> FunctionExpression\n  if (isClass(node)) {\n    // @ts-expect-error todo(flow->ts): avoid type unsafe mutations\n    node.type = \"ClassExpression\";\n    // abstract modifiers are only allowed on class declarations\n    node.abstract = false;\n  } else if (isFunction(node)) {\n    // @ts-expect-error todo(flow->ts): avoid type unsafe mutations\n    node.type = \"FunctionExpression\";\n  }\n\n  // if it's still not an expression\n  if (!isExpression(node)) {\n    throw new Error(`cannot turn ${node.type} to an expression`);\n  }\n\n  return node;\n}\n","import { VISITOR_KEYS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\nconst _skip = Symbol();\nconst _stop = Symbol();\n\n/**\n * A prefix AST traversal implementation meant for simple searching and processing.\n * @param enter The callback can return `traverseFast.skip` to skip the subtree of the current node, or `traverseFast.stop` to stop the traversal.\n * @returns `true` if the traversal was stopped by callback, `false` otherwise.\n */\nexport default function traverseFast<Options = object>(\n  node: t.Node | null | undefined,\n  enter: (\n    node: t.Node,\n    opts?: Options,\n  ) => void | typeof traverseFast.skip | typeof traverseFast.stop,\n  opts?: Options,\n): boolean {\n  if (!node) return false;\n\n  const keys = VISITOR_KEYS[node.type];\n  if (!keys) return false;\n\n  opts = opts || ({} as Options);\n  const ret = enter(node, opts);\n  if (ret !== undefined) {\n    switch (ret) {\n      case _skip:\n        return false;\n      case _stop:\n        return true;\n    }\n  }\n\n  for (const key of keys) {\n    const subNode: t.Node | undefined | null =\n      // @ts-expect-error key must present in node\n      node[key];\n\n    if (!subNode) continue;\n\n    if (Array.isArray(subNode)) {\n      for (const node of subNode) {\n        if (traverseFast(node, enter, opts)) return true;\n      }\n    } else {\n      if (traverseFast(subNode, enter, opts)) return true;\n    }\n  }\n  return false;\n}\n\ntraverseFast.skip = _skip;\ntraverseFast.stop = _stop;\n","import { COMMENT_KEYS } from \"../constants/index.ts\";\nimport type * as t from \"../index.ts\";\n\nconst CLEAR_KEYS = [\n  \"tokens\", // only exist in t.File\n  \"start\",\n  \"end\",\n  \"loc\",\n  // Fixme: should be extra.raw / extra.rawValue?\n  \"raw\",\n  \"rawValue\",\n] as const;\n\nconst CLEAR_KEYS_PLUS_COMMENTS = [\n  ...COMMENT_KEYS,\n  \"comments\",\n  ...CLEAR_KEYS,\n] as const;\n\nexport type Options = { preserveComments?: boolean };\n/**\n * Remove all of the _* properties from a node along with the additional metadata\n * properties like location data and raw token data.\n */\nexport default function removeProperties(\n  node: t.Node,\n  opts: Options = {},\n): void {\n  const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;\n  for (const key of map) {\n    // @ts-expect-error tokens only exist in t.File\n    if (node[key] != null) node[key] = undefined;\n  }\n\n  for (const key of Object.keys(node)) {\n    // @ts-expect-error string can not index node\n    if (key.startsWith(\"_\") && node[key] != null) node[key] = undefined;\n  }\n\n  const symbols: symbol[] = Object.getOwnPropertySymbols(node);\n  for (const sym of symbols) {\n    // @ts-expect-error Fixme: document symbol properties\n    node[sym] = null;\n  }\n}\n","import traverseFast from \"../traverse/traverseFast.ts\";\nimport removeProperties from \"./removeProperties.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function removePropertiesDeep<T extends t.Node>(\n  tree: T,\n  opts?: { preserveComments: boolean } | null,\n): T {\n  traverseFast(tree, removeProperties, opts);\n\n  return tree;\n}\n","import {\n  isIdentifier,\n  isStringLiteral,\n} from \"../validators/generated/index.ts\";\nimport cloneNode from \"../clone/cloneNode.ts\";\nimport removePropertiesDeep from \"../modifications/removePropertiesDeep.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function toKeyAlias(\n  node: t.Method | t.Property,\n  key: t.Node = node.key,\n): string {\n  let alias;\n\n  // @ts-expect-error todo(flow->ts): maybe add node type check before checking `.kind`\n  if (node.kind === \"method\") {\n    return toKeyAlias.increment() + \"\";\n  } else if (isIdentifier(key)) {\n    alias = key.name;\n  } else if (isStringLiteral(key)) {\n    alias = JSON.stringify(key.value);\n  } else {\n    alias = JSON.stringify(removePropertiesDeep(cloneNode(key)));\n  }\n\n  // @ts-expect-error todo(flow->ts): maybe add node type check before checking `.computed`\n  if (node.computed) {\n    alias = `[${alias}]`;\n  }\n\n  // @ts-expect-error todo(flow->ts): maybe add node type check before checking `.static`\n  if (node.static) {\n    alias = `static:${alias}`;\n  }\n\n  return alias;\n}\n\ntoKeyAlias.uid = 0;\n\ntoKeyAlias.increment = function () {\n  if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {\n    return (toKeyAlias.uid = 0);\n  } else {\n    return toKeyAlias.uid++;\n  }\n};\n","import {\n  isStatement,\n  isFunction,\n  isClass,\n  isAssignmentExpression,\n} from \"../validators/generated/index.ts\";\nimport { expressionStatement } from \"../builders/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default toStatement as {\n  (node: t.AssignmentExpression, ignore?: boolean): t.ExpressionStatement;\n\n  <T extends t.Statement>(node: T, ignore: false): T;\n  <T extends t.Statement>(node: T, ignore?: boolean): T | false;\n\n  (node: t.Class, ignore: false): t.ClassDeclaration;\n  (node: t.Class, ignore?: boolean): t.ClassDeclaration | false;\n\n  (node: t.Function, ignore: false): t.FunctionDeclaration;\n  (node: t.Function, ignore?: boolean): t.FunctionDeclaration | false;\n\n  (node: t.Node, ignore: false): t.Statement;\n  (node: t.Node, ignore?: boolean): t.Statement | false;\n};\n\nfunction toStatement(node: t.Node, ignore?: boolean): t.Statement | false {\n  if (isStatement(node)) {\n    return node;\n  }\n\n  let mustHaveId = false;\n  let newType;\n\n  if (isClass(node)) {\n    mustHaveId = true;\n    newType = \"ClassDeclaration\" as const;\n  } else if (isFunction(node)) {\n    mustHaveId = true;\n    newType = \"FunctionDeclaration\" as const;\n  } else if (isAssignmentExpression(node)) {\n    return expressionStatement(node);\n  }\n\n  // @ts-expect-error todo(flow->ts): node.id might be missing\n  if (mustHaveId && !node.id) {\n    newType = false;\n  }\n\n  if (!newType) {\n    if (ignore) {\n      return false;\n    } else {\n      throw new Error(`cannot turn ${node.type} to a statement`);\n    }\n  }\n\n  // @ts-expect-error manipulating node.type\n  node.type = newType;\n\n  // @ts-expect-error todo(flow->ts) refactor to avoid type unsafe mutations like reassigning node type above\n  return node;\n}\n","import isValidIdentifier from \"../validators/isValidIdentifier.ts\";\nimport {\n  identifier,\n  booleanLiteral,\n  nullLiteral,\n  stringLiteral,\n  numericLiteral,\n  bigIntLiteral,\n  regExpLiteral,\n  arrayExpression,\n  objectProperty,\n  objectExpression,\n  unaryExpression,\n  binaryExpression,\n} from \"../builders/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default valueToNode as {\n  (value: undefined): t.Identifier; // TODO: This should return \"void 0\"\n  (value: boolean): t.BooleanLiteral;\n  (value: null): t.NullLiteral;\n  (value: string): t.StringLiteral;\n  // Infinities and NaN need to use a BinaryExpression; negative values must be wrapped in UnaryExpression\n  (value: number): t.NumericLiteral | t.BinaryExpression | t.UnaryExpression;\n  (value: bigint): t.BigIntLiteral;\n  (value: RegExp): t.RegExpLiteral;\n  (value: readonly unknown[]): t.ArrayExpression;\n\n  // this throws with objects that are not plain objects,\n  // or if there are non-valueToNode-able values\n  (value: object): t.ObjectExpression;\n\n  (value: unknown): t.Expression;\n};\n\n// @ts-expect-error: Object.prototype.toString must return a string\nconst objectToString: (value: unknown) => string = Function.call.bind(\n  Object.prototype.toString,\n);\n\nfunction isRegExp(value: unknown): value is RegExp {\n  return objectToString(value) === \"[object RegExp]\";\n}\n\nfunction isPlainObject(value: unknown): value is object {\n  if (\n    typeof value !== \"object\" ||\n    value === null ||\n    Object.prototype.toString.call(value) !== \"[object Object]\"\n  ) {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(value);\n  // Object.prototype's __proto__ is null. Every other class's __proto__.__proto__ is\n  // not null by default. We cannot check if proto === Object.prototype because it\n  // could come from another realm.\n  return proto === null || Object.getPrototypeOf(proto) === null;\n}\n\nfunction valueToNode(value: unknown): t.Expression {\n  // undefined\n  if (value === undefined) {\n    return identifier(\"undefined\");\n  }\n\n  // boolean\n  if (value === true || value === false) {\n    return booleanLiteral(value);\n  }\n\n  // null\n  if (value === null) {\n    return nullLiteral();\n  }\n\n  // strings\n  if (typeof value === \"string\") {\n    return stringLiteral(value);\n  }\n\n  // numbers\n  if (typeof value === \"number\") {\n    let result;\n    if (Number.isFinite(value)) {\n      result = numericLiteral(Math.abs(value));\n    } else {\n      let numerator;\n      if (Number.isNaN(value)) {\n        // NaN\n        numerator = numericLiteral(0);\n      } else {\n        // Infinity / -Infinity\n        numerator = numericLiteral(1);\n      }\n\n      result = binaryExpression(\"/\", numerator, numericLiteral(0));\n    }\n\n    if (value < 0 || Object.is(value, -0)) {\n      result = unaryExpression(\"-\", result);\n    }\n\n    return result;\n  }\n\n  // bigints\n  if (typeof value === \"bigint\") {\n    if (value < 0) {\n      return unaryExpression(\"-\", bigIntLiteral(-value));\n    } else {\n      return bigIntLiteral(value);\n    }\n  }\n\n  // regexes\n  if (isRegExp(value)) {\n    const pattern = value.source;\n    const flags = /\\/([a-z]*)$/.exec(value.toString())![1];\n    return regExpLiteral(pattern, flags);\n  }\n\n  // array\n  if (Array.isArray(value)) {\n    return arrayExpression(value.map(valueToNode));\n  }\n\n  // object\n  if (isPlainObject(value)) {\n    const props = [];\n    for (const key of Object.keys(value)) {\n      let nodeKey,\n        computed = false;\n      if (isValidIdentifier(key)) {\n        if (key === \"__proto__\") {\n          computed = true;\n          nodeKey = stringLiteral(key);\n        } else {\n          nodeKey = identifier(key);\n        }\n      } else {\n        nodeKey = stringLiteral(key);\n      }\n      props.push(\n        objectProperty(\n          nodeKey,\n          valueToNode(\n            // @ts-expect-error key must present in value\n            value[key],\n          ),\n          computed,\n        ),\n      );\n    }\n    return objectExpression(props);\n  }\n\n  throw new Error(\"don't know how to turn this value into a node\");\n}\n","import { memberExpression } from \"../builders/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Append a node to a member expression.\n */\nexport default function appendToMemberExpression(\n  member: t.MemberExpression,\n  append: t.MemberExpression[\"property\"],\n  computed: boolean = false,\n): t.MemberExpression {\n  member.object = memberExpression(\n    member.object,\n    member.property,\n    member.computed,\n  );\n  member.property = append;\n  member.computed = !!computed;\n\n  return member;\n}\n","import { INHERIT_KEYS } from \"../constants/index.ts\";\nimport inheritsComments from \"../comments/inheritsComments.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Inherit all contextual properties from `parent` node to `child` node.\n */\nexport default function inherits<T extends t.Node | null | undefined>(\n  child: T,\n  parent: t.Node | null | undefined,\n): T {\n  if (!child || !parent) return child;\n\n  // optionally inherit specific properties if not null\n  for (const key of INHERIT_KEYS.optional) {\n    // @ts-expect-error Fixme: refine parent types\n    if (child[key] == null) {\n      // @ts-expect-error Fixme: refine parent types\n      child[key] = parent[key];\n    }\n  }\n\n  // force inherit \"private\" properties\n  for (const key of Object.keys(parent)) {\n    if (key.startsWith(\"_\") && key !== \"__clone\") {\n      // @ts-expect-error Fixme: refine parent types\n      child[key] = parent[key];\n    }\n  }\n\n  // force inherit select properties\n  for (const key of INHERIT_KEYS.force) {\n    // @ts-expect-error Fixme: refine parent types\n    child[key] = parent[key];\n  }\n\n  inheritsComments(child, parent);\n\n  return child;\n}\n","import { memberExpression } from \"../builders/generated/index.ts\";\nimport { isSuper } from \"../index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Prepend a node to a member expression.\n */\nexport default function prependToMemberExpression<\n  T extends Pick<t.MemberExpression, \"object\" | \"property\">,\n>(member: T, prepend: t.MemberExpression[\"object\"]): T {\n  if (isSuper(member.object)) {\n    throw new Error(\n      \"Cannot prepend node to super property access (`super.foo`).\",\n    );\n  }\n  member.object = memberExpression(prepend, member.object);\n\n  return member;\n}\n","import type * as t from \"../index.ts\";\n\n/**\n * For the given node, generate a map from assignment id names to the identifier node.\n * Unlike getBindingIdentifiers, this function does not handle declarations and imports.\n * @param node the assignment expression or forXstatement\n * @returns an object map\n * @see getBindingIdentifiers\n */\nexport default function getAssignmentIdentifiers(\n  node: t.Node | t.Node[],\n): Record<string, t.Identifier> {\n  // null represents holes in an array pattern\n  const search: (t.Node | null)[] = ([] as t.Node[]).concat(node);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.pop();\n    if (!id) continue;\n\n    switch (id.type) {\n      case \"ArrayPattern\":\n        search.push(...id.elements);\n        break;\n\n      case \"AssignmentExpression\":\n      case \"AssignmentPattern\":\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        search.push(id.left);\n        break;\n\n      case \"ObjectPattern\":\n        search.push(...id.properties);\n        break;\n\n      case \"ObjectProperty\":\n        search.push(id.value);\n        break;\n\n      case \"RestElement\":\n      case \"UpdateExpression\":\n        search.push(id.argument);\n        break;\n\n      case \"UnaryExpression\":\n        if (id.operator === \"delete\") {\n          search.push(id.argument);\n        }\n        break;\n\n      case \"Identifier\":\n        ids[id.name] = id;\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  return ids;\n}\n","import {\n  isExportDeclaration,\n  isIdentifier,\n  isClassExpression,\n  isDeclaration,\n  isFunctionDeclaration,\n  isFunctionExpression,\n  isExportAllDeclaration,\n  isAssignmentExpression,\n  isUnaryExpression,\n  isUpdateExpression,\n} from \"../validators/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport { getBindingIdentifiers as default };\n\nfunction getBindingIdentifiers(\n  node: t.Node,\n  duplicates: true,\n  outerOnly?: boolean,\n  newBindingsOnly?: boolean,\n): Record<string, t.Identifier[]>;\n\nfunction getBindingIdentifiers(\n  node: t.Node,\n  duplicates?: false,\n  outerOnly?: boolean,\n  newBindingsOnly?: boolean,\n): Record<string, t.Identifier>;\n\nfunction getBindingIdentifiers(\n  node: t.Node,\n  duplicates?: boolean,\n  outerOnly?: boolean,\n  newBindingsOnly?: boolean,\n): Record<string, t.Identifier> | Record<string, t.Identifier[]>;\n\n/**\n * Return a list of binding identifiers associated with the input `node`.\n */\nfunction getBindingIdentifiers(\n  node: t.Node,\n  duplicates?: boolean,\n  outerOnly?: boolean,\n  newBindingsOnly?: boolean,\n): Record<string, t.Identifier> | Record<string, t.Identifier[]> {\n  // @ts-expect-error FIXME: disallow Node[]\n  const search: t.Node[] = [].concat(node);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n\n    if (\n      newBindingsOnly &&\n      // These nodes do not introduce _new_ bindings, but they are included\n      // in getBindingIdentifiers.keys for backwards compatibility.\n      // TODO(@nicolo-ribaudo): Check if we can remove them from .keys in a\n      // backward-compatible way, and if not what we need to do to remove them\n      // in Babel 8.\n      (isAssignmentExpression(id) ||\n        isUnaryExpression(id) ||\n        isUpdateExpression(id))\n    ) {\n      continue;\n    }\n\n    if (isIdentifier(id)) {\n      if (duplicates) {\n        const _ids = (ids[id.name] = ids[id.name] || []);\n        _ids.push(id);\n      } else {\n        ids[id.name] = id;\n      }\n      continue;\n    }\n\n    if (isExportDeclaration(id) && !isExportAllDeclaration(id)) {\n      if (isDeclaration(id.declaration)) {\n        search.push(id.declaration);\n      }\n      continue;\n    }\n\n    if (outerOnly) {\n      if (isFunctionDeclaration(id)) {\n        search.push(id.id!);\n        continue;\n      }\n\n      if (isFunctionExpression(id) || isClassExpression(id)) {\n        continue;\n      }\n    }\n\n    const keys = getBindingIdentifiers.keys[id.type];\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const nodes =\n          // @ts-expect-error key must present in id\n          id[key] as t.Node[] | t.Node | undefined | null;\n        if (nodes) {\n          if (Array.isArray(nodes)) {\n            search.push(...nodes);\n          } else {\n            search.push(nodes);\n          }\n        }\n      }\n    }\n  }\n  return ids;\n}\n\n/**\n * Mapping of types to their identifier keys.\n */\ntype KeysMap = {\n  [N in t.Node as N[\"type\"]]?: (keyof N)[];\n};\n\nconst keys: KeysMap = {\n  DeclareClass: [\"id\"],\n  DeclareFunction: [\"id\"],\n  DeclareModule: [\"id\"],\n  DeclareVariable: [\"id\"],\n  DeclareInterface: [\"id\"],\n  DeclareTypeAlias: [\"id\"],\n  DeclareOpaqueType: [\"id\"],\n  InterfaceDeclaration: [\"id\"],\n  TypeAlias: [\"id\"],\n  OpaqueType: [\"id\"],\n\n  CatchClause: [\"param\"],\n  LabeledStatement: [\"label\"],\n  UnaryExpression: [\"argument\"],\n  AssignmentExpression: [\"left\"],\n\n  ImportSpecifier: [\"local\"],\n  ImportNamespaceSpecifier: [\"local\"],\n  ImportDefaultSpecifier: [\"local\"],\n  ImportDeclaration: [\"specifiers\"],\n  TSImportEqualsDeclaration: [\"id\"],\n\n  ExportSpecifier: [\"exported\"],\n  ExportNamespaceSpecifier: [\"exported\"],\n  ExportDefaultSpecifier: [\"exported\"],\n\n  FunctionDeclaration: [\"id\", \"params\"],\n  FunctionExpression: [\"id\", \"params\"],\n  ArrowFunctionExpression: [\"params\"],\n  ObjectMethod: [\"params\"],\n  ClassMethod: [\"params\"],\n  ClassPrivateMethod: [\"params\"],\n\n  ForInStatement: [\"left\"],\n  ForOfStatement: [\"left\"],\n\n  ClassDeclaration: [\"id\"],\n  ClassExpression: [\"id\"],\n\n  RestElement: [\"argument\"],\n  UpdateExpression: [\"argument\"],\n\n  ObjectProperty: [\"value\"],\n\n  AssignmentPattern: [\"left\"],\n  ArrayPattern: [\"elements\"],\n  ObjectPattern: [\"properties\"],\n\n  VariableDeclaration: [\"declarations\"],\n  VariableDeclarator: [\"id\"],\n};\n\ngetBindingIdentifiers.keys = keys;\n","import getBindingIdentifiers from \"./getBindingIdentifiers.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default getOuterBindingIdentifiers as {\n  (node: t.Node, duplicates: true): Record<string, t.Identifier[]>;\n  (node: t.Node, duplicates?: false): Record<string, t.Identifier>;\n  (\n    node: t.Node,\n    duplicates?: boolean,\n  ): Record<string, t.Identifier> | Record<string, t.Identifier[]>;\n};\n\nfunction getOuterBindingIdentifiers(\n  node: t.Node,\n  duplicates: boolean,\n): Record<string, t.Identifier> | Record<string, t.Identifier[]> {\n  return getBindingIdentifiers(node, duplicates, true);\n}\n","import type * as t from \"../index.ts\";\n\nimport {\n  isAssignmentExpression,\n  isClassMethod,\n  isIdentifier,\n  isLiteral,\n  isNullLiteral,\n  isObjectMethod,\n  isObjectProperty,\n  isPrivateName,\n  isRegExpLiteral,\n  isTemplateLiteral,\n  isVariableDeclarator,\n} from \"../validators/generated/index.ts\";\n\nfunction getNameFromLiteralId(id: t.Literal): string | null {\n  if (isNullLiteral(id)) {\n    return \"null\";\n  }\n\n  if (isRegExpLiteral(id)) {\n    return `/${id.pattern}/${id.flags}`;\n  }\n\n  if (isTemplateLiteral(id)) {\n    return id.quasis.map(quasi => quasi.value.raw).join(\"\");\n  }\n\n  if (id.value !== undefined) {\n    return String(id.value);\n  }\n\n  return null;\n}\n\nfunction getObjectMemberKey(\n  node: t.ObjectProperty | t.ObjectMethod | t.ClassProperty | t.ClassMethod,\n): t.Expression | t.PrivateName | null {\n  if (!node.computed || isLiteral(node.key)) {\n    return node.key;\n  }\n  return null;\n}\n\ntype GetFunctionNameResult = {\n  name: string;\n  originalNode: t.Node;\n} | null;\n\nexport default function getFunctionName(\n  node: t.ObjectMethod | t.ClassMethod,\n): GetFunctionNameResult;\nexport default function getFunctionName(\n  node: t.Function | t.Class,\n  parent: t.Node,\n): GetFunctionNameResult;\nexport default function getFunctionName(\n  node: t.Function | t.Class,\n  parent?: t.Node,\n): GetFunctionNameResult {\n  if (\"id\" in node && node.id) {\n    return {\n      name: node.id.name,\n      originalNode: node.id,\n    };\n  }\n\n  let prefix = \"\";\n\n  let id;\n  if (isObjectProperty(parent, { value: node })) {\n    // { foo: () => {} };\n    id = getObjectMemberKey(parent);\n  } else if (isObjectMethod(node) || isClassMethod(node)) {\n    // { foo() {} };\n    id = getObjectMemberKey(node);\n    if (node.kind === \"get\") prefix = \"get \";\n    else if (node.kind === \"set\") prefix = \"set \";\n  } else if (isVariableDeclarator(parent) && parent.init === node) {\n    // let foo = function () {};\n    id = parent.id;\n  } else if (isAssignmentExpression(parent, { operator: \"=\", right: node })) {\n    // foo = function () {};\n    id = parent.left;\n  }\n\n  if (!id) return null;\n\n  const name = isLiteral(id)\n    ? getNameFromLiteralId(id)\n    : isIdentifier(id)\n      ? id.name\n      : isPrivateName(id)\n        ? id.id.name\n        : null;\n  if (name == null) return null;\n\n  return { name: prefix + name, originalNode: id };\n}\n","import { VISITOR_KEYS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport type TraversalAncestors = {\n  node: t.Node;\n  key: string;\n  index?: number;\n}[];\n\nexport type TraversalHandler<T> = (\n  this: undefined,\n  node: t.Node,\n  parent: TraversalAncestors,\n  state: T,\n) => void;\n\nexport type TraversalHandlers<T> = {\n  enter?: TraversalHandler<T>;\n  exit?: TraversalHandler<T>;\n};\n\n/**\n * A general AST traversal with both prefix and postfix handlers, and a\n * state object. Exposes ancestry data to each handler so that more complex\n * AST data can be taken into account.\n */\nexport default function traverse<T>(\n  node: t.Node,\n  handlers: TraversalHandler<T> | TraversalHandlers<T>,\n  state?: T,\n): void {\n  if (typeof handlers === \"function\") {\n    handlers = { enter: handlers };\n  }\n\n  const { enter, exit } = handlers;\n\n  traverseSimpleImpl(node, enter, exit, state, []);\n}\n\nfunction traverseSimpleImpl<T>(\n  node: any,\n  enter: Function | undefined,\n  exit: Function | undefined,\n  state: T | undefined,\n  ancestors: TraversalAncestors,\n) {\n  const keys = VISITOR_KEYS[node.type];\n  if (!keys) return;\n\n  if (enter) enter(node, ancestors, state);\n\n  for (const key of keys) {\n    const subNode = node[key];\n\n    if (Array.isArray(subNode)) {\n      for (let i = 0; i < subNode.length; i++) {\n        const child = subNode[i];\n        if (!child) continue;\n\n        ancestors.push({\n          node,\n          key,\n          index: i,\n        });\n\n        traverseSimpleImpl(child, enter, exit, state, ancestors);\n\n        ancestors.pop();\n      }\n    } else if (subNode) {\n      ancestors.push({\n        node,\n        key,\n      });\n\n      traverseSimpleImpl(subNode, enter, exit, state, ancestors);\n\n      ancestors.pop();\n    }\n  }\n\n  if (exit) exit(node, ancestors, state);\n}\n","import getBindingIdentifiers from \"../retrievers/getBindingIdentifiers.ts\";\nimport type * as t from \"../index.ts\";\n/**\n * Check if the input `node` is a binding identifier.\n */\nexport default function isBinding(\n  node: t.Node,\n  parent: t.Node,\n  grandparent?: t.Node,\n): boolean {\n  if (\n    grandparent &&\n    node.type === \"Identifier\" &&\n    parent.type === \"ObjectProperty\" &&\n    grandparent.type === \"ObjectExpression\"\n  ) {\n    // We need to special-case this, because getBindingIdentifiers\n    // has an ObjectProperty->value entry for destructuring patterns.\n    return false;\n  }\n\n  const keys = getBindingIdentifiers.keys[parent.type];\n  if (keys) {\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const val =\n        // @ts-expect-error key must present in parent\n        parent[key];\n      if (Array.isArray(val)) {\n        if (val.includes(node)) return true;\n      } else {\n        if (val === node) return true;\n      }\n    }\n  }\n\n  return false;\n}\n","import { isVariableDeclaration } from \"./generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if the input `node` is a `let` variable declaration.\n */\nexport default function isLet(node: t.Node | undefined | null): boolean {\n  return isVariableDeclaration(node) && node.kind !== \"var\";\n}\n","import {\n  isClassDeclaration,\n  isFunctionDeclaration,\n} from \"./generated/index.ts\";\nimport isLet from \"./isLet.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if the input `node` is block scoped.\n */\nexport default function isBlockScoped(\n  node: t.Node | null | undefined,\n): boolean {\n  return isFunctionDeclaration(node) || isClassDeclaration(node) || isLet(node);\n}\n","import isType from \"./isType.ts\";\nimport { isIdentifier } from \"./generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if the input `node` is definitely immutable.\n */\nexport default function isImmutable(node: t.Node): boolean {\n  if (isType(node.type, \"Immutable\")) return true;\n\n  if (isIdentifier(node)) {\n    if (node.name === \"undefined\") {\n      // immutable!\n      return true;\n    } else {\n      // no idea...\n      return false;\n    }\n  }\n\n  return false;\n}\n","import { NODE_FIELDS, VISITOR_KEYS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if two nodes are equivalent\n */\nexport default function isNodesEquivalent<T extends Partial<t.Node>>(\n  a: T,\n  b: any,\n): b is T {\n  if (\n    typeof a !== \"object\" ||\n    typeof b !== \"object\" ||\n    a == null ||\n    b == null\n  ) {\n    return a === b;\n  }\n\n  if (a.type !== b.type) {\n    return false;\n  }\n\n  const fields = Object.keys(NODE_FIELDS[a.type!] || a.type);\n  const visitorKeys = VISITOR_KEYS[a.type!];\n\n  for (const field of fields) {\n    const val_a =\n      // @ts-expect-error field must present in a\n      a[field];\n    const val_b = b[field];\n    if (typeof val_a !== typeof val_b) {\n      return false;\n    }\n    if (val_a == null && val_b == null) {\n      continue;\n    } else if (val_a == null || val_b == null) {\n      return false;\n    }\n\n    if (Array.isArray(val_a)) {\n      if (!Array.isArray(val_b)) {\n        return false;\n      }\n      if (val_a.length !== val_b.length) {\n        return false;\n      }\n\n      for (let i = 0; i < val_a.length; i++) {\n        if (!isNodesEquivalent(val_a[i], val_b[i])) {\n          return false;\n        }\n      }\n      continue;\n    }\n\n    if (typeof val_a === \"object\" && !visitorKeys?.includes(field)) {\n      for (const key of Object.keys(val_a)) {\n        if (val_a[key] !== val_b[key]) {\n          return false;\n        }\n      }\n      continue;\n    }\n\n    if (!isNodesEquivalent(val_a, val_b)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type * as t from \"../index.ts\";\n\n/**\n * Check if the input `node` is a reference to a bound variable.\n */\nexport default function isReferenced(\n  node: t.Node | null | undefined,\n  parent: t.Node,\n  grandparent?: t.Node,\n): boolean {\n  switch (parent.type) {\n    // yes: PARENT[NODE]\n    // yes: NODE.child\n    // no: parent.NODE\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n      if (parent.property === node) {\n        return !!parent.computed;\n      }\n      return parent.object === node;\n\n    case \"JSXMemberExpression\":\n      return parent.object === node;\n    // no: let NODE = init;\n    // yes: let id = NODE;\n    case \"VariableDeclarator\":\n      return parent.init === node;\n\n    // yes: () => NODE\n    // no: (NODE) => {}\n    case \"ArrowFunctionExpression\":\n      return parent.body === node;\n\n    // no: class { #NODE; }\n    // no: class { get #NODE() {} }\n    // no: class { #NODE() {} }\n    // no: class { fn() { return this.#NODE; } }\n    case \"PrivateName\":\n      return false;\n\n    // no: class { NODE() {} }\n    // yes: class { [NODE]() {} }\n    // no: class { foo(NODE) {} }\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"ObjectMethod\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return false;\n\n    // yes: { [NODE]: \"\" }\n    // no: { NODE: \"\" }\n    // depends: { NODE }\n    // depends: { key: NODE }\n    case \"ObjectProperty\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      // parent.value === node\n      return grandparent?.type !== \"ObjectPattern\";\n    // no: class { NODE = value; }\n    // yes: class { [NODE] = value; }\n    // yes: class { key = NODE; }\n    case \"ClassProperty\":\n    case \"ClassAccessorProperty\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return true;\n    case \"ClassPrivateProperty\":\n      return parent.key !== node;\n\n    // no: class NODE {}\n    // yes: class Foo extends NODE {}\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      return parent.superClass === node;\n\n    // yes: left = NODE;\n    // no: NODE = right;\n    case \"AssignmentExpression\":\n      return parent.right === node;\n\n    // no: [NODE = foo] = [];\n    // yes: [foo = NODE] = [];\n    case \"AssignmentPattern\":\n      return parent.right === node;\n\n    // no: NODE: for (;;) {}\n    case \"LabeledStatement\":\n      return false;\n\n    // no: try {} catch (NODE) {}\n    case \"CatchClause\":\n      return false;\n\n    // no: function foo(...NODE) {}\n    case \"RestElement\":\n      return false;\n\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n      return false;\n\n    // no: function NODE() {}\n    // no: function foo(NODE) {}\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n      return false;\n\n    // no: export NODE from \"foo\";\n    // no: export * as NODE from \"foo\";\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      return false;\n\n    // no: export { foo as NODE };\n    // yes: export { NODE as foo };\n    // no: export { NODE as foo } from \"foo\";\n    case \"ExportSpecifier\":\n      // @ts-expect-error todo(flow->ts): Property 'source' does not exist on type 'AnyTypeAnnotation'.\n      if (grandparent?.source) {\n        return false;\n      }\n      return parent.local === node;\n\n    // no: import NODE from \"foo\";\n    // no: import * as NODE from \"foo\";\n    // no: import { NODE as foo } from \"foo\";\n    // no: import { foo as NODE } from \"foo\";\n    // no: import NODE from \"bar\";\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n      return false;\n\n    // no: import \"foo\" assert { NODE: \"json\" }\n    case \"ImportAttribute\":\n      return false;\n\n    // no: <div NODE=\"foo\" />\n    case \"JSXAttribute\":\n      return false;\n\n    // no: [NODE] = [];\n    // no: ({ NODE }) = [];\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      return false;\n\n    // no: new.NODE\n    // no: NODE.target\n    case \"MetaProperty\":\n      return false;\n\n    // yes: type X = { someProperty: NODE }\n    // no: type X = { NODE: OtherType }\n    case \"ObjectTypeProperty\":\n      return parent.key !== node;\n\n    // yes: enum X { Foo = NODE }\n    // no: enum X { NODE }\n    case \"TSEnumMember\":\n      return parent.id !== node;\n\n    // yes: { [NODE]: value }\n    // no: { NODE: value }\n    case \"TSPropertySignature\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n\n      return true;\n  }\n\n  return true;\n}\n","import {\n  isFunction,\n  isCatchClause,\n  isBlockStatement,\n  isScopable,\n  isPattern,\n} from \"./generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if the input `node` is a scope.\n */\nexport default function isScope(\n  node: t.Node | null | undefined,\n  parent: t.Node,\n): boolean {\n  // If a BlockStatement is an immediate descendent of a Function/CatchClause, it must be in the body.\n  // Hence we skipped the parentKey === \"params\" check\n  if (isBlockStatement(node) && (isFunction(parent) || isCatchClause(parent))) {\n    return false;\n  }\n\n  // If a Pattern is an immediate descendent of a Function/CatchClause, it must be in the params.\n  // Hence we skipped the parentKey === \"params\" check\n  if (isPattern(node) && (isFunction(parent) || isCatchClause(parent))) {\n    return true;\n  }\n\n  return isScopable(node);\n}\n","import { isIdentifier, isImportDefaultSpecifier } from \"./generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if the input `specifier` is a `default` import or export.\n */\nexport default function isSpecifierDefault(\n  specifier: t.ModuleSpecifier,\n): boolean {\n  return (\n    isImportDefaultSpecifier(specifier) ||\n    // @ts-expect-error todo(flow->ts): stricter type for specifier\n    isIdentifier(specifier.imported || specifier.exported, {\n      name: \"default\",\n    })\n  );\n}\n","import isValidIdentifier from \"./isValidIdentifier.ts\";\n\nconst RESERVED_WORDS_ES3_ONLY = new Set<string>([\n  \"abstract\",\n  \"boolean\",\n  \"byte\",\n  \"char\",\n  \"double\",\n  \"enum\",\n  \"final\",\n  \"float\",\n  \"goto\",\n  \"implements\",\n  \"int\",\n  \"interface\",\n  \"long\",\n  \"native\",\n  \"package\",\n  \"private\",\n  \"protected\",\n  \"public\",\n  \"short\",\n  \"static\",\n  \"synchronized\",\n  \"throws\",\n  \"transient\",\n  \"volatile\",\n]);\n\n/**\n * Check if the input `name` is a valid identifier name according to the ES3 specification.\n *\n * Additional ES3 reserved words are\n */\nexport default function isValidES3Identifier(name: string): boolean {\n  return isValidIdentifier(name) && !RESERVED_WORDS_ES3_ONLY.has(name);\n}\n","import { isVariableDeclaration } from \"./generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if the input `node` is a variable declaration.\n */\nexport default function isVar(node: t.Node | null | undefined): boolean {\n  return isVariableDeclaration(node) && node.kind === \"var\";\n}\n","import isReactComponent from \"./validators/react/isReactComponent.ts\";\nimport isCompatTag from \"./validators/react/isCompatTag.ts\";\nimport buildChildren from \"./builders/react/buildChildren.ts\";\n\n// asserts\nexport { default as assertNode } from \"./asserts/assertNode.ts\";\nexport * from \"./asserts/generated/index.ts\";\n\n// builders\nexport { default as createTypeAnnotationBasedOnTypeof } from \"./builders/flow/createTypeAnnotationBasedOnTypeof.ts\";\n/** @deprecated use createFlowUnionType instead */\nexport { default as createUnionTypeAnnotation } from \"./builders/flow/createFlowUnionType.ts\";\nexport { default as createFlowUnionType } from \"./builders/flow/createFlowUnionType.ts\";\nexport { default as createTSUnionType } from \"./builders/typescript/createTSUnionType.ts\";\nexport * from \"./builders/productions.ts\";\nexport * from \"./builders/generated/index.ts\"; // includes AST types\n\n// clone\nexport { default as cloneNode } from \"./clone/cloneNode.ts\";\nexport { default as clone } from \"./clone/clone.ts\";\nexport { default as cloneDeep } from \"./clone/cloneDeep.ts\";\nexport { default as cloneDeepWithoutLoc } from \"./clone/cloneDeepWithoutLoc.ts\";\nexport { default as cloneWithoutLoc } from \"./clone/cloneWithoutLoc.ts\";\n\n// comments\nexport { default as addComment } from \"./comments/addComment.ts\";\nexport { default as addComments } from \"./comments/addComments.ts\";\nexport { default as inheritInnerComments } from \"./comments/inheritInnerComments.ts\";\nexport { default as inheritLeadingComments } from \"./comments/inheritLeadingComments.ts\";\nexport { default as inheritsComments } from \"./comments/inheritsComments.ts\";\nexport { default as inheritTrailingComments } from \"./comments/inheritTrailingComments.ts\";\nexport { default as removeComments } from \"./comments/removeComments.ts\";\n\n// constants\nexport * from \"./constants/generated/index.ts\";\nexport * from \"./constants/index.ts\";\n\n// converters\nexport { default as ensureBlock } from \"./converters/ensureBlock.ts\";\nexport { default as toBindingIdentifierName } from \"./converters/toBindingIdentifierName.ts\";\nexport { default as toBlock } from \"./converters/toBlock.ts\";\nexport { default as toComputedKey } from \"./converters/toComputedKey.ts\";\nexport { default as toExpression } from \"./converters/toExpression.ts\";\nexport { default as toIdentifier } from \"./converters/toIdentifier.ts\";\nexport { default as toKeyAlias } from \"./converters/toKeyAlias.ts\";\nexport { default as toStatement } from \"./converters/toStatement.ts\";\nexport { default as valueToNode } from \"./converters/valueToNode.ts\";\n\n// definitions\nexport * from \"./definitions/index.ts\";\n\n// modifications\nexport { default as appendToMemberExpression } from \"./modifications/appendToMemberExpression.ts\";\nexport { default as inherits } from \"./modifications/inherits.ts\";\nexport { default as prependToMemberExpression } from \"./modifications/prependToMemberExpression.ts\";\nexport {\n  default as removeProperties,\n  type Options as RemovePropertiesOptions,\n} from \"./modifications/removeProperties.ts\";\nexport { default as removePropertiesDeep } from \"./modifications/removePropertiesDeep.ts\";\nexport { default as removeTypeDuplicates } from \"./modifications/flow/removeTypeDuplicates.ts\";\n\n// retrievers\nexport { default as getAssignmentIdentifiers } from \"./retrievers/getAssignmentIdentifiers.ts\";\nexport { default as getBindingIdentifiers } from \"./retrievers/getBindingIdentifiers.ts\";\nexport { default as getOuterBindingIdentifiers } from \"./retrievers/getOuterBindingIdentifiers.ts\";\nexport { default as getFunctionName } from \"./retrievers/getFunctionName.ts\";\n\n// traverse\nexport { default as traverse } from \"./traverse/traverse.ts\";\nexport * from \"./traverse/traverse.ts\";\nexport { default as traverseFast } from \"./traverse/traverseFast.ts\";\n\n// utils\nexport { default as shallowEqual } from \"./utils/shallowEqual.ts\";\n\n// validators\nexport { default as is } from \"./validators/is.ts\";\nexport { default as isBinding } from \"./validators/isBinding.ts\";\nexport { default as isBlockScoped } from \"./validators/isBlockScoped.ts\";\nexport { default as isImmutable } from \"./validators/isImmutable.ts\";\nexport { default as isLet } from \"./validators/isLet.ts\";\nexport { default as isNode } from \"./validators/isNode.ts\";\nexport { default as isNodesEquivalent } from \"./validators/isNodesEquivalent.ts\";\nexport { default as isPlaceholderType } from \"./validators/isPlaceholderType.ts\";\nexport { default as isReferenced } from \"./validators/isReferenced.ts\";\nexport { default as isScope } from \"./validators/isScope.ts\";\nexport { default as isSpecifierDefault } from \"./validators/isSpecifierDefault.ts\";\nexport { default as isType } from \"./validators/isType.ts\";\nexport { default as isValidES3Identifier } from \"./validators/isValidES3Identifier.ts\";\nexport { default as isValidIdentifier } from \"./validators/isValidIdentifier.ts\";\nexport { default as isVar } from \"./validators/isVar.ts\";\nexport { default as matchesPattern } from \"./validators/matchesPattern.ts\";\nexport { default as validate } from \"./validators/validate.ts\";\nexport { default as buildMatchMemberExpression } from \"./validators/buildMatchMemberExpression.ts\";\nexport * from \"./validators/generated/index.ts\";\n\n// react\nexport const react = {\n  isReactComponent,\n  isCompatTag,\n  buildChildren,\n};\n\n// this is used by @babel/traverse to warn about deprecated visitors\nexport { default as __internal__deprecationWarning } from \"./utils/deprecationWarning.ts\";\n"],"names":["shallowEqual","actual","expected","keys","Object","key","warnings","Set","deprecationWarning","oldName","newName","prefix","cacheKey","has","add","internal","trace","captureShortStackTrace","console","warn","skip","length","stackTraceLimit","prepareStackTrace","Error","stackTrace","err","stack","shortStackTrace","slice","test","getFileName","map","frame","join","isArrayExpression","node","opts","type","isAssignmentExpression","isBinaryExpression","isInterpreterDirective","isDirective","isDirectiveLiteral","isBlockStatement","isBreakStatement","isCallExpression","isCatchClause","isConditionalExpression","isContinueStatement","isDebuggerStatement","isDoWhileStatement","isEmptyStatement","isExpressionStatement","isFile","isForInStatement","isForStatement","isFunctionDeclaration","isFunctionExpression","isIdentifier","isIfStatement","isLabeledStatement","isStringLiteral","isNumericLiteral","isNullLiteral","isBooleanLiteral","isRegExpLiteral","isLogicalExpression","isMemberExpression","isNewExpression","isProgram","isObjectExpression","isObjectMethod","isObjectProperty","isRestElement","isReturnStatement","isSequenceExpression","isParenthesizedExpression","isSwitchCase","isSwitchStatement","isThisExpression","isThrowStatement","isTryStatement","isUnaryExpression","isUpdateExpression","isVariableDeclaration","isVariableDeclarator","isWhileStatement","isWithStatement","isAssignmentPattern","isArrayPattern","isArrowFunctionExpression","isClassBody","isClassExpression","isClassDeclaration","isExportAllDeclaration","isExportDefaultDeclaration","isExportNamedDeclaration","isExportSpecifier","isForOfStatement","isImportDeclaration","isImportDefaultSpecifier","isImportNamespaceSpecifier","isImportSpecifier","isImportExpression","isMetaProperty","isClassMethod","isObjectPattern","isSpreadElement","isSuper","isTaggedTemplateExpression","isTemplateElement","isTemplateLiteral","isYieldExpression","isAwaitExpression","isImport","isBigIntLiteral","isExportNamespaceSpecifier","isOptionalMemberExpression","isOptionalCallExpression","isClassProperty","isClassPrivateProperty","isClassPrivateMethod","isPrivateName","isStaticBlock","isImportAttribute","isAnyTypeAnnotation","isArrayTypeAnnotation","isBooleanTypeAnnotation","isBooleanLiteralTypeAnnotation","isNullLiteralTypeAnnotation","isClassImplements","isDeclareClass","isDeclareFunction","isDeclareInterface","isDeclareModule","isDeclareModuleExports","isDeclareTypeAlias","isDeclareOpaqueType","isDeclareVariable","isDeclareExportDeclaration","isDeclareExportAllDeclaration","isDeclaredPredicate","isExistsTypeAnnotation","isFunctionTypeAnnotation","isFunctionTypeParam","isGenericTypeAnnotation","isInferredPredicate","isInterfaceExtends","isInterfaceDeclaration","isInterfaceTypeAnnotation","isIntersectionTypeAnnotation","isMixedTypeAnnotation","isEmptyTypeAnnotation","isNullableTypeAnnotation","isNumberLiteralTypeAnnotation","isNumberTypeAnnotation","isObjectTypeAnnotation","isObjectTypeInternalSlot","isObjectTypeCallProperty","isObjectTypeIndexer","isObjectTypeProperty","isObjectTypeSpreadProperty","isOpaqueType","isQualifiedTypeIdentifier","isStringLiteralTypeAnnotation","isStringTypeAnnotation","isSymbolTypeAnnotation","isThisTypeAnnotation","isTupleTypeAnnotation","isTypeofTypeAnnotation","isTypeAlias","isTypeAnnotation","isTypeCastExpression","isTypeParameter","isTypeParameterDeclaration","isTypeParameterInstantiation","isUnionTypeAnnotation","isVariance","isVoidTypeAnnotation","isEnumDeclaration","isEnumBooleanBody","isEnumNumberBody","isEnumStringBody","isEnumSymbolBody","isEnumBooleanMember","isEnumNumberMember","isEnumStringMember","isEnumDefaultedMember","isIndexedAccessType","isOptionalIndexedAccessType","isJSXAttribute","isJSXClosingElement","isJSXElement","isJSXEmptyExpression","isJSXExpressionContainer","isJSXSpreadChild","isJSXIdentifier","isJSXMemberExpression","isJSXNamespacedName","isJSXOpeningElement","isJSXSpreadAttribute","isJSXText","isJSXFragment","isJSXOpeningFragment","isJSXClosingFragment","isPlaceholder","isV8IntrinsicIdentifier","isArgumentPlaceholder","isBindExpression","isClassAccessorProperty","isDecorator","isDoExpression","isExportDefaultSpecifier","isModuleExpression","isTopicReference","isVoidPattern","isTSParameterProperty","isTSDeclareFunction","isTSDeclareMethod","isTSQualifiedName","isTSCallSignatureDeclaration","isTSConstructSignatureDeclaration","isTSPropertySignature","isTSMethodSignature","isTSIndexSignature","isTSAnyKeyword","isTSBooleanKeyword","isTSBigIntKeyword","isTSIntrinsicKeyword","isTSNeverKeyword","isTSNullKeyword","isTSNumberKeyword","isTSObjectKeyword","isTSStringKeyword","isTSSymbolKeyword","isTSUndefinedKeyword","isTSUnknownKeyword","isTSVoidKeyword","isTSThisType","isTSFunctionType","isTSConstructorType","isTSTypeReference","isTSTypePredicate","isTSTypeQuery","isTSTypeLiteral","isTSArrayType","isTSTupleType","isTSOptionalType","isTSRestType","isTSNamedTupleMember","isTSUnionType","isTSIntersectionType","isTSConditionalType","isTSInferType","isTSParenthesizedType","isTSTypeOperator","isTSIndexedAccessType","isTSMappedType","isTSTemplateLiteralType","isTSLiteralType","isTSClassImplements","isTSInterfaceHeritage","isTSInterfaceDeclaration","isTSInterfaceBody","isTSTypeAliasDeclaration","isTSInstantiationExpression","isTSAsExpression","isTSSatisfiesExpression","isTSTypeAssertion","isTSEnumBody","isTSEnumDeclaration","isTSEnumMember","isTSModuleDeclaration","isTSModuleBlock","isTSImportType","isTSImportEqualsDeclaration","isTSExternalModuleReference","isTSNonNullExpression","isTSExportAssignment","isTSNamespaceExportDeclaration","isTSTypeAnnotation","isTSTypeParameterInstantiation","isTSTypeParameterDeclaration","isTSTypeParameter","isStandardized","expectedNode","isExpression","isBinary","isScopable","isBlockParent","isBlock","isStatement","isTerminatorless","isCompletionStatement","isConditional","isLoop","isWhile","isExpressionWrapper","isFor","isForXStatement","isFunction","isFunctionParent","isPureish","isDeclaration","isFunctionParameter","isPatternLike","isLVal","isTSEntityName","isLiteral","isUserWhitespacable","isMethod","isObjectMember","isProperty","isUnaryLike","isPattern","isClass","isImportOrExportDeclaration","isExportDeclaration","isModuleSpecifier","isPrivate","isFlow","isFlowType","isFlowBaseAnnotation","isFlowDeclaration","isFlowPredicate","isEnumBody","isEnumMember","isJSX","isMiscellaneous","isAccessor","isTypeScript","isTSTypeElement","isTSType","isTSBaseType","isNumberLiteral","isRegexLiteral","isRestProperty","isSpreadProperty","isModuleDeclaration","isMemberExpressionLike","matchesPattern","member","match","allowPartial","parts","Array","isArray","split","nodes","object","meta","push","property","i","j","value","name","id","buildMatchMemberExpression","isReactComponent","isCompatTag","tagName","isType","nodeType","targetType","ALIAS_KEYS","aliases","FLIPPED_ALIAS_KEYS","includes","isPlaceholderType","placeholderType","PLACEHOLDERS_ALIAS","is","matches","undefined","isValidIdentifier","reserved","isKeyword","isStrictReservedWord","isIdentifierName","STATEMENT_OR_BLOCK_KEYS","FLATTENABLE_KEYS","FOR_INIT_KEYS","COMMENT_KEYS","LOGICAL_OPERATORS","UPDATE_OPERATORS","BOOLEAN_NUMBER_BINARY_OPERATORS","EQUALITY_BINARY_OPERATORS","COMPARISON_BINARY_OPERATORS","BOOLEAN_BINARY_OPERATORS","NUMBER_BINARY_OPERATORS","BINARY_OPERATORS","ASSIGNMENT_OPERATORS","op","BOOLEAN_UNARY_OPERATORS","NUMBER_UNARY_OPERATORS","STRING_UNARY_OPERATORS","UNARY_OPERATORS","INHERIT_KEYS","optional","force","VISITOR_KEYS","NODE_FIELDS","BUILDER_KEYS","DEPRECATED_KEYS","NODE_PARENT_VALIDATIONS","NODE_UNION_SHAPES__PRIVATE","getType","val","validate","validateType","typeNames","assertNodeType","validateOptional","validateDefault","defaultValue","default","validateOptionalType","arrayOf","elementType","chain","assertValueType","assertEach","arrayOfType","validateArrayOfType","callback","childValidator","validateChild","validator","subKey","toString","v","each","assertOneOf","values","TypeError","JSON","stringify","oneOf","allExpandedTypes","types","expandedTypes","set","valType","oneOfNodeTypes","assertNodeOrValueType","primitiveType","oneOfNodeOrValueTypes","assertShape","shape","errors","validateField","error","message","shapeOf","assertOptionalChainStart","current","callee","fns","args","fn","chainOf","validTypeOpts","validFieldKeys","store","defineAliasedType","defined","inherits","additional","filter","a","unshift","defineType","visitor","builder","fields","getOwnPropertyNames","field","def","deprecated","k","deprecatedAlias","concat","forEach","alias","unionShape","classMethodOrPropertyUnionShapeCommon","allowPrivateName","discriminator","shapes","properties","elements","operator","assign","identifier","pattern","left","right","expression","inOp","directives","body","label","arguments","typeArguments","param","consequent","alternate","program","comments","tokens","init","update","functionCommon","params","generator","async","functionTypeAnnotationCommon","returnType","typeParameters","functionDeclarationCommon","declare","predicate","parent","patternLikeCommon","typeAnnotation","decorators","exec","parentKey","nonComp","computed","imported","isReservedWord","Number","isFinite","flags","invalid","normal","sourceType","interpreter","kind","shorthand","argument","listKey","index","expressions","discriminant","cases","block","handler","finalizer","declarations","withoutInit","constOrLetOrVar","usingOrAwaitUsing","parentIsForX","decl","definite","superClass","implements","mixins","abstract","importAttributes","attributes","source","exportKind","declaration","specifiers","sourced","sourceless","local","exported","lval","await","module","phase","importKind","options","classMethodOrPropertyCommon","accessibility","static","override","classMethodOrDeclareMethodCommon","access","tag","quasi","raw","cooked","templateElementCookedValidator","unterminatedCalled","str","firstInvalidLoc","readStringContents","unterminated","strictNumericEscape","invalidEscapeSequence","numericSeparatorInEscapeSequence","unexpectedNumericSeparator","invalidDigit","invalidCodePoint","tail","quasis","delegate","readonly","variance","defineInterfaceishType","extends","supertype","impltype","rest","this","indexers","callProperties","internalSlots","exact","inexact","method","proto","qualification","bound","enumBodyBase","explicitType","hasUnknownMembers","members","objectType","indexType","openingElement","closingElement","children","namespace","selfClosing","openingFragment","closingFragment","PLACEHOLDERS","Declaration","Pattern","PLACEHOLDERS_FLIPPED_ALIAS","hasOwn","bool","tSFunctionTypeAnnotationCommon","parameter","signatureDeclarationCommon","callConstructSignatureDeclaration","namedTypeElementCommon","parameters","tsKeywordTypes","fnOrCtrBase","typeName","parameterName","asserts","exprName","elementTypes","unionOrIntersection","checkType","extendsType","trueType","falseType","typeParameter","constraint","nameType","literal","unaryExpression","unaryOperator","TSTypeExpression","const","initializer","qualifier","moduleReference","in","out","DEPRECATED_ALIASES","ModuleDeclaration","TYPES","validateInternal","maybeNode","_validate","utils","arrayExpression","defs","ArrayExpression","assignmentExpression","AssignmentExpression","binaryExpression","BinaryExpression","interpreterDirective","InterpreterDirective","directive","Directive","directiveLiteral","DirectiveLiteral","blockStatement","BlockStatement","breakStatement","BreakStatement","callExpression","_arguments","CallExpression","catchClause","CatchClause","conditionalExpression","ConditionalExpression","continueStatement","ContinueStatement","debuggerStatement","doWhileStatement","DoWhileStatement","emptyStatement","expressionStatement","ExpressionStatement","file","File","forInStatement","ForInStatement","forStatement","ForStatement","functionDeclaration","FunctionDeclaration","functionExpression","FunctionExpression","Identifier","ifStatement","IfStatement","labeledStatement","LabeledStatement","stringLiteral","StringLiteral","numericLiteral","NumericLiteral","nullLiteral","booleanLiteral","BooleanLiteral","regExpLiteral","RegExpLiteral","logicalExpression","LogicalExpression","memberExpression","MemberExpression","newExpression","NewExpression","Program","objectExpression","ObjectExpression","objectMethod","ObjectMethod","objectProperty","ObjectProperty","restElement","RestElement","returnStatement","ReturnStatement","sequenceExpression","SequenceExpression","parenthesizedExpression","ParenthesizedExpression","switchCase","SwitchCase","switchStatement","SwitchStatement","thisExpression","throwStatement","ThrowStatement","tryStatement","TryStatement","UnaryExpression","updateExpression","UpdateExpression","variableDeclaration","VariableDeclaration","variableDeclarator","VariableDeclarator","whileStatement","WhileStatement","withStatement","WithStatement","assignmentPattern","AssignmentPattern","arrayPattern","ArrayPattern","arrowFunctionExpression","ArrowFunctionExpression","classBody","ClassBody","classExpression","ClassExpression","classDeclaration","ClassDeclaration","exportAllDeclaration","ExportAllDeclaration","exportDefaultDeclaration","ExportDefaultDeclaration","exportNamedDeclaration","ExportNamedDeclaration","exportSpecifier","ExportSpecifier","forOfStatement","_await","ForOfStatement","importDeclaration","ImportDeclaration","importDefaultSpecifier","ImportDefaultSpecifier","importNamespaceSpecifier","ImportNamespaceSpecifier","importSpecifier","ImportSpecifier","importExpression","ImportExpression","metaProperty","MetaProperty","classMethod","_static","ClassMethod","objectPattern","ObjectPattern","spreadElement","SpreadElement","_super","taggedTemplateExpression","TaggedTemplateExpression","templateElement","TemplateElement","templateLiteral","TemplateLiteral","yieldExpression","YieldExpression","awaitExpression","AwaitExpression","_import","bigIntLiteral","BigIntLiteral","exportNamespaceSpecifier","ExportNamespaceSpecifier","optionalMemberExpression","OptionalMemberExpression","optionalCallExpression","OptionalCallExpression","classProperty","ClassProperty","classPrivateProperty","ClassPrivateProperty","classPrivateMethod","ClassPrivateMethod","privateName","PrivateName","staticBlock","StaticBlock","importAttribute","ImportAttribute","anyTypeAnnotation","arrayTypeAnnotation","ArrayTypeAnnotation","booleanTypeAnnotation","booleanLiteralTypeAnnotation","BooleanLiteralTypeAnnotation","nullLiteralTypeAnnotation","classImplements","ClassImplements","declareClass","_extends","DeclareClass","declareFunction","DeclareFunction","declareInterface","DeclareInterface","declareModule","DeclareModule","declareModuleExports","DeclareModuleExports","declareTypeAlias","DeclareTypeAlias","declareOpaqueType","DeclareOpaqueType","declareVariable","DeclareVariable","declareExportDeclaration","DeclareExportDeclaration","declareExportAllDeclaration","DeclareExportAllDeclaration","declaredPredicate","DeclaredPredicate","existsTypeAnnotation","functionTypeAnnotation","FunctionTypeAnnotation","functionTypeParam","FunctionTypeParam","genericTypeAnnotation","GenericTypeAnnotation","inferredPredicate","interfaceExtends","InterfaceExtends","interfaceDeclaration","InterfaceDeclaration","interfaceTypeAnnotation","InterfaceTypeAnnotation","intersectionTypeAnnotation","IntersectionTypeAnnotation","mixedTypeAnnotation","emptyTypeAnnotation","nullableTypeAnnotation","NullableTypeAnnotation","numberLiteralTypeAnnotation","NumberLiteralTypeAnnotation","numberTypeAnnotation","objectTypeAnnotation","ObjectTypeAnnotation","objectTypeInternalSlot","ObjectTypeInternalSlot","objectTypeCallProperty","ObjectTypeCallProperty","objectTypeIndexer","ObjectTypeIndexer","objectTypeProperty","ObjectTypeProperty","objectTypeSpreadProperty","ObjectTypeSpreadProperty","opaqueType","OpaqueType","qualifiedTypeIdentifier","QualifiedTypeIdentifier","stringLiteralTypeAnnotation","StringLiteralTypeAnnotation","stringTypeAnnotation","symbolTypeAnnotation","thisTypeAnnotation","tupleTypeAnnotation","TupleTypeAnnotation","typeofTypeAnnotation","TypeofTypeAnnotation","typeAlias","TypeAlias","TypeAnnotation","typeCastExpression","TypeCastExpression","_default","TypeParameter","typeParameterDeclaration","TypeParameterDeclaration","typeParameterInstantiation","TypeParameterInstantiation","unionTypeAnnotation","UnionTypeAnnotation","Variance","voidTypeAnnotation","enumDeclaration","EnumDeclaration","enumBooleanBody","EnumBooleanBody","enumNumberBody","EnumNumberBody","enumStringBody","EnumStringBody","enumSymbolBody","EnumSymbolBody","enumBooleanMember","EnumBooleanMember","enumNumberMember","EnumNumberMember","enumStringMember","EnumStringMember","enumDefaultedMember","EnumDefaultedMember","indexedAccessType","IndexedAccessType","optionalIndexedAccessType","OptionalIndexedAccessType","jsxAttribute","JSXAttribute","jsxClosingElement","JSXClosingElement","jsxElement","JSXElement","jsxEmptyExpression","jsxExpressionContainer","JSXExpressionContainer","jsxSpreadChild","JSXSpreadChild","jsxIdentifier","JSXIdentifier","jsxMemberExpression","JSXMemberExpression","jsxNamespacedName","JSXNamespacedName","jsxOpeningElement","JSXOpeningElement","jsxSpreadAttribute","JSXSpreadAttribute","jsxText","JSXText","jsxFragment","JSXFragment","jsxOpeningFragment","jsxClosingFragment","placeholder","Placeholder","v8IntrinsicIdentifier","V8IntrinsicIdentifier","argumentPlaceholder","bindExpression","BindExpression","classAccessorProperty","ClassAccessorProperty","decorator","Decorator","doExpression","DoExpression","exportDefaultSpecifier","ExportDefaultSpecifier","moduleExpression","ModuleExpression","topicReference","voidPattern","tsParameterProperty","TSParameterProperty","tsDeclareFunction","TSDeclareFunction","tsDeclareMethod","TSDeclareMethod","tsQualifiedName","TSQualifiedName","tsCallSignatureDeclaration","TSCallSignatureDeclaration","tsConstructSignatureDeclaration","TSConstructSignatureDeclaration","tsPropertySignature","TSPropertySignature","tsMethodSignature","TSMethodSignature","tsIndexSignature","TSIndexSignature","tsAnyKeyword","tsBooleanKeyword","tsBigIntKeyword","tsIntrinsicKeyword","tsNeverKeyword","tsNullKeyword","tsNumberKeyword","tsObjectKeyword","tsStringKeyword","tsSymbolKeyword","tsUndefinedKeyword","tsUnknownKeyword","tsVoidKeyword","tsThisType","tsFunctionType","TSFunctionType","tsConstructorType","TSConstructorType","tsTypeReference","TSTypeReference","tsTypePredicate","TSTypePredicate","tsTypeQuery","TSTypeQuery","tsTypeLiteral","TSTypeLiteral","tsArrayType","TSArrayType","tsTupleType","TSTupleType","tsOptionalType","TSOptionalType","tsRestType","TSRestType","tsNamedTupleMember","TSNamedTupleMember","tsUnionType","TSUnionType","tsIntersectionType","TSIntersectionType","tsConditionalType","TSConditionalType","tsInferType","TSInferType","tsParenthesizedType","TSParenthesizedType","tsTypeOperator","TSTypeOperator","tsIndexedAccessType","TSIndexedAccessType","tsMappedType","TSMappedType","tsTemplateLiteralType","TSTemplateLiteralType","tsLiteralType","TSLiteralType","tsClassImplements","TSClassImplements","tsInterfaceHeritage","TSInterfaceHeritage","tsInterfaceDeclaration","TSInterfaceDeclaration","tsInterfaceBody","TSInterfaceBody","tsTypeAliasDeclaration","TSTypeAliasDeclaration","tsInstantiationExpression","TSInstantiationExpression","tsAsExpression","TSAsExpression","tsSatisfiesExpression","TSSatisfiesExpression","tsTypeAssertion","TSTypeAssertion","tsEnumBody","TSEnumBody","tsEnumDeclaration","TSEnumDeclaration","tsEnumMember","TSEnumMember","tsModuleDeclaration","TSModuleDeclaration","tsModuleBlock","TSModuleBlock","tsImportType","TSImportType","tsImportEqualsDeclaration","TSImportEqualsDeclaration","tsExternalModuleReference","TSExternalModuleReference","tsNonNullExpression","TSNonNullExpression","tsExportAssignment","TSExportAssignment","tsNamespaceExportDeclaration","TSNamespaceExportDeclaration","tsTypeAnnotation","TSTypeAnnotation","tsTypeParameterInstantiation","TSTypeParameterInstantiation","tsTypeParameterDeclaration","TSTypeParameterDeclaration","tsTypeParameter","TSTypeParameter","NumberLiteral","RegexLiteral","RestProperty","SpreadProperty","lowercase","replace","x","toUpperCase","b","DebuggerStatement","EmptyStatement","NullLiteral","ThisExpression","Super","Import","AnyTypeAnnotation","BooleanTypeAnnotation","NullLiteralTypeAnnotation","ExistsTypeAnnotation","InferredPredicate","MixedTypeAnnotation","EmptyTypeAnnotation","NumberTypeAnnotation","StringTypeAnnotation","SymbolTypeAnnotation","ThisTypeAnnotation","VoidTypeAnnotation","JSXEmptyExpression","JSXOpeningFragment","JSXClosingFragment","ArgumentPlaceholder","TopicReference","VoidPattern","TSAnyKeyword","TSBooleanKeyword","TSBigIntKeyword","TSIntrinsicKeyword","TSNeverKeyword","TSNullKeyword","TSNumberKeyword","TSObjectKeyword","TSStringKeyword","TSSymbolKeyword","TSUndefinedKeyword","TSUnknownKeyword","TSVoidKeyword","TSThisType","cleanJSXElementLiteralChild","child","lines","lastNonEmptyLine","line","isFirstLine","isLastLine","isLastNonEmptyLine","trimmedLine","buildChildren","isNode","assertNode","assert","assertArrayExpression","assertAssignmentExpression","assertBinaryExpression","assertInterpreterDirective","assertDirective","assertDirectiveLiteral","assertBlockStatement","assertBreakStatement","assertCallExpression","assertCatchClause","assertConditionalExpression","assertContinueStatement","assertDebuggerStatement","assertDoWhileStatement","assertEmptyStatement","assertExpressionStatement","assertFile","assertForInStatement","assertForStatement","assertFunctionDeclaration","assertFunctionExpression","assertIdentifier","assertIfStatement","assertLabeledStatement","assertStringLiteral","assertNumericLiteral","assertNullLiteral","assertBooleanLiteral","assertRegExpLiteral","assertLogicalExpression","assertMemberExpression","assertNewExpression","assertProgram","assertObjectExpression","assertObjectMethod","assertObjectProperty","assertRestElement","assertReturnStatement","assertSequenceExpression","assertParenthesizedExpression","assertSwitchCase","assertSwitchStatement","assertThisExpression","assertThrowStatement","assertTryStatement","assertUnaryExpression","assertUpdateExpression","assertVariableDeclaration","assertVariableDeclarator","assertWhileStatement","assertWithStatement","assertAssignmentPattern","assertArrayPattern","assertArrowFunctionExpression","assertClassBody","assertClassExpression","assertClassDeclaration","assertExportAllDeclaration","assertExportDefaultDeclaration","assertExportNamedDeclaration","assertExportSpecifier","assertForOfStatement","assertImportDeclaration","assertImportDefaultSpecifier","assertImportNamespaceSpecifier","assertImportSpecifier","assertImportExpression","assertMetaProperty","assertClassMethod","assertObjectPattern","assertSpreadElement","assertSuper","assertTaggedTemplateExpression","assertTemplateElement","assertTemplateLiteral","assertYieldExpression","assertAwaitExpression","assertImport","assertBigIntLiteral","assertExportNamespaceSpecifier","assertOptionalMemberExpression","assertOptionalCallExpression","assertClassProperty","assertClassPrivateProperty","assertClassPrivateMethod","assertPrivateName","assertStaticBlock","assertImportAttribute","assertAnyTypeAnnotation","assertArrayTypeAnnotation","assertBooleanTypeAnnotation","assertBooleanLiteralTypeAnnotation","assertNullLiteralTypeAnnotation","assertClassImplements","assertDeclareClass","assertDeclareFunction","assertDeclareInterface","assertDeclareModule","assertDeclareModuleExports","assertDeclareTypeAlias","assertDeclareOpaqueType","assertDeclareVariable","assertDeclareExportDeclaration","assertDeclareExportAllDeclaration","assertDeclaredPredicate","assertExistsTypeAnnotation","assertFunctionTypeAnnotation","assertFunctionTypeParam","assertGenericTypeAnnotation","assertInferredPredicate","assertInterfaceExtends","assertInterfaceDeclaration","assertInterfaceTypeAnnotation","assertIntersectionTypeAnnotation","assertMixedTypeAnnotation","assertEmptyTypeAnnotation","assertNullableTypeAnnotation","assertNumberLiteralTypeAnnotation","assertNumberTypeAnnotation","assertObjectTypeAnnotation","assertObjectTypeInternalSlot","assertObjectTypeCallProperty","assertObjectTypeIndexer","assertObjectTypeProperty","assertObjectTypeSpreadProperty","assertOpaqueType","assertQualifiedTypeIdentifier","assertStringLiteralTypeAnnotation","assertStringTypeAnnotation","assertSymbolTypeAnnotation","assertThisTypeAnnotation","assertTupleTypeAnnotation","assertTypeofTypeAnnotation","assertTypeAlias","assertTypeAnnotation","assertTypeCastExpression","assertTypeParameter","assertTypeParameterDeclaration","assertTypeParameterInstantiation","assertUnionTypeAnnotation","assertVariance","assertVoidTypeAnnotation","assertEnumDeclaration","assertEnumBooleanBody","assertEnumNumberBody","assertEnumStringBody","assertEnumSymbolBody","assertEnumBooleanMember","assertEnumNumberMember","assertEnumStringMember","assertEnumDefaultedMember","assertIndexedAccessType","assertOptionalIndexedAccessType","assertJSXAttribute","assertJSXClosingElement","assertJSXElement","assertJSXEmptyExpression","assertJSXExpressionContainer","assertJSXSpreadChild","assertJSXIdentifier","assertJSXMemberExpression","assertJSXNamespacedName","assertJSXOpeningElement","assertJSXSpreadAttribute","assertJSXText","assertJSXFragment","assertJSXOpeningFragment","assertJSXClosingFragment","assertPlaceholder","assertV8IntrinsicIdentifier","assertArgumentPlaceholder","assertBindExpression","assertClassAccessorProperty","assertDecorator","assertDoExpression","assertExportDefaultSpecifier","assertModuleExpression","assertTopicReference","assertVoidPattern","assertTSParameterProperty","assertTSDeclareFunction","assertTSDeclareMethod","assertTSQualifiedName","assertTSCallSignatureDeclaration","assertTSConstructSignatureDeclaration","assertTSPropertySignature","assertTSMethodSignature","assertTSIndexSignature","assertTSAnyKeyword","assertTSBooleanKeyword","assertTSBigIntKeyword","assertTSIntrinsicKeyword","assertTSNeverKeyword","assertTSNullKeyword","assertTSNumberKeyword","assertTSObjectKeyword","assertTSStringKeyword","assertTSSymbolKeyword","assertTSUndefinedKeyword","assertTSUnknownKeyword","assertTSVoidKeyword","assertTSThisType","assertTSFunctionType","assertTSConstructorType","assertTSTypeReference","assertTSTypePredicate","assertTSTypeQuery","assertTSTypeLiteral","assertTSArrayType","assertTSTupleType","assertTSOptionalType","assertTSRestType","assertTSNamedTupleMember","assertTSUnionType","assertTSIntersectionType","assertTSConditionalType","assertTSInferType","assertTSParenthesizedType","assertTSTypeOperator","assertTSIndexedAccessType","assertTSMappedType","assertTSTemplateLiteralType","assertTSLiteralType","assertTSClassImplements","assertTSInterfaceHeritage","assertTSInterfaceDeclaration","assertTSInterfaceBody","assertTSTypeAliasDeclaration","assertTSInstantiationExpression","assertTSAsExpression","assertTSSatisfiesExpression","assertTSTypeAssertion","assertTSEnumBody","assertTSEnumDeclaration","assertTSEnumMember","assertTSModuleDeclaration","assertTSModuleBlock","assertTSImportType","assertTSImportEqualsDeclaration","assertTSExternalModuleReference","assertTSNonNullExpression","assertTSExportAssignment","assertTSNamespaceExportDeclaration","assertTSTypeAnnotation","assertTSTypeParameterInstantiation","assertTSTypeParameterDeclaration","assertTSTypeParameter","assertStandardized","assertExpression","assertBinary","assertScopable","assertBlockParent","assertBlock","assertStatement","assertTerminatorless","assertCompletionStatement","assertConditional","assertLoop","assertWhile","assertExpressionWrapper","assertFor","assertForXStatement","assertFunction","assertFunctionParent","assertPureish","assertDeclaration","assertFunctionParameter","assertPatternLike","assertLVal","assertTSEntityName","assertLiteral","assertImmutable","assertUserWhitespacable","assertMethod","assertObjectMember","assertProperty","assertUnaryLike","assertPattern","assertClass","assertImportOrExportDeclaration","assertExportDeclaration","assertModuleSpecifier","assertPrivate","assertFlow","assertFlowType","assertFlowBaseAnnotation","assertFlowDeclaration","assertFlowPredicate","assertEnumBody","assertEnumMember","assertJSX","assertMiscellaneous","assertAccessor","assertTypeScript","assertTSTypeElement","assertTSType","assertTSBaseType","assertNumberLiteral","assertRegexLiteral","assertRestProperty","assertSpreadProperty","assertModuleDeclaration","createTypeAnnotationBasedOnTypeof","getQualifiedName","removeTypeDuplicates","nodesIn","from","generics","Map","bases","typeGroups","existing","get","baseType","genericName","createFlowUnionType","flattened","typeArgumentsKey","existingTypeArguments","createTSUnionType","typeAnnotations","buildUndefinedNode","cloneIfNode","obj","deep","withoutLoc","commentsCache","cloneNodeInternal","cloneIfNodeOrArray","cloneNode","newNode","maybeCloneComments","loc","leadingComments","innerComments","trailingComments","extra","comment","cache","ret","clone","cloneDeep","cloneDeepWithoutLoc","cloneWithoutLoc","addComments","addComment","content","inherit","Boolean","inheritInnerComments","inheritLeadingComments","inheritTrailingComments","inheritsComments","removeComments","STANDARDIZED_TYPES","EXPRESSION_TYPES","BINARY_TYPES","SCOPABLE_TYPES","BLOCKPARENT_TYPES","BLOCK_TYPES","STATEMENT_TYPES","TERMINATORLESS_TYPES","COMPLETIONSTATEMENT_TYPES","CONDITIONAL_TYPES","LOOP_TYPES","WHILE_TYPES","EXPRESSIONWRAPPER_TYPES","FOR_TYPES","FORXSTATEMENT_TYPES","FUNCTION_TYPES","FUNCTIONPARENT_TYPES","PUREISH_TYPES","DECLARATION_TYPES","FUNCTIONPARAMETER_TYPES","PATTERNLIKE_TYPES","LVAL_TYPES","TSENTITYNAME_TYPES","LITERAL_TYPES","IMMUTABLE_TYPES","USERWHITESPACABLE_TYPES","METHOD_TYPES","OBJECTMEMBER_TYPES","PROPERTY_TYPES","UNARYLIKE_TYPES","PATTERN_TYPES","CLASS_TYPES","IMPORTOREXPORTDECLARATION_TYPES","EXPORTDECLARATION_TYPES","MODULESPECIFIER_TYPES","PRIVATE_TYPES","FLOW_TYPES","FLOWTYPE_TYPES","FLOWBASEANNOTATION_TYPES","FLOWDECLARATION_TYPES","FLOWPREDICATE_TYPES","ENUMBODY_TYPES","ENUMMEMBER_TYPES","JSX_TYPES","MISCELLANEOUS_TYPES","ACCESSOR_TYPES","TYPESCRIPT_TYPES","TSTYPEELEMENT_TYPES","TSTYPE_TYPES","TSBASETYPE_TYPES","MODULEDECLARATION_TYPES","toBlock","blockNodes","ensureBlock","result","toIdentifier","input","c","isIdentifierChar","codePointAt","toBindingIdentifierName","toComputedKey","toExpression","_skip","Symbol","_stop","traverseFast","enter","subNode","stop","CLEAR_KEYS","CLEAR_KEYS_PLUS_COMMENTS","removeProperties","preserveComments","startsWith","symbols","getOwnPropertySymbols","sym","removePropertiesDeep","tree","toKeyAlias","increment","uid","MAX_SAFE_INTEGER","toStatement","ignore","mustHaveId","newType","objectToString","Function","call","bind","prototype","isRegExp","isPlainObject","getPrototypeOf","valueToNode","Math","abs","numerator","isNaN","props","nodeKey","appendToMemberExpression","append","prependToMemberExpression","prepend","getAssignmentIdentifiers","search","ids","create","pop","getBindingIdentifiers","duplicates","outerOnly","newBindingsOnly","shift","_ids","getOuterBindingIdentifiers","getNameFromLiteralId","String","getObjectMemberKey","getFunctionName","originalNode","traverse","handlers","state","exit","traverseSimpleImpl","ancestors","isBinding","grandparent","isLet","isBlockScoped","isImmutable","isNodesEquivalent","visitorKeys","val_a","val_b","isReferenced","isScope","isSpecifierDefault","specifier","RESERVED_WORDS_ES3_ONLY","isValidES3Identifier","isVar","react"],"mappings":"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"}
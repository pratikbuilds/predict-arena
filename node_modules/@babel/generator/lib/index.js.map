{"version":3,"file":"index.js","sources":["../src/source-map.ts","../src/buffer.ts","../src/node/parentheses.ts","../src/generators/template-literals.ts","../src/generators/expressions.ts","../src/generators/statements.ts","../src/generators/methods.ts","../src/generators/typescript.ts","../src/generators/modules.ts","../src/generators/types.ts","../src/generators/flow.ts","../src/generators/classes.ts","../src/generators/base.ts","../src/generators/jsx.ts","../src/nodes.ts","../src/node/index.ts","../src/token-map.ts","../src/printer.ts","../src/index.ts"],"sourcesContent":["import {\n  GenMapping,\n  maybeAddMapping,\n  setSourceContent,\n  allMappings,\n  toEncodedMap,\n  toDecodedMap,\n} from \"@jridgewell/gen-mapping\";\n\nimport type {\n  EncodedSourceMap,\n  DecodedSourceMap,\n  Mapping,\n} from \"@jridgewell/gen-mapping\";\n\nimport type {\n  InvalidOriginalMapping,\n  OriginalMapping,\n  SourceMapInput,\n} from \"@jridgewell/trace-mapping\";\nimport { originalPositionFor, TraceMap } from \"@jridgewell/trace-mapping\";\n\n/**\n * Build a sourcemap.\n */\n\nexport default class SourceMap {\n  private _map: GenMapping;\n  private _rawMappings: Mapping[] | undefined;\n  private _sourceFileName: string | undefined;\n\n  // Any real line is > 0, so init to 0 is fine.\n  private _lastGenLine = 0;\n  private _lastSourceLine = 0;\n\n  // Source columns can be 0, but we only check in unison with sourceLine, which\n  // inits to an impossible value. So init to 0 is fine.\n  private _lastSourceColumn = 0;\n\n  public _inputMap: TraceMap | null = null;\n\n  constructor(\n    opts: {\n      sourceFileName?: string;\n      sourceRoot?: string;\n      inputSourceMap?: SourceMapInput;\n    },\n    code: string | Record<string, string> | null | undefined,\n  ) {\n    const map = (this._map = new GenMapping({ sourceRoot: opts.sourceRoot }));\n    this._sourceFileName = opts.sourceFileName?.replace(/\\\\/g, \"/\");\n    this._rawMappings = undefined;\n\n    if (opts.inputSourceMap) {\n      this._inputMap = new TraceMap(opts.inputSourceMap);\n      const resolvedSources = this._inputMap.resolvedSources;\n      if (resolvedSources.length) {\n        for (let i = 0; i < resolvedSources.length; i++) {\n          setSourceContent(\n            map,\n            resolvedSources[i],\n            // @ts-expect-error FIXME: this._inputMap.sourcesContent?.[i] may be undefined, which is not acceptable by setSourceContent\n            this._inputMap.sourcesContent?.[i],\n          );\n        }\n      }\n    }\n\n    if (typeof code === \"string\" && !opts.inputSourceMap) {\n      setSourceContent(map, this._sourceFileName!, code);\n    } else if (typeof code === \"object\") {\n      for (const sourceFileName of Object.keys(code!)) {\n        setSourceContent(\n          map,\n          sourceFileName.replace(/\\\\/g, \"/\"),\n          code![sourceFileName],\n        );\n      }\n    }\n  }\n\n  /**\n   * Get the sourcemap.\n   */\n  get(): EncodedSourceMap {\n    return toEncodedMap(this._map);\n  }\n\n  getDecoded(): DecodedSourceMap {\n    return toDecodedMap(this._map);\n  }\n\n  getRawMappings(): Mapping[] {\n    return (this._rawMappings ||= allMappings(this._map));\n  }\n\n  /**\n   * Mark the current generated position with a source position. May also be passed null line/column\n   * values to insert a mapping to nothing.\n   */\n\n  mark(\n    generated: { line: number; column: number },\n    line?: number,\n    column?: number,\n    identifierName?: string | null,\n    identifierNamePos?: { line: number; column: number },\n    filename?: string | null,\n  ) {\n    this._rawMappings = undefined;\n\n    let originalMapping: OriginalMapping | InvalidOriginalMapping | undefined;\n\n    if (line != null) {\n      if (this._inputMap) {\n        // This is the lookup for this mark\n        originalMapping = originalPositionFor(this._inputMap, {\n          line,\n          column: column!,\n        });\n\n        // If the we found a name, nothing else needs to be done\n        // Maybe we're marking a `(` and the input map already had a name attached there,\n        // or we're marking a `(` and the sourcemap spanned a `foo(`,\n        // or we're marking an identifier, etc.\n        if (!originalMapping.name && identifierNamePos) {\n          // We're trying to mark a `(` (as that's the only thing that provides\n          // an identifierNamePos currently), and we the AST had an identifier attached.\n          // Lookup it's original name.\n          const originalIdentifierMapping = originalPositionFor(\n            this._inputMap,\n            identifierNamePos,\n          );\n          if (originalIdentifierMapping.name) {\n            identifierName = originalIdentifierMapping.name;\n          }\n        }\n      } else {\n        originalMapping = {\n          name: null,\n          source: filename?.replace(/\\\\/g, \"/\") || this._sourceFileName!,\n          line: line,\n          column: column!,\n        };\n      }\n    }\n\n    // @ts-expect-error FIXME: original cannot be InvalidOriginalMapping\n    maybeAddMapping(this._map, {\n      name: identifierName,\n      generated,\n      source: originalMapping?.source,\n      original: originalMapping,\n    });\n  }\n}\n","import type SourceMap from \"./source-map.ts\";\nimport type { SourceLocation } from \"@babel/types\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charcodes from \"charcodes\";\n\nexport type Loc = SourceLocation;\nexport type Pos = SourceLocation[\"start\"];\n\ntype SourcePosition = {\n  line: number | undefined;\n  column: number | undefined;\n  identifierName: string | undefined;\n  identifierNamePos: Pos | undefined;\n  filename: string | undefined;\n};\n\nconst spaceIndents: string[] = [];\nfor (let i = 0; i < 32; i++) {\n  spaceIndents.push(\" \".repeat(i * 2));\n}\n\nexport default class Buffer {\n  constructor(map: SourceMap | null, indentChar: string) {\n    this._map = map;\n    this._indentChar = indentChar;\n  }\n\n  _map: SourceMap | null = null;\n  _buf = \"\";\n  _str = \"\";\n  _appendCount = 0;\n  _last = 0;\n  _canMarkIdName = true;\n  _indentChar = \"\";\n  _queuedChar: typeof charcodes.space | typeof charcodes.semicolon | 0 = 0;\n\n  _position = {\n    line: 1,\n    column: 0,\n  };\n  _sourcePosition: SourcePosition = {\n    identifierName: undefined,\n    identifierNamePos: undefined,\n    line: undefined,\n    column: undefined,\n    filename: undefined,\n  };\n\n  /**\n   * Get the final string output from the buffer, along with the sourcemap if one exists.\n   */\n\n  get() {\n    const { _map, _last } = this;\n    if (this._queuedChar !== charcodes.space) {\n      this._flush();\n    }\n\n    // Whatever trim is used here should not execute a regex against the\n    // source string since it may be arbitrarily large after all transformations\n    const code =\n      _last === charcodes.lineFeed\n        ? (this._buf + this._str).trimRight()\n        : this._buf + this._str;\n\n    // Creating objects with getters is expensive.\n    if (_map === null) {\n      return {\n        code: code,\n        decodedMap: undefined,\n        map: null,\n        rawMappings: undefined,\n      };\n    }\n\n    const result = {\n      code: code,\n      // Decoded sourcemap is free to generate.\n      decodedMap: _map.getDecoded(),\n      // Used as a marker for backwards compatibility. We moved input map merging\n      // into the generator. We cannot merge the input map a second time, so the\n      // presence of this field tells us we've already done the work.\n      get __mergedMap() {\n        return this.map;\n      },\n      // Encoding the sourcemap is moderately CPU expensive.\n      get map() {\n        const resultMap = _map.get();\n        result.map = resultMap;\n        return resultMap;\n      },\n      set map(value) {\n        Object.defineProperty(result, \"map\", { value, writable: true });\n      },\n      // Retrieving the raw mappings is very memory intensive.\n      get rawMappings() {\n        const mappings = _map.getRawMappings();\n        result.rawMappings = mappings;\n        return mappings;\n      },\n      set rawMappings(value) {\n        Object.defineProperty(result, \"rawMappings\", { value, writable: true });\n      },\n    };\n\n    return result;\n  }\n\n  /**\n   * Add a string to the buffer that cannot be reverted.\n   */\n\n  append(str: string, maybeNewline: boolean): void {\n    this._flush();\n    this._append(str, maybeNewline);\n  }\n\n  appendChar(char: number): void {\n    this._flush();\n    this._appendChar(char, 1, true);\n  }\n\n  /**\n   * Add a string to the buffer than can be reverted.\n   */\n  queue(char: typeof charcodes.space | typeof charcodes.semicolon): void {\n    this._flush();\n    this._queuedChar = char;\n  }\n\n  _flush(): void {\n    const queuedChar = this._queuedChar;\n    if (queuedChar !== 0) {\n      this._appendChar(queuedChar, 1, true);\n      this._queuedChar = 0;\n    }\n  }\n\n  _appendChar(char: number, repeat: number, useSourcePos: boolean): void {\n    this._last = char;\n\n    if (char === -1) {\n      const indent =\n        repeat > 64\n          ? this._indentChar.repeat(repeat)\n          : spaceIndents[repeat / 2];\n      this._str += indent;\n    } else {\n      this._str +=\n        repeat > 1\n          ? String.fromCharCode(char).repeat(repeat)\n          : String.fromCharCode(char);\n    }\n\n    const isSpace = char === charcodes.space;\n    const position = this._position;\n    if (char !== charcodes.lineFeed) {\n      if (this._map) {\n        const sourcePos = this._sourcePosition;\n        if (useSourcePos && sourcePos) {\n          this._map.mark(\n            position,\n            sourcePos.line,\n            sourcePos.column,\n            isSpace ? undefined : sourcePos.identifierName,\n            isSpace ? undefined : sourcePos.identifierNamePos,\n            sourcePos.filename,\n          );\n\n          if (!isSpace && this._canMarkIdName) {\n            sourcePos.identifierName = undefined;\n            sourcePos.identifierNamePos = undefined;\n          }\n        } else {\n          this._map.mark(position);\n        }\n      }\n\n      position.column += repeat;\n    } else {\n      position.line++;\n      position.column = 0;\n    }\n  }\n\n  _append(str: string, maybeNewline: boolean): void {\n    const len = str.length;\n    const position = this._position;\n    const sourcePos = this._sourcePosition;\n\n    this._last = -1; /* LAST_CHAR_KINDS.NORMAL */\n\n    if (++this._appendCount > 4096) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n      +this._str; // Unexplainable huge performance boost. Ref: https://github.com/davidmarkclements/flatstr License: MIT\n      this._buf += this._str;\n      this._str = str;\n      this._appendCount = 0;\n    } else {\n      this._str += str;\n    }\n\n    const hasMap = this._map !== null;\n\n    if (!maybeNewline && !hasMap) {\n      position.column += len;\n      return;\n    }\n\n    const { column, identifierName, identifierNamePos, filename } = sourcePos;\n    let line = sourcePos.line;\n\n    if (\n      (identifierName != null || identifierNamePos != null) &&\n      this._canMarkIdName\n    ) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n\n    // Search for newline chars. We search only for `\\n`, since both `\\r` and\n    // `\\r\\n` are normalized to `\\n` during parse. We exclude `\\u2028` and\n    // `\\u2029` for performance reasons, they're so uncommon that it's probably\n    // ok. It's also unclear how other sourcemap utilities handle them...\n    let i = str.indexOf(\"\\n\");\n    let last = 0;\n\n    // If the string starts with a newline char, then adding a mark is redundant.\n    // This catches both \"no newlines\" and \"newline after several chars\".\n    if (hasMap && i !== 0) {\n      this._map!.mark(\n        position,\n        line,\n        column,\n        identifierName,\n        identifierNamePos,\n        filename,\n      );\n    }\n\n    // Now, find each remaining newline char in the string.\n    while (i !== -1) {\n      position.line++;\n      position.column = 0;\n      last = i + 1;\n\n      // We mark the start of each line, which happens directly after this newline char\n      // unless this is the last char.\n      // When manually adding multi-line content (such as a comment), `line` will be `undefined`.\n      if (last < len && line !== undefined) {\n        line++;\n        if (hasMap) {\n          this._map!.mark(position, line, 0, undefined, undefined, filename);\n        }\n      }\n      i = str.indexOf(\"\\n\", last);\n    }\n    position.column += len - last;\n  }\n\n  removeLastSemicolon(): void {\n    if (this._queuedChar === charcodes.semicolon) {\n      this._queuedChar = 0;\n    }\n  }\n\n  getLastChar(checkQueue?: boolean): number {\n    if (!checkQueue) {\n      return this._last;\n    }\n    const queuedChar = this._queuedChar;\n    return queuedChar !== 0 ? queuedChar : this._last;\n  }\n\n  /**\n   * This will only detect at most 1 newline after a call to `flush()`,\n   * but this has not been found so far, and an accurate count can be achieved if needed later.\n   */\n  getNewlineCount(): number {\n    return this._queuedChar === 0 && this._last === charcodes.lineFeed ? 1 : 0;\n  }\n\n  hasContent(): boolean {\n    return this._last !== 0 /*|| this._queuedChar !== 0*/;\n  }\n\n  /**\n   * Certain sourcemap usecases expect mappings to be more accurate than\n   * Babel's generic sourcemap handling allows. For now, we special-case\n   * identifiers to allow for the primary cases to work.\n   * The goal of this line is to ensure that the map output from Babel will\n   * have an exact range on identifiers in the output code. Without this\n   * line, Babel would potentially include some number of trailing tokens\n   * that are printed after the identifier, but before another location has\n   * been assigned.\n   * This allows tooling like Rollup and Webpack to more accurately perform\n   * their own transformations. Most importantly, this allows the import/export\n   * transformations performed by those tools to loose less information when\n   * applying their own transformations on top of the code and map results\n   * generated by Babel itself.\n   *\n   * The primary example of this is the snippet:\n   *\n   *   import mod from \"mod\";\n   *   mod();\n   *\n   * With this line, there will be one mapping range over \"mod\" and another\n   * over \"();\", where previously it would have been a single mapping.\n   */\n  exactSource(loc: Loc, cb: () => void) {\n    if (!this._map) {\n      cb();\n      return;\n    }\n\n    this.source(\"start\", loc);\n    const identifierName = loc.identifierName;\n    const sourcePos = this._sourcePosition;\n    if (identifierName != null) {\n      this._canMarkIdName = false;\n      sourcePos.identifierName = identifierName;\n    }\n    cb();\n\n    if (identifierName != null) {\n      this._canMarkIdName = true;\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n    this.source(\"end\", loc);\n  }\n\n  /**\n   * Sets a given position as the current source location so generated code after this call\n   * will be given this position in the sourcemap.\n   */\n\n  source(prop: \"start\" | \"end\", loc: Loc): void {\n    if (!this._map) return;\n\n    // Since this is called extremely often, we reuse the same _sourcePosition\n    // object for the whole lifetime of the buffer.\n    this._normalizePosition(prop, loc, 0);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc,\n    columnOffset: number,\n  ): void {\n    if (!this._map) return;\n\n    this._normalizePosition(prop, loc, columnOffset);\n  }\n\n  _normalizePosition(prop: \"start\" | \"end\", loc: Loc, columnOffset: number) {\n    this._flush();\n\n    const pos = loc[prop];\n    const target = this._sourcePosition;\n\n    if (pos) {\n      target.line = pos.line;\n      // TODO: Fix https://github.com/babel/babel/issues/15712 in downstream\n      target.column = Math.max(pos.column + columnOffset, 0);\n      target.filename = loc.filename;\n    }\n  }\n\n  getCurrentColumn(): number {\n    return this._position.column + (this._queuedChar ? 1 : 0);\n  }\n\n  getCurrentLine(): number {\n    return this._position.line;\n  }\n}\n","import {\n  isMemberExpression,\n  isOptionalMemberExpression,\n  isYieldExpression,\n  isStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nimport { TokenContext } from \"./index.ts\";\n\nconst PRECEDENCE = new Map([\n  [\"||\", 0],\n  [\"??\", 1],\n  [\"&&\", 2],\n  [\"|\", 3],\n  [\"^\", 4],\n  [\"&\", 5],\n  [\"==\", 6],\n  [\"===\", 6],\n  [\"!=\", 6],\n  [\"!==\", 6],\n  [\"<\", 7],\n  [\">\", 7],\n  [\"<=\", 7],\n  [\">=\", 7],\n  [\"in\", 7],\n  [\"instanceof\", 7],\n  [\">>\", 8],\n  [\"<<\", 8],\n  [\">>>\", 8],\n  [\"+\", 9],\n  [\"-\", 9],\n  [\"*\", 10],\n  [\"/\", 10],\n  [\"%\", 10],\n  [\"**\", 11],\n]);\n\nfunction isTSTypeExpression(nodeId: number) {\n  return (\n    nodeId === __node(\"TSAsExpression\") ||\n    nodeId === __node(\"TSSatisfiesExpression\") ||\n    nodeId === __node(\"TSTypeAssertion\")\n  );\n}\n\nconst isClassExtendsClause = (\n  node: t.Node,\n  parent: any,\n  parentId: number,\n): parent is t.Class => {\n  return (\n    (parentId === __node(\"ClassDeclaration\") ||\n      parentId === __node(\"ClassExpression\")) &&\n    parent.superClass === node\n  );\n};\n\nconst hasPostfixPart = (node: t.Node, parent: any, parentId: number) => {\n  switch (parentId) {\n    case __node(\"MemberExpression\"):\n    case __node(\"OptionalMemberExpression\"):\n      return parent.object === node;\n    case __node(\"CallExpression\"):\n    case __node(\"OptionalCallExpression\"):\n    case __node(\"NewExpression\"):\n      return parent.callee === node;\n    case __node(\"TaggedTemplateExpression\"):\n      return parent.tag === node;\n    case __node(\"TSNonNullExpression\"):\n      return true;\n  }\n\n  return false;\n};\n\nexport function NullableTypeAnnotation(\n  node: t.NullableTypeAnnotation,\n  parent: any,\n  parentId: number,\n): boolean {\n  return parentId === __node(\"ArrayTypeAnnotation\");\n}\n\nexport function FunctionTypeAnnotation(\n  node: t.FunctionTypeAnnotation,\n  parent: any,\n  parentId: number,\n  tokenContext: number,\n): boolean {\n  return (\n    // (() => A) | (() => B)\n    parentId === __node(\"UnionTypeAnnotation\") ||\n    // (() => A) & (() => B)\n    parentId === __node(\"IntersectionTypeAnnotation\") ||\n    // (() => A)[]\n    parentId === __node(\"ArrayTypeAnnotation\") ||\n    (tokenContext & TokenContext.arrowFlowReturnType) > 0\n  );\n}\n\nexport function UpdateExpression(\n  node: t.UpdateExpression,\n  parent: any,\n  parentId: number,\n): boolean {\n  return (\n    hasPostfixPart(node, parent, parentId) ||\n    isClassExtendsClause(node, parent, parentId)\n  );\n}\n\nfunction needsParenBeforeExpressionBrace(tokenContext: number) {\n  return (\n    (tokenContext &\n      (TokenContext.expressionStatement | TokenContext.arrowBody)) >\n    0\n  );\n}\n\nexport function ObjectExpression(\n  node: t.ObjectExpression,\n  parent: any,\n  parentId: number,\n  tokenContext: number,\n): boolean {\n  return needsParenBeforeExpressionBrace(tokenContext);\n}\n\nexport function DoExpression(\n  node: t.DoExpression,\n  parent: any,\n  parentId: number,\n  tokenContext: number,\n): boolean {\n  // `async do` can start an expression statement\n  return (tokenContext & TokenContext.expressionStatement) > 0 && !node.async;\n}\n\nconst enum BinaryLikeType {\n  Binary = 0,\n  Logical = 1,\n  TypeScript = 2,\n}\n\nfunction BinaryLike(\n  node: t.Binary | t.TSAsExpression | t.TSSatisfiesExpression,\n  parent: any,\n  parentId: number,\n  nodeType: BinaryLikeType,\n): boolean {\n  if (isClassExtendsClause(node, parent, parentId)) {\n    return true;\n  }\n\n  if (\n    hasPostfixPart(node, parent, parentId) ||\n    parentId === __node(\"UnaryExpression\") ||\n    parentId === __node(\"SpreadElement\") ||\n    parentId === __node(\"AwaitExpression\")\n  ) {\n    return true;\n  }\n  let parentPos: number | undefined;\n  switch (parentId) {\n    case __node(\"BinaryExpression\"):\n    case __node(\"LogicalExpression\"):\n      parentPos = PRECEDENCE.get(parent.operator);\n      break;\n    case __node(\"TSAsExpression\"):\n    case __node(\"TSSatisfiesExpression\"):\n      parentPos = 7; /* in */\n  }\n  if (parentPos !== undefined) {\n    const nodePos =\n      nodeType === BinaryLikeType.TypeScript\n        ? 7 /* in */\n        : PRECEDENCE.get((node as t.Binary).operator)!;\n    if (parentPos > nodePos) return true;\n    if (\n      parentPos === nodePos &&\n      parentId === __node(\"BinaryExpression\") &&\n      (nodePos === 11 /* ** */ ? parent.left === node : parent.right === node)\n    ) {\n      return true;\n    }\n    if (\n      nodeType === BinaryLikeType.Logical &&\n      parentId === __node(\"LogicalExpression\") &&\n      // 1: ??\n      ((nodePos === 1 && parentPos !== 1) || (parentPos === 1 && nodePos !== 1))\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function UnionTypeAnnotation(\n  node: t.UnionTypeAnnotation | t.IntersectionTypeAnnotation,\n  parent: any,\n  parentId: number,\n): boolean {\n  switch (parentId) {\n    case __node(\"ArrayTypeAnnotation\"):\n    case __node(\"NullableTypeAnnotation\"):\n    case __node(\"IntersectionTypeAnnotation\"):\n    case __node(\"UnionTypeAnnotation\"):\n      return true;\n  }\n  return false;\n}\n\nexport { UnionTypeAnnotation as IntersectionTypeAnnotation };\n\nexport function OptionalIndexedAccessType(\n  node: t.OptionalIndexedAccessType,\n  parent: any,\n  parentId: number,\n): boolean {\n  return parentId === __node(\"IndexedAccessType\") && parent.objectType === node;\n}\n\nexport function TSAsExpression(\n  node: t.TSAsExpression | t.TSSatisfiesExpression,\n  parent: any,\n  parentId: number,\n): boolean {\n  if (\n    (parentId === __node(\"AssignmentExpression\") ||\n      parentId === __node(\"AssignmentPattern\")) &&\n    parent.left === node\n  ) {\n    return true;\n  }\n  if (\n    parentId === __node(\"BinaryExpression\") &&\n    (parent.operator === \"|\" || parent.operator === \"&\") &&\n    node === parent.left\n  ) {\n    return true;\n  }\n  return BinaryLike(node, parent, parentId, BinaryLikeType.TypeScript);\n}\n\nexport { TSAsExpression as TSSatisfiesExpression };\n\nexport { UnaryLike as TSTypeAssertion };\n\nexport function TSConditionalType(\n  node: t.TSConditionalType,\n  parent: any,\n  parentId: number,\n): boolean {\n  switch (parentId) {\n    case __node(\"TSArrayType\"):\n    case __node(\"TSOptionalType\"):\n    case __node(\"TSTypeOperator\"):\n    // for `infer K extends (L extends M ? M : ...)`\n    // fallthrough\n    case __node(\"TSTypeParameter\"):\n    case __node(\"TSIntersectionType\"):\n    case __node(\"TSUnionType\"):\n      return true;\n    case __node(\"TSIndexedAccessType\"):\n      return parent.objectType === node;\n    case __node(\"TSConditionalType\"):\n      return parent.checkType === node || parent.extendsType === node;\n  }\n  return false;\n}\n\nexport function TSUnionType(\n  node: t.TSUnionType | t.TSFunctionType,\n  parent: any,\n  parentId: number,\n): boolean {\n  switch (parentId) {\n    case __node(\"TSIntersectionType\"):\n    case __node(\"TSTypeOperator\"):\n    case __node(\"TSArrayType\"):\n    case __node(\"TSOptionalType\"):\n      return true;\n    case __node(\"TSIndexedAccessType\"):\n      return parent.objectType === node;\n  }\n  return false;\n}\n\nexport function TSIntersectionType(\n  node: t.TSUnionType,\n  parent: any,\n  parentId: number,\n): boolean {\n  return (\n    parentId === __node(\"TSTypeOperator\") ||\n    TSTypeOperator(node, parent, parentId)\n  );\n}\n\nexport function TSInferType(\n  node: t.TSInferType,\n  parent: any,\n  parentId: number,\n): boolean {\n  if (TSTypeOperator(node, parent, parentId)) {\n    return true;\n  }\n  if (\n    (parentId === __node(\"TSIntersectionType\") ||\n      parentId === __node(\"TSUnionType\")) &&\n    node.typeParameter.constraint != null\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function TSTypeOperator(\n  node: t.TSTypeOperator | t.TSUnionType | t.TSInferType,\n  parent: any,\n  parentId: number,\n): boolean {\n  switch (parentId) {\n    case __node(\"TSArrayType\"):\n    case __node(\"TSOptionalType\"):\n      return true;\n    case __node(\"TSIndexedAccessType\"):\n      if (parent.objectType === node) {\n        return true;\n      }\n  }\n  return false;\n}\n\nexport function TSInstantiationExpression(\n  node: t.TSInstantiationExpression,\n  parent: any,\n  parentId: number,\n) {\n  switch (parentId) {\n    case __node(\"CallExpression\"):\n    case __node(\"OptionalCallExpression\"):\n    case __node(\"NewExpression\"):\n    case __node(\"TSInstantiationExpression\"):\n      return parent.typeArguments != null;\n  }\n\n  return false;\n}\n\nexport function TSFunctionType(\n  node: t.TSFunctionType,\n  parent: any,\n  parentId: number,\n): boolean {\n  if (TSUnionType(node, parent, parentId)) return true;\n\n  return (\n    parentId === __node(\"TSUnionType\") ||\n    (parentId === __node(\"TSConditionalType\") &&\n      (parent.checkType === node || parent.extendsType === node))\n  );\n}\n\nexport { TSFunctionType as TSConstructorType };\n\nexport function BinaryExpression(\n  node: t.BinaryExpression,\n  parent: any,\n  parentId: number,\n  tokenContext: number,\n): boolean {\n  if (BinaryLike(node, parent, parentId, BinaryLikeType.Binary)) return true;\n\n  // for ((1 in []);;);\n  // for (var x = (1 in []) in 2);\n  return (\n    (tokenContext & TokenContext.forInOrInitHeadAccumulate) > 0 &&\n    node.operator === \"in\"\n  );\n}\n\nexport function LogicalExpression(\n  node: t.LogicalExpression,\n  parent: any,\n  parentId: number,\n): boolean {\n  return BinaryLike(node, parent, parentId, BinaryLikeType.Logical);\n}\n\nexport function SequenceExpression(\n  node: t.SequenceExpression,\n  parent: any,\n  parentId: number,\n): boolean {\n  if (\n    parentId === __node(\"SequenceExpression\") ||\n    parentId === __node(\"ParenthesizedExpression\") ||\n    (parentId === __node(\"MemberExpression\") && parent.property === node) ||\n    (parentId === __node(\"OptionalMemberExpression\") &&\n      parent.property === node) ||\n    parentId === __node(\"TemplateLiteral\")\n  ) {\n    return false;\n  }\n  if (parentId === __node(\"ClassDeclaration\")) {\n    return true;\n  }\n  if (parentId === __node(\"ForOfStatement\")) {\n    return parent.right === node;\n  }\n  if (parentId === __node(\"ExportDefaultDeclaration\")) {\n    return true;\n  }\n\n  return !isStatement(parent);\n}\n\nexport function YieldExpression(\n  node: t.YieldExpression,\n  parent: any,\n  parentId: number,\n): boolean {\n  return (\n    parentId === __node(\"BinaryExpression\") ||\n    parentId === __node(\"LogicalExpression\") ||\n    parentId === __node(\"UnaryExpression\") ||\n    parentId === __node(\"SpreadElement\") ||\n    hasPostfixPart(node, parent, parentId) ||\n    (parentId === __node(\"AwaitExpression\") && isYieldExpression(node)) ||\n    (parentId === __node(\"ConditionalExpression\") && node === parent.test) ||\n    isClassExtendsClause(node, parent, parentId) ||\n    isTSTypeExpression(parentId)\n  );\n}\n\nexport { YieldExpression as AwaitExpression };\n\nexport function ClassExpression(\n  node: t.ClassExpression,\n  parent: any,\n  parentId: number,\n  tokenContext: number,\n): boolean {\n  return (\n    (tokenContext &\n      (TokenContext.expressionStatement | TokenContext.exportDefault)) >\n    0\n  );\n}\n\nfunction UnaryLike(\n  node:\n    | t.UnaryLike\n    | t.TSTypeAssertion\n    | t.ArrowFunctionExpression\n    | t.ConditionalExpression\n    | t.AssignmentExpression,\n  parent: any,\n  parentId: number,\n): boolean {\n  return (\n    hasPostfixPart(node, parent, parentId) ||\n    (parentId === __node(\"BinaryExpression\") &&\n      parent.operator === \"**\" &&\n      parent.left === node) ||\n    isClassExtendsClause(node, parent, parentId)\n  );\n}\n\nexport { UnaryLike as UnaryExpression, UnaryLike as SpreadElement };\n\nexport function FunctionExpression(\n  node: t.FunctionExpression,\n  parent: any,\n  parentId: number,\n  tokenContext: number,\n): boolean {\n  return (\n    (tokenContext &\n      (TokenContext.expressionStatement | TokenContext.exportDefault)) >\n    0\n  );\n}\n\nexport function ConditionalExpression(\n  node:\n    | t.ConditionalExpression\n    | t.ArrowFunctionExpression\n    | t.AssignmentExpression,\n  parent: any,\n  parentId: number,\n): boolean {\n  switch (parentId) {\n    case __node(\"UnaryExpression\"):\n    case __node(\"SpreadElement\"):\n    case __node(\"BinaryExpression\"):\n    case __node(\"LogicalExpression\"):\n    case __node(\"AwaitExpression\"):\n      return true;\n    case __node(\"ConditionalExpression\"):\n      if (parent.test === node) {\n        return true;\n      }\n  }\n\n  if (isTSTypeExpression(parentId)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent, parentId);\n}\n\nexport { ConditionalExpression as ArrowFunctionExpression };\n\nexport function OptionalMemberExpression(\n  node: t.OptionalMemberExpression,\n  parent: any,\n  parentId: number,\n): boolean {\n  switch (parentId) {\n    case __node(\"CallExpression\"):\n      return parent.callee === node;\n    case __node(\"MemberExpression\"):\n      return parent.object === node;\n  }\n  return false;\n}\n\nexport { OptionalMemberExpression as OptionalCallExpression };\n\nexport function AssignmentExpression(\n  node: t.AssignmentExpression,\n  parent: any,\n  parentId: number,\n  tokenContext: number,\n): boolean {\n  if (\n    needsParenBeforeExpressionBrace(tokenContext) &&\n    node.left.type === \"ObjectPattern\"\n  ) {\n    return true;\n  }\n  return ConditionalExpression(node, parent, parentId);\n}\n\nexport function Identifier(\n  node: t.Identifier,\n  parent: any,\n  parentId: number,\n  tokenContext: number,\n  getRawIdentifier: (node: t.Identifier) => string,\n): boolean {\n  if (getRawIdentifier && getRawIdentifier(node) !== node.name) {\n    return false;\n  }\n\n  // 13.15.2 AssignmentExpression RS: Evaluation\n  // (fn) = function () {};\n  if (\n    parentId === __node(\"AssignmentExpression\") &&\n    node.extra?.parenthesized &&\n    parent.left === node\n  ) {\n    const rightType = parent.right.type;\n    if (\n      (rightType === \"FunctionExpression\" || rightType === \"ClassExpression\") &&\n      parent.right.id == null\n    ) {\n      return true;\n    }\n  }\n\n  // fast path\n  if (\n    tokenContext & TokenContext.forOfHead ||\n    ((parentId === __node(\"MemberExpression\") ||\n      parentId === __node(\"OptionalMemberExpression\")) &&\n      tokenContext &\n        (TokenContext.expressionStatement |\n          TokenContext.forInitHead |\n          TokenContext.forInHead))\n  ) {\n    // Non-strict code allows the identifier `let`, but it cannot occur as-is in\n    // certain contexts to avoid ambiguity with contextual keyword `let`.\n    if (node.name === \"let\") {\n      // Some contexts only forbid `let [`, so check if the next token would\n      // be the left bracket of a computed member expression.\n      const isFollowedByBracket =\n        isMemberExpression(parent, {\n          object: node,\n          computed: true,\n        }) ||\n        isOptionalMemberExpression(parent, {\n          object: node,\n          computed: true,\n          optional: false,\n        });\n      if (\n        isFollowedByBracket &&\n        tokenContext &\n          (TokenContext.expressionStatement |\n            TokenContext.forInitHead |\n            TokenContext.forInHead)\n      ) {\n        return true;\n      }\n      return (tokenContext & TokenContext.forOfHead) > 0;\n    }\n  }\n\n  // ECMAScript specifically forbids a for-of loop from starting with the\n  // token sequence `for (async of`, because it would be ambiguous with\n  // `for (async of => {};;)`, so we need to add extra parentheses.\n  return (\n    parentId === __node(\"ForOfStatement\") &&\n    parent.left === node &&\n    node.name === \"async\" &&\n    !parent.await\n  );\n}\n","import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function TaggedTemplateExpression(\n  this: Printer,\n  node: t.TaggedTemplateExpression,\n) {\n  this.print(node.tag);\n\n  this.print(node.typeArguments);\n\n  this.print(node.quasi);\n}\n\nexport function TemplateElement(this: Printer) {\n  throw new Error(\"TemplateElement printing is handled in TemplateLiteral\");\n}\n\nexport type TemplateLiteralBase = t.Node & {\n  quasis: t.TemplateElement[];\n};\n\nexport function _printTemplate<T extends t.Node>(\n  this: Printer,\n  node: TemplateLiteralBase,\n  substitutions: T[],\n) {\n  const quasis = node.quasis;\n  let partRaw = \"`\";\n  for (let i = 0; i < quasis.length - 1; i++) {\n    partRaw += quasis[i].value.raw;\n    this.token(partRaw + \"${\", true);\n    this.print(substitutions[i]);\n    partRaw = \"}\";\n  }\n\n  partRaw += quasis[quasis.length - 1].value.raw;\n  this.token(partRaw + \"`\", true);\n}\n\nexport function TemplateLiteral(this: Printer, node: t.TemplateLiteral) {\n  _printTemplate.call(this, node, node.expressions);\n}\n","import type Printer from \"../printer.ts\";\nimport {\n  isCallExpression,\n  isLiteral,\n  isMemberExpression,\n  isNewExpression,\n  isPattern,\n} from \"@babel/types\";\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\nimport type * as t from \"@babel/types\";\nimport { TokenContext } from \"../node/index.ts\";\n\nexport function UnaryExpression(this: Printer, node: t.UnaryExpression) {\n  const { operator } = node;\n  const firstChar = operator.charCodeAt(0);\n  if (firstChar >= charCodes.lowercaseA && firstChar <= charCodes.lowercaseZ) {\n    this.word(operator);\n    this.space();\n  } else {\n    this.tokenChar(firstChar);\n  }\n\n  this.print(node.argument);\n}\n\nexport function DoExpression(this: Printer, node: t.DoExpression) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n  this.word(\"do\");\n  this.space();\n  this.print(node.body);\n}\n\nexport function ParenthesizedExpression(\n  this: Printer,\n  node: t.ParenthesizedExpression,\n) {\n  this.token(\"(\");\n  const oldNoLineTerminatorAfterNode = this.enterDelimited();\n  this.print(node.expression, undefined, true);\n  this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n  this.rightParens(node);\n}\n\nexport function UpdateExpression(this: Printer, node: t.UpdateExpression) {\n  if (node.prefix) {\n    this.token(node.operator, false, 0, true);\n    this.print(node.argument);\n  } else {\n    this.print(node.argument, true);\n    this.token(node.operator, false, 0, true);\n  }\n}\n\nexport function ConditionalExpression(\n  this: Printer,\n  node: t.ConditionalExpression,\n) {\n  this.print(node.test);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.consequent);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.alternate);\n}\n\nexport function NewExpression(\n  this: Printer,\n  node: t.NewExpression,\n  parent: t.Node,\n) {\n  this.word(\"new\");\n  this.space();\n  this.print(node.callee);\n  if (\n    this.format.minified &&\n    node.arguments.length === 0 &&\n    !isCallExpression(parent, { callee: node }) &&\n    !isMemberExpression(parent) &&\n    !isNewExpression(parent)\n  ) {\n    return;\n  }\n\n  this.print(node.typeArguments);\n\n  if (\n    node.arguments.length === 0 &&\n    this.tokenMap &&\n    !this.tokenMap.endMatches(node, \")\")\n  ) {\n    return;\n  }\n\n  this.token(\"(\");\n  const oldNoLineTerminatorAfterNode = this.enterDelimited();\n  this.printList(\n    node.arguments,\n    this.shouldPrintTrailingComma(\")\"),\n    undefined,\n    undefined,\n    undefined,\n    true,\n  );\n  this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n  this.rightParens(node);\n}\n\nexport function SequenceExpression(this: Printer, node: t.SequenceExpression) {\n  this.printList(node.expressions);\n}\n\nexport function ThisExpression(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function Super(this: Printer) {\n  this.word(\"super\");\n}\n\nexport function _shouldPrintDecoratorsBeforeExport(\n  this: Printer,\n  node: t.ExportDeclaration & { declaration: t.ClassDeclaration },\n) {\n  return (\n    typeof node.start === \"number\" && node.start === node.declaration.start\n  );\n}\n\nexport function Decorator(this: Printer, node: t.Decorator) {\n  this.token(\"@\");\n  const { expression } = node;\n  this.print(expression);\n  this.newline();\n}\n\nexport function OptionalMemberExpression(\n  this: Printer,\n  node: t.OptionalMemberExpression,\n) {\n  let { computed } = node;\n  const { optional, property } = node;\n\n  this.print(node.object);\n\n  if (!computed && isMemberExpression(property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  // @ts-expect-error todo(flow->ts) maybe instead of typeof check specific literal types?\n  if (isLiteral(property) && typeof property.value === \"number\") {\n    computed = true;\n  }\n  if (optional) {\n    this.token(\"?.\");\n  }\n\n  if (computed) {\n    this.token(\"[\");\n    this.print(property);\n    this.token(\"]\");\n  } else {\n    if (!optional) {\n      this.token(\".\");\n    }\n    this.print(property);\n  }\n}\n\nexport function OptionalCallExpression(\n  this: Printer,\n  node: t.OptionalCallExpression,\n) {\n  this.print(node.callee);\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  this.print(node.typeArguments);\n\n  this.token(\"(\");\n  const oldNoLineTerminatorAfterNode = this.enterDelimited();\n  this.printList(\n    node.arguments,\n    undefined,\n    undefined,\n    undefined,\n    undefined,\n    true,\n  );\n  this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n  this.rightParens(node);\n}\n\nexport function CallExpression(this: Printer, node: t.CallExpression) {\n  this.print(node.callee);\n\n  this.print(node.typeArguments);\n\n  this.token(\"(\");\n  const oldNoLineTerminatorAfterNode = this.enterDelimited();\n  this.printList(\n    node.arguments,\n    this.shouldPrintTrailingComma(\")\"),\n    undefined,\n    undefined,\n    undefined,\n    true,\n  );\n  this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n  this.rightParens(node);\n}\n\nexport function Import(this: Printer) {\n  this.word(\"import\");\n}\n\nexport function AwaitExpression(this: Printer, node: t.AwaitExpression) {\n  this.word(\"await\");\n  this.space();\n  this.print(node.argument);\n}\n\nexport function YieldExpression(this: Printer, node: t.YieldExpression) {\n  if (node.delegate) {\n    this.word(\"yield\", true);\n    this.token(\"*\");\n    if (node.argument) {\n      this.space();\n      // line terminators are allowed after yield*\n      this.print(node.argument);\n    }\n  } else if (node.argument) {\n    this.word(\"yield\", true);\n    this.space();\n    this.print(node.argument);\n  } else {\n    this.word(\"yield\");\n  }\n}\n\nexport function EmptyStatement(this: Printer) {\n  this.semicolon(true /* force */);\n}\n\nexport function ExpressionStatement(\n  this: Printer,\n  node: t.ExpressionStatement,\n) {\n  this.tokenContext |= TokenContext.expressionStatement;\n  this.print(node.expression);\n  this.semicolon();\n}\n\nexport function AssignmentPattern(this: Printer, node: t.AssignmentPattern) {\n  this.print(node.left);\n  if (node.left.type === \"Identifier\" || isPattern(node.left)) {\n    if (node.left.optional) this.token(\"?\");\n    this.print(node.left.typeAnnotation);\n  }\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right);\n}\n\nexport function AssignmentExpression(\n  this: Printer,\n  node: t.AssignmentExpression | t.LogicalExpression,\n) {\n  this.print(node.left);\n\n  this.space();\n  this.token(node.operator, false, 0, true);\n  this.space();\n\n  this.print(node.right);\n}\n\nexport { AssignmentExpression as LogicalExpression };\n\nexport function BinaryExpression(this: Printer, node: t.BinaryExpression) {\n  this.print(node.left);\n\n  this.space();\n  const { operator } = node;\n  if (operator.charCodeAt(0) === charCodes.lowercaseI) {\n    this.word(operator);\n  } else {\n    this.token(operator, false, 0, true);\n    this.setLastChar(operator.charCodeAt(operator.length - 1));\n  }\n  this.space();\n\n  this.print(node.right);\n}\n\nexport function BindExpression(this: Printer, node: t.BindExpression) {\n  this.print(node.object);\n  this.token(\"::\");\n  this.print(node.callee);\n}\n\nexport function MemberExpression(this: Printer, node: t.MemberExpression) {\n  this.print(node.object);\n\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  let computed = node.computed;\n  // @ts-expect-error todo(flow->ts) maybe use specific literal types\n  if (isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n\n  if (computed) {\n    const oldNoLineTerminatorAfterNode = this.enterDelimited();\n    this.token(\"[\");\n    this.print(node.property, undefined, true);\n    this.token(\"]\");\n    this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n  } else {\n    this.token(\".\");\n    this.print(node.property);\n  }\n}\n\nexport function MetaProperty(this: Printer, node: t.MetaProperty) {\n  this.print(node.meta);\n  this.token(\".\");\n  this.print(node.property);\n}\n\nexport function PrivateName(this: Printer, node: t.PrivateName) {\n  this.token(\"#\");\n  this.print(node.id);\n}\n\nexport function V8IntrinsicIdentifier(\n  this: Printer,\n  node: t.V8IntrinsicIdentifier,\n) {\n  this.token(\"%\");\n  this.word(node.name);\n}\n\nexport function ModuleExpression(this: Printer, node: t.ModuleExpression) {\n  this.word(\"module\", true);\n  this.space();\n  this.token(\"{\");\n  this.indent();\n  const { body } = node;\n  if (body.body.length || body.directives.length) {\n    this.newline();\n  }\n  this.print(body);\n  this.dedent();\n  this.rightBrace(node);\n}\n","import type Printer from \"../printer.ts\";\nimport { isFor, isIfStatement, isStatement, isVoidPattern } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\nimport { TokenContext } from \"../node/index.ts\";\n\nexport function WithStatement(this: Printer, node: t.WithStatement) {\n  this.word(\"with\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.object);\n  this.token(\")\");\n  this.printBlock(node.body);\n}\n\nexport function IfStatement(this: Printer, node: t.IfStatement) {\n  this.word(\"if\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test);\n  this.token(\")\");\n  this.space();\n\n  const needsBlock =\n    node.alternate && isIfStatement(getLastStatement(node.consequent));\n  if (needsBlock) {\n    this.token(\"{\");\n    this.newline();\n    this.indent();\n  }\n\n  this.printAndIndentOnComments(node.consequent);\n\n  if (needsBlock) {\n    this.dedent();\n    this.newline();\n    this.token(\"}\");\n  }\n\n  if (node.alternate) {\n    if (this.endsWith(charCodes.rightCurlyBrace)) this.space();\n    this.word(\"else\");\n    this.space();\n    this.printAndIndentOnComments(node.alternate);\n  }\n}\n\n// Recursively get the last statement.\nfunction getLastStatement(statement: t.Statement): t.Statement {\n  // @ts-expect-error: If statement.body is empty or not a Node, isStatement will return false\n  const { body } = statement;\n  if (isStatement(body) === false) {\n    return statement;\n  }\n\n  return getLastStatement(body);\n}\n\nexport function ForStatement(this: Printer, node: t.ForStatement) {\n  this.word(\"for\");\n  this.space();\n  this.token(\"(\");\n\n  this.tokenContext |=\n    TokenContext.forInitHead | TokenContext.forInOrInitHeadAccumulate;\n  this.print(node.init);\n  this.tokenContext = TokenContext.normal;\n\n  this.token(\";\");\n\n  if (node.test) {\n    this.space();\n    this.print(node.test);\n  }\n  this.tokenChar(charCodes.semicolon, 1);\n\n  if (node.update) {\n    this.space();\n    this.print(node.update);\n  }\n\n  this.token(\")\");\n  this.printBlock(node.body);\n}\n\nexport function WhileStatement(this: Printer, node: t.WhileStatement) {\n  this.word(\"while\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test);\n  this.token(\")\");\n  this.printBlock(node.body);\n}\n\nexport function ForInStatement(this: Printer, node: t.ForInStatement) {\n  this.word(\"for\");\n  this.space();\n  this.noIndentInnerCommentsHere();\n  this.token(\"(\");\n  this.tokenContext |=\n    TokenContext.forInHead | TokenContext.forInOrInitHeadAccumulate;\n  this.print(node.left);\n  this.tokenContext = TokenContext.normal;\n  this.space();\n  this.word(\"in\");\n  this.space();\n  this.print(node.right);\n  this.token(\")\");\n  this.printBlock(node.body);\n}\n\nexport function ForOfStatement(this: Printer, node: t.ForOfStatement) {\n  this.word(\"for\");\n  this.space();\n  if (node.await) {\n    this.word(\"await\");\n    this.space();\n  }\n  this.noIndentInnerCommentsHere();\n  this.token(\"(\");\n  this.tokenContext |= TokenContext.forOfHead;\n  this.print(node.left);\n  this.space();\n  this.word(\"of\");\n  this.space();\n  this.print(node.right);\n  this.token(\")\");\n  this.printBlock(node.body);\n}\n\nexport function DoWhileStatement(this: Printer, node: t.DoWhileStatement) {\n  this.word(\"do\");\n  this.space();\n  this.print(node.body);\n  this.space();\n  this.word(\"while\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test);\n  this.token(\")\");\n  this.semicolon();\n}\n\nfunction printStatementAfterKeyword(\n  printer: Printer,\n  node: t.Node | null | undefined,\n) {\n  if (node) {\n    printer.space();\n    printer.printTerminatorless(node);\n  }\n\n  printer.semicolon();\n}\n\nexport function BreakStatement(this: Printer, node: t.ContinueStatement) {\n  this.word(\"break\");\n  printStatementAfterKeyword(this, node.label);\n}\n\nexport function ContinueStatement(this: Printer, node: t.ContinueStatement) {\n  this.word(\"continue\");\n  printStatementAfterKeyword(this, node.label);\n}\n\nexport function ReturnStatement(this: Printer, node: t.ReturnStatement) {\n  this.word(\"return\");\n  printStatementAfterKeyword(this, node.argument);\n}\n\nexport function ThrowStatement(this: Printer, node: t.ThrowStatement) {\n  this.word(\"throw\");\n  printStatementAfterKeyword(this, node.argument);\n}\n\nexport function LabeledStatement(this: Printer, node: t.LabeledStatement) {\n  this.print(node.label);\n  this.token(\":\");\n  this.space();\n  this.print(node.body);\n}\n\nexport function TryStatement(this: Printer, node: t.TryStatement) {\n  this.word(\"try\");\n  this.space();\n  this.print(node.block);\n  this.space();\n\n  // Esprima bug puts the catch clause in a `handlers` array.\n  // see https://code.google.com/p/esprima/issues/detail?id=433\n  // We run into this from regenerator generated ast.\n  // @ts-expect-error todo(flow->ts) should ast node type be updated to support this?\n  if (node.handlers) {\n    // @ts-expect-error todo(flow->ts) should ast node type be updated to support this?\n    this.print(node.handlers[0]);\n  } else {\n    this.print(node.handler);\n  }\n\n  if (node.finalizer) {\n    this.space();\n    this.word(\"finally\");\n    this.space();\n    this.print(node.finalizer);\n  }\n}\n\nexport function CatchClause(this: Printer, node: t.CatchClause) {\n  this.word(\"catch\");\n  this.space();\n  if (node.param) {\n    this.token(\"(\");\n    this.print(node.param);\n    this.print(node.param.typeAnnotation);\n    this.token(\")\");\n    this.space();\n  }\n  this.print(node.body);\n}\n\nexport function SwitchStatement(this: Printer, node: t.SwitchStatement) {\n  this.word(\"switch\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.discriminant);\n  this.token(\")\");\n  this.space();\n  this.token(\"{\");\n\n  this.printSequence(node.cases, true);\n\n  this.rightBrace(node);\n}\n\nexport function SwitchCase(this: Printer, node: t.SwitchCase) {\n  if (node.test) {\n    this.word(\"case\");\n    this.space();\n    this.print(node.test);\n    this.token(\":\");\n  } else {\n    this.word(\"default\");\n    this.token(\":\");\n  }\n\n  if (node.consequent.length) {\n    this.newline();\n    this.printSequence(node.consequent, true);\n  }\n}\n\nexport function DebuggerStatement(this: Printer) {\n  this.word(\"debugger\");\n  this.semicolon();\n}\n\nfunction commaSeparatorWithNewline(this: Printer, occurrenceCount: number) {\n  this.tokenChar(charCodes.comma, occurrenceCount);\n  this.newline();\n}\n\nexport function VariableDeclaration(\n  this: Printer,\n  node: t.VariableDeclaration,\n  parent: t.Node,\n) {\n  if (node.declare) {\n    // TS\n    this.word(\"declare\");\n    this.space();\n  }\n\n  const { kind } = node;\n  switch (kind) {\n    case \"await using\":\n      this.word(\"await\");\n      this.space();\n    // fallthrough\n    case \"using\":\n      this.word(\"using\", true);\n      break;\n    default:\n      this.word(kind);\n  }\n  this.space();\n\n  let hasInits = false;\n  // don't add whitespace to loop heads\n  if (!isFor(parent)) {\n    for (const declar of node.declarations) {\n      if (declar.init) {\n        // has an init so let's split it up over multiple lines\n        hasInits = true;\n        break;\n      }\n    }\n  }\n\n  //\n  // use a pretty separator when we aren't in compact mode, have initializers and don't have retainLines on\n  // this will format declarations like:\n  //\n  //   let foo = \"bar\", bar = \"foo\";\n  //\n  // into\n  //\n  //   let foo = \"bar\",\n  //       bar = \"foo\";\n  //\n\n  this.printList(\n    node.declarations,\n    undefined,\n    undefined,\n    node.declarations.length > 1,\n    hasInits ? commaSeparatorWithNewline : undefined,\n  );\n\n  if (parent != null) {\n    switch (parent.type) {\n      case \"ForStatement\":\n        if (parent.init === node) {\n          return;\n        }\n        break;\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        if (parent.left === node) {\n          return;\n        }\n    }\n  }\n\n  this.semicolon();\n}\n\nexport function VariableDeclarator(this: Printer, node: t.VariableDeclarator) {\n  this.print(node.id);\n  if (node.definite) this.token(\"!\"); // TS\n\n  if (!isVoidPattern(node.id)) {\n    this.print(node.id.typeAnnotation);\n  }\n\n  if (node.init) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.init);\n  }\n}\n","import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\nimport { isIdentifier, type ParentMaps } from \"@babel/types\";\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\nimport { TokenContext } from \"../node/index.ts\";\n\ntype ParentsOf<T extends t.Node> = ParentMaps[T[\"type\"]];\n\nexport function _params(\n  this: Printer,\n  node: t.Function | t.TSDeclareMethod | t.TSDeclareFunction,\n  noLineTerminator: boolean,\n  idNode?: t.Expression | t.PrivateName | null,\n  parentNode?: ParentsOf<typeof node>,\n) {\n  this.print(node.typeParameters);\n\n  if (idNode !== undefined || parentNode !== undefined) {\n    const nameInfo = _getFuncIdName.call(this, idNode, parentNode);\n    if (nameInfo) {\n      this.sourceIdentifierName(nameInfo.name, nameInfo.pos);\n    }\n  }\n\n  this.token(\"(\");\n  _parameters.call(this, node.params, charCodes.rightParenthesis);\n\n  this.print(node.returnType, noLineTerminator);\n\n  this._noLineTerminator = noLineTerminator;\n}\n\nexport function _parameters(\n  this: Printer,\n  parameters: t.Function[\"params\"],\n  endToken: number,\n) {\n  const oldNoLineTerminatorAfterNode = this.enterDelimited();\n\n  const trailingComma = this.shouldPrintTrailingComma(endToken);\n\n  const paramLength = parameters.length;\n  for (let i = 0; i < paramLength; i++) {\n    _param.call(this, parameters[i]);\n\n    if (trailingComma || i < paramLength - 1) {\n      this.tokenChar(charCodes.comma, i);\n      this.space();\n    }\n  }\n\n  this.tokenChar(endToken);\n  this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n}\n\nexport function _param(\n  this: Printer,\n  parameter: t.Identifier | t.RestElement | t.Pattern | t.TSParameterProperty,\n) {\n  this.printJoin(\n    // @ts-expect-error decorators is not in VoidPattern\n    parameter.decorators,\n    undefined,\n    undefined,\n    undefined,\n    undefined,\n    true,\n  );\n  this.print(parameter, undefined, true);\n  if (\n    // @ts-expect-error optional is not in TSParameterProperty\n    parameter.optional\n  ) {\n    this.token(\"?\"); // TS / flow\n  }\n\n  this.print(\n    // @ts-expect-error typeAnnotation is not in TSParameterProperty\n    parameter.typeAnnotation,\n    undefined,\n    true,\n  ); // TS / flow\n}\n\nexport function _methodHead(this: Printer, node: t.Method | t.TSDeclareMethod) {\n  const kind = node.kind;\n  const key = node.key;\n\n  if (kind === \"get\" || kind === \"set\") {\n    this.word(kind);\n    this.space();\n  }\n\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n\n  if (\n    kind === \"method\" ||\n    // @ts-expect-error Fixme: kind: \"init\" is not defined\n    kind === \"init\"\n  ) {\n    if (node.generator) {\n      this.token(\"*\");\n    }\n  }\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(key);\n    this.token(\"]\");\n  } else {\n    this.print(key);\n  }\n\n  if (\n    // @ts-expect-error optional is not in ObjectMethod\n    node.optional\n  ) {\n    // TS\n    this.token(\"?\");\n  }\n\n  if (this._buf._map) {\n    _params.call(\n      this,\n      node,\n      false,\n      node.computed && node.key.type !== \"StringLiteral\" ? undefined : node.key,\n    );\n  } else {\n    _params.call(this, node, false);\n  }\n}\n\nexport function _predicate(\n  this: Printer,\n  node:\n    | t.FunctionDeclaration\n    | t.FunctionExpression\n    | t.ArrowFunctionExpression,\n  noLineTerminatorAfter?: boolean,\n) {\n  if (node.predicate) {\n    if (!node.returnType) {\n      this.token(\":\");\n    }\n    this.space();\n    this.print(node.predicate, noLineTerminatorAfter);\n  }\n}\n\nexport function _functionHead(\n  this: Printer,\n  node: t.FunctionDeclaration | t.FunctionExpression | t.TSDeclareFunction,\n  parent: ParentsOf<typeof node>,\n  hasPredicate: boolean,\n) {\n  if (node.async) {\n    this.word(\"async\");\n    if (!this.format.preserveFormat) {\n      // We prevent inner comments from being printed here,\n      // so that they are always consistently printed in the\n      // same place regardless of the function type.\n      this._innerCommentsState = 0 /* INNER_COMMENT_STATE.DISALLOWED */;\n    }\n    this.space();\n  }\n  this.word(\"function\");\n  if (node.generator) {\n    if (!this.format.preserveFormat) {\n      // We prevent inner comments from being printed here,\n      // so that they are always consistently printed in the\n      // same place regardless of the function type.\n      this._innerCommentsState = 0 /* INNER_COMMENT_STATE.DISALLOWED */;\n    }\n    this.token(\"*\");\n  }\n\n  this.space();\n  if (node.id) {\n    this.print(node.id);\n  }\n\n  if (this._buf._map) {\n    _params.call(this, node, false, node.id, parent);\n  } else {\n    _params.call(this, node, false);\n  }\n  if (hasPredicate) {\n    _predicate.call(this, node as t.FunctionDeclaration | t.FunctionExpression);\n  }\n}\n\nexport function FunctionExpression(\n  this: Printer,\n  node: t.FunctionExpression,\n  parent: ParentsOf<typeof node>,\n) {\n  _functionHead.call(this, node, parent, true);\n  this.space();\n  this.print(node.body);\n}\n\nexport { FunctionExpression as FunctionDeclaration };\n\nexport function ArrowFunctionExpression(\n  this: Printer,\n  node: t.ArrowFunctionExpression,\n  parent: ParentsOf<typeof node>,\n) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n\n  if (_shouldPrintArrowParamsParens.call(this, node)) {\n    _params.call(\n      this,\n      node,\n      true,\n      undefined,\n      this._buf._map ? parent : undefined,\n    );\n  } else {\n    this.print(node.params[0], true);\n  }\n\n  _predicate.call(this, node, true);\n  this.space();\n  // When printing (x)/*1*/=>{}, we remove the parentheses\n  // and thus there aren't two contiguous inner tokens.\n  // We forcefully print inner comments here.\n  this.printInnerComments();\n  this.token(\"=>\");\n\n  this.space();\n\n  this.tokenContext |= TokenContext.arrowBody;\n  this.print(node.body);\n}\n\n// Try to avoid printing parens in simple cases, but only if we're pretty\n// sure that they aren't needed by type annotations or potential newlines.\nexport function _shouldPrintArrowParamsParens(\n  this: Printer,\n  node: t.ArrowFunctionExpression,\n): boolean {\n  if (node.params.length !== 1) return true;\n\n  if (node.typeParameters || node.returnType || node.predicate) {\n    return true;\n  }\n\n  const firstParam = node.params[0];\n  if (\n    !isIdentifier(firstParam) ||\n    firstParam.typeAnnotation ||\n    firstParam.optional ||\n    // Flow does not support `foo /*: string*/ => {};`\n    firstParam.leadingComments?.length ||\n    firstParam.trailingComments?.length\n  ) {\n    return true;\n  }\n\n  if (this.tokenMap) {\n    if (node.loc == null) return true;\n    if (this.tokenMap.findMatching(node, \"(\") !== null) return true;\n    const arrowToken = this.tokenMap.findMatching(node, \"=>\");\n    if (arrowToken?.loc == null) return true;\n    return arrowToken.loc.start.line !== node.loc.start.line;\n  }\n\n  if (this.format.retainLines) return true;\n\n  return false;\n}\n\nfunction _getFuncIdName(\n  this: Printer,\n  idNode: t.Expression | t.PrivateName,\n  parent: ParentsOf<t.Function | t.TSDeclareMethod | t.TSDeclareFunction>,\n) {\n  let id: t.Expression | t.PrivateName | t.LVal | t.VoidPattern = idNode;\n\n  if (!id && parent) {\n    const parentType = parent.type;\n\n    if (parentType === \"VariableDeclarator\") {\n      id = parent.id;\n    } else if (\n      parentType === \"AssignmentExpression\" ||\n      parentType === \"AssignmentPattern\"\n    ) {\n      id = parent.left;\n    } else if (\n      parentType === \"ObjectProperty\" ||\n      parentType === \"ClassProperty\"\n    ) {\n      if (!parent.computed || parent.key.type === \"StringLiteral\") {\n        id = parent.key;\n      }\n    } else if (\n      parentType === \"ClassPrivateProperty\" ||\n      parentType === \"ClassAccessorProperty\"\n    ) {\n      id = parent.key;\n    }\n  }\n\n  if (!id) return;\n\n  let nameInfo;\n\n  if (id.type === \"Identifier\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: id.loc?.identifierName || id.name,\n    };\n  } else if (id.type === \"PrivateName\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: \"#\" + id.id.name,\n    };\n  } else if (id.type === \"StringLiteral\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: id.value,\n    };\n  }\n\n  return nameInfo;\n}\n","import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\nimport { _functionHead, _param, _parameters } from \"./methods.ts\";\nimport { _classMethodHead } from \"./classes.ts\";\nimport { _printTemplate } from \"./template-literals.ts\";\n\nexport function TSTypeAnnotation(\n  this: Printer,\n  node: t.TSTypeAnnotation,\n  parent: t.Node,\n) {\n  // TODO(@nicolo-ribaudo): investigate not including => in the range\n  // of the return type of an arrow function type\n  this.token(\n    (parent.type === \"TSFunctionType\" || parent.type === \"TSConstructorType\") &&\n      parent.returnType === node\n      ? \"=>\"\n      : \":\",\n  );\n  this.space();\n  // @ts-expect-error todo(flow->ts) can this be removed? `.optional` looks to be not existing property\n  if (node.optional) this.token(\"?\");\n  this.print(node.typeAnnotation);\n}\n\nexport function TSTypeParameterInstantiation(\n  this: Printer,\n  node: t.TSTypeParameterInstantiation,\n  parent: t.Node,\n): void {\n  this.token(\"<\");\n\n  let printTrailingSeparator: boolean | null =\n    parent.type === \"ArrowFunctionExpression\" && node.params.length === 1;\n  if (this.tokenMap && node.start != null && node.end != null) {\n    // Only force the trailing comma for pre-existing nodes if they\n    // already had a comma (either because they were multi-param, or\n    // because they had a trailing comma)\n    printTrailingSeparator &&= !!this.tokenMap.find(node, t =>\n      this.tokenMap!.matchesOriginal(t, \",\"),\n    );\n    // Preserve the trailing comma if it was there before\n    printTrailingSeparator ||= this.shouldPrintTrailingComma(\">\");\n  }\n\n  this.printList(node.params, printTrailingSeparator);\n  this.token(\">\");\n}\n\nexport { TSTypeParameterInstantiation as TSTypeParameterDeclaration };\n\nexport function TSTypeParameter(this: Printer, node: t.TSTypeParameter) {\n  if (node.const) {\n    this.word(\"const\");\n    this.space();\n  }\n\n  if (node.in) {\n    this.word(\"in\");\n    this.space();\n  }\n\n  if (node.out) {\n    this.word(\"out\");\n    this.space();\n  }\n\n  this.word((node.name as unknown as t.Identifier).name);\n\n  if (node.constraint) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.constraint);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default);\n  }\n}\n\nexport function TSParameterProperty(\n  this: Printer,\n  node: t.TSParameterProperty,\n) {\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  _param.call(this, node.parameter);\n}\n\nexport function TSDeclareFunction(\n  this: Printer,\n  node: t.TSDeclareFunction,\n  parent: t.ParentMaps[\"TSDeclareFunction\"],\n) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  _functionHead.call(this, node, parent, false);\n  this.semicolon();\n}\n\nexport function TSDeclareMethod(this: Printer, node: t.TSDeclareMethod) {\n  _classMethodHead.call(this, node);\n  this.semicolon();\n}\n\nexport function TSQualifiedName(this: Printer, node: t.TSQualifiedName) {\n  this.print(node.left);\n  this.token(\".\");\n  this.print(node.right);\n}\n\nexport function TSCallSignatureDeclaration(\n  this: Printer,\n  node: t.TSCallSignatureDeclaration,\n) {\n  tsPrintSignatureDeclarationBase.call(this, node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nfunction maybePrintTrailingCommaOrSemicolon(printer: Printer, node: t.Node) {\n  if (!printer.tokenMap || !node.start || !node.end) {\n    printer.semicolon();\n    return;\n  }\n\n  if (printer.tokenMap.endMatches(node, \",\")) {\n    printer.token(\",\");\n  } else if (printer.tokenMap.endMatches(node, \";\")) {\n    printer.semicolon();\n  }\n}\n\nexport function TSConstructSignatureDeclaration(\n  this: Printer,\n  node: t.TSConstructSignatureDeclaration,\n) {\n  this.word(\"new\");\n  this.space();\n  tsPrintSignatureDeclarationBase.call(this, node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function TSPropertySignature(\n  this: Printer,\n  node: t.TSPropertySignature,\n) {\n  const { readonly } = node;\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  tsPrintPropertyOrMethodName.call(this, node);\n  this.print(node.typeAnnotation);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nfunction tsPrintPropertyOrMethodName(\n  this: Printer,\n  node: t.TSPropertySignature | t.TSMethodSignature,\n) {\n  if (node.computed) {\n    this.token(\"[\");\n  }\n  this.print(node.key);\n  if (node.computed) {\n    this.token(\"]\");\n  }\n  if (node.optional) {\n    this.token(\"?\");\n  }\n}\n\nexport function TSMethodSignature(this: Printer, node: t.TSMethodSignature) {\n  const { kind } = node;\n  if (kind === \"set\" || kind === \"get\") {\n    this.word(kind);\n    this.space();\n  }\n  tsPrintPropertyOrMethodName.call(this, node);\n  tsPrintSignatureDeclarationBase.call(this, node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function TSIndexSignature(this: Printer, node: t.TSIndexSignature) {\n  const { readonly, static: isStatic } = node;\n  if (isStatic) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.token(\"[\");\n  _parameters.call(this, node.parameters, charCodes.rightSquareBracket);\n  this.print(node.typeAnnotation);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function TSAnyKeyword(this: Printer) {\n  this.word(\"any\");\n}\nexport function TSBigIntKeyword(this: Printer) {\n  this.word(\"bigint\");\n}\nexport function TSUnknownKeyword(this: Printer) {\n  this.word(\"unknown\");\n}\nexport function TSNumberKeyword(this: Printer) {\n  this.word(\"number\");\n}\nexport function TSObjectKeyword(this: Printer) {\n  this.word(\"object\");\n}\nexport function TSBooleanKeyword(this: Printer) {\n  this.word(\"boolean\");\n}\nexport function TSStringKeyword(this: Printer) {\n  this.word(\"string\");\n}\nexport function TSSymbolKeyword(this: Printer) {\n  this.word(\"symbol\");\n}\nexport function TSVoidKeyword(this: Printer) {\n  this.word(\"void\");\n}\nexport function TSUndefinedKeyword(this: Printer) {\n  this.word(\"undefined\");\n}\nexport function TSNullKeyword(this: Printer) {\n  this.word(\"null\");\n}\nexport function TSNeverKeyword(this: Printer) {\n  this.word(\"never\");\n}\nexport function TSIntrinsicKeyword(this: Printer) {\n  this.word(\"intrinsic\");\n}\n\nexport function TSThisType(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function TSFunctionType(this: Printer, node: t.TSFunctionType) {\n  tsPrintFunctionOrConstructorType.call(this, node);\n}\n\nexport function TSConstructorType(this: Printer, node: t.TSConstructorType) {\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n  this.word(\"new\");\n  this.space();\n  tsPrintFunctionOrConstructorType.call(this, node);\n}\n\nfunction tsPrintFunctionOrConstructorType(\n  this: Printer,\n  node: t.TSFunctionType | t.TSConstructorType,\n) {\n  const { typeParameters } = node;\n  const parameters = node.params;\n\n  this.print(typeParameters);\n  this.token(\"(\");\n  _parameters.call(this, parameters, charCodes.rightParenthesis);\n  this.space();\n  const returnType = node.returnType;\n\n  this.print(returnType);\n}\n\nexport function TSTypeReference(this: Printer, node: t.TSTypeReference) {\n  const typeArguments = node.typeArguments;\n\n  this.print(node.typeName, !!typeArguments);\n  this.print(typeArguments);\n}\n\nexport function TSTypePredicate(this: Printer, node: t.TSTypePredicate) {\n  if (node.asserts) {\n    this.word(\"asserts\");\n    this.space();\n  }\n  this.print(node.parameterName);\n  if (node.typeAnnotation) {\n    this.space();\n    this.word(\"is\");\n    this.space();\n    this.print(node.typeAnnotation.typeAnnotation);\n  }\n}\n\nexport function TSTypeQuery(this: Printer, node: t.TSTypeQuery) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.exprName);\n\n  const typeArguments = node.typeArguments;\n\n  if (typeArguments) {\n    this.print(typeArguments);\n  }\n}\n\nexport function TSTypeLiteral(this: Printer, node: t.TSTypeLiteral) {\n  printBraced(this, node, () =>\n    this.printJoin(node.members, true, true, undefined, undefined, true),\n  );\n}\n\nexport function TSArrayType(this: Printer, node: t.TSArrayType) {\n  this.print(node.elementType, true);\n\n  this.token(\"[\");\n  this.token(\"]\");\n}\n\nexport function TSTupleType(this: Printer, node: t.TSTupleType) {\n  this.token(\"[\");\n  this.printList(node.elementTypes, this.shouldPrintTrailingComma(\"]\"));\n  this.token(\"]\");\n}\n\nexport function TSOptionalType(this: Printer, node: t.TSOptionalType) {\n  this.print(node.typeAnnotation);\n  this.token(\"?\");\n}\n\nexport function TSRestType(this: Printer, node: t.TSRestType) {\n  this.token(\"...\");\n  this.print(node.typeAnnotation);\n}\n\nexport function TSNamedTupleMember(this: Printer, node: t.TSNamedTupleMember) {\n  this.print(node.label);\n  if (node.optional) this.token(\"?\");\n  this.token(\":\");\n  this.space();\n  this.print(node.elementType);\n}\n\nexport function TSUnionType(this: Printer, node: t.TSUnionType) {\n  tsPrintUnionOrIntersectionType(this, node, \"|\");\n}\n\nexport function TSIntersectionType(this: Printer, node: t.TSIntersectionType) {\n  tsPrintUnionOrIntersectionType(this, node, \"&\");\n}\n\nfunction tsPrintUnionOrIntersectionType(\n  printer: Printer,\n  node: t.TSUnionType | t.TSIntersectionType,\n  sep: \"|\" | \"&\",\n) {\n  let hasLeadingToken = 0;\n  if (printer.tokenMap?.startMatches(node, sep)) {\n    hasLeadingToken = 1;\n    printer.token(sep);\n  }\n\n  printer.printJoin(node.types, undefined, undefined, function (i) {\n    this.space();\n    this.token(sep, undefined, i + hasLeadingToken);\n    this.space();\n  });\n}\n\nexport function TSConditionalType(this: Printer, node: t.TSConditionalType) {\n  this.print(node.checkType);\n  this.space();\n  this.word(\"extends\");\n  this.space();\n  this.print(node.extendsType);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.trueType);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.falseType);\n}\n\nexport function TSInferType(this: Printer, node: t.TSInferType) {\n  this.word(\"infer\");\n  this.print(node.typeParameter);\n}\n\nexport function TSParenthesizedType(\n  this: Printer,\n  node: t.TSParenthesizedType,\n) {\n  this.token(\"(\");\n  this.print(node.typeAnnotation);\n  this.token(\")\");\n}\n\nexport function TSTypeOperator(this: Printer, node: t.TSTypeOperator) {\n  this.word(node.operator);\n  this.space();\n  this.print(node.typeAnnotation);\n}\n\nexport function TSIndexedAccessType(\n  this: Printer,\n  node: t.TSIndexedAccessType,\n) {\n  this.print(node.objectType, true);\n  this.token(\"[\");\n  this.print(node.indexType);\n  this.token(\"]\");\n}\n\nexport function TSMappedType(this: Printer, node: t.TSMappedType) {\n  const { nameType, optional, readonly, typeAnnotation } = node;\n  this.token(\"{\");\n  const oldNoLineTerminatorAfterNode = this.enterDelimited();\n  this.space();\n  if (readonly) {\n    tokenIfPlusMinus(this, readonly);\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.token(\"[\");\n\n  this.word(node.key.name);\n\n  this.space();\n  this.word(\"in\");\n  this.space();\n\n  this.print(node.constraint);\n\n  if (nameType) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(nameType, undefined, true);\n  }\n\n  this.token(\"]\");\n\n  if (optional) {\n    tokenIfPlusMinus(this, optional);\n    this.token(\"?\");\n  }\n\n  if (typeAnnotation) {\n    this.token(\":\");\n    this.space();\n    this.print(typeAnnotation, undefined, true);\n  }\n  this.space();\n  this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n  this.token(\"}\");\n}\n\nfunction tokenIfPlusMinus(self: Printer, tok: true | \"+\" | \"-\") {\n  if (tok !== true) {\n    self.token(tok);\n  }\n}\n\nexport function TSTemplateLiteralType(\n  this: Printer,\n  node: t.TSTemplateLiteralType,\n) {\n  _printTemplate.call(this, node, node.types);\n}\n\nexport function TSLiteralType(this: Printer, node: t.TSLiteralType) {\n  this.print(node.literal);\n}\n\nexport function TSClassImplements(this: Printer, node: t.TSClassImplements) {\n  this.print(node.expression);\n  this.print(node.typeArguments);\n}\n\nexport { TSClassImplements as TSInterfaceHeritage };\n\nexport function TSInterfaceDeclaration(\n  this: Printer,\n  node: t.TSInterfaceDeclaration,\n) {\n  const { declare, id, typeParameters, extends: extendz, body } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"interface\");\n  this.space();\n  this.print(id);\n  this.print(typeParameters);\n  if (extendz?.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(extendz);\n  }\n  this.space();\n  this.print(body);\n}\n\nexport function TSInterfaceBody(this: Printer, node: t.TSInterfaceBody) {\n  printBraced(this, node, () =>\n    this.printJoin(node.body, true, true, undefined, undefined, true),\n  );\n}\n\nexport function TSTypeAliasDeclaration(\n  this: Printer,\n  node: t.TSTypeAliasDeclaration,\n) {\n  const { declare, id, typeParameters, typeAnnotation } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"type\");\n  this.space();\n  this.print(id);\n  this.print(typeParameters);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(typeAnnotation);\n  this.semicolon();\n}\n\nexport function TSAsExpression(this: Printer, node: t.TSAsExpression) {\n  const { expression, typeAnnotation } = node;\n  this.print(expression, true);\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(typeAnnotation);\n}\n\nexport function TSSatisfiesExpression(\n  this: Printer,\n  node: t.TSSatisfiesExpression,\n) {\n  const { expression, typeAnnotation } = node;\n  this.print(expression, true);\n  this.space();\n  this.word(\"satisfies\");\n  this.space();\n  this.print(typeAnnotation);\n}\n\nexport function TSTypeAssertion(this: Printer, node: t.TSTypeAssertion) {\n  const { typeAnnotation, expression } = node;\n  this.token(\"<\");\n  this.print(typeAnnotation);\n  this.token(\">\");\n  this.space();\n  this.print(expression);\n}\n\nexport function TSInstantiationExpression(\n  this: Printer,\n  node: t.TSInstantiationExpression,\n) {\n  this.print(node.expression);\n\n  this.print(node.typeArguments);\n}\n\nexport function TSEnumDeclaration(this: Printer, node: t.TSEnumDeclaration) {\n  const { declare, const: isConst, id } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  if (isConst) {\n    this.word(\"const\");\n    this.space();\n  }\n  this.word(\"enum\");\n  this.space();\n  this.print(id);\n  this.space();\n\n  this.print(node.body);\n}\n\nexport function TSEnumBody(this: Printer, node: t.TSEnumBody) {\n  printBraced(this, node, () =>\n    this.printList(\n      node.members,\n      this.shouldPrintTrailingComma(\"}\") ?? false,\n      true,\n      true,\n      undefined,\n      true,\n    ),\n  );\n}\n\nexport function TSEnumMember(this: Printer, node: t.TSEnumMember) {\n  const { id, initializer } = node;\n  this.print(id);\n  if (initializer) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(initializer);\n  }\n}\n\nexport function TSModuleDeclaration(\n  this: Printer,\n  node: t.TSModuleDeclaration,\n) {\n  const { declare, kind } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (kind !== \"global\") {\n    this.word(kind);\n    this.space();\n  }\n\n  this.print(node.id);\n  if (!node.body) {\n    this.semicolon();\n    return;\n  }\n  this.space();\n  this.print(node.body);\n}\n\nexport function TSModuleBlock(this: Printer, node: t.TSModuleBlock) {\n  printBraced(this, node, () => this.printSequence(node.body, true, true));\n}\n\nexport function TSImportType(this: Printer, node: t.TSImportType) {\n  const { qualifier, options } = node;\n  this.word(\"import\");\n  this.token(\"(\");\n  this.print(node.source);\n  if (options) {\n    this.token(\",\");\n    this.print(options);\n  }\n  this.token(\")\");\n  if (qualifier) {\n    this.token(\".\");\n    this.print(qualifier);\n  }\n  const typeArguments = node.typeArguments;\n\n  if (typeArguments) {\n    this.print(typeArguments);\n  }\n}\n\nexport function TSImportEqualsDeclaration(\n  this: Printer,\n  node: t.TSImportEqualsDeclaration,\n) {\n  const { id, moduleReference } = node;\n\n  this.word(\"import\");\n  this.space();\n  this.print(id);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(moduleReference);\n  this.semicolon();\n}\n\nexport function TSExternalModuleReference(\n  this: Printer,\n  node: t.TSExternalModuleReference,\n) {\n  this.token(\"require(\");\n  this.print(node.expression);\n  this.token(\")\");\n}\n\nexport function TSNonNullExpression(\n  this: Printer,\n  node: t.TSNonNullExpression,\n) {\n  this.print(node.expression);\n  this.token(\"!\");\n  this.setLastChar(charCodes.exclamationMark);\n}\n\nexport function TSExportAssignment(this: Printer, node: t.TSExportAssignment) {\n  this.word(\"export\");\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.expression);\n  this.semicolon();\n}\n\nexport function TSNamespaceExportDeclaration(\n  this: Printer,\n  node: t.TSNamespaceExportDeclaration,\n) {\n  this.word(\"export\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.word(\"namespace\");\n  this.space();\n  this.print(node.id);\n  this.semicolon();\n}\n\nfunction tsPrintSignatureDeclarationBase(this: Printer, node: any) {\n  const { typeParameters } = node;\n  const parameters = node.params;\n  this.print(typeParameters);\n  this.token(\"(\");\n  _parameters.call(this, parameters, charCodes.rightParenthesis);\n  this.print(node.returnType);\n}\n\nexport function _tsPrintClassMemberModifiers(\n  this: Printer,\n  node:\n    | t.ClassProperty\n    | t.ClassAccessorProperty\n    | t.ClassPrivateProperty\n    | t.ClassMethod\n    | t.ClassPrivateMethod\n    | t.TSDeclareMethod,\n) {\n  const isPrivateField = node.type === \"ClassPrivateProperty\";\n  const isPublicField =\n    node.type === \"ClassAccessorProperty\" || node.type === \"ClassProperty\";\n  printModifiersList(this, node, [\n    isPublicField && node.declare && \"declare\",\n    !isPrivateField && node.accessibility,\n  ]);\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  printModifiersList(this, node, [\n    !isPrivateField && node.abstract && \"abstract\",\n    !isPrivateField && node.override && \"override\",\n    (isPublicField || isPrivateField) && node.readonly && \"readonly\",\n  ]);\n}\n\nfunction printBraced(printer: Printer, node: t.Node, cb: () => void) {\n  printer.token(\"{\");\n  const oldNoLineTerminatorAfterNode = printer.enterDelimited();\n  cb();\n  printer._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n  printer.rightBrace(node);\n}\n\nfunction printModifiersList(\n  printer: Printer,\n  node: t.Node,\n  modifiers: (string | false | null | undefined)[],\n) {\n  const modifiersSet = new Set<string>();\n  for (const modifier of modifiers) {\n    if (modifier) modifiersSet.add(modifier);\n  }\n\n  printer.tokenMap?.find(node, tok => {\n    if (modifiersSet.has(tok.value)) {\n      printer.token(tok.value);\n      printer.space();\n      modifiersSet.delete(tok.value);\n      return modifiersSet.size === 0;\n    }\n    return false;\n  });\n\n  for (const modifier of modifiersSet) {\n    printer.word(modifier);\n    printer.space();\n  }\n}\n","import type Printer from \"../printer.ts\";\nimport {\n  isClassDeclaration,\n  isExportDefaultSpecifier,\n  isExportNamespaceSpecifier,\n  isImportDefaultSpecifier,\n  isImportNamespaceSpecifier,\n  isStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { TokenContext } from \"../node/index.ts\";\nimport { _shouldPrintDecoratorsBeforeExport } from \"./expressions.ts\";\n\nexport function ImportSpecifier(this: Printer, node: t.ImportSpecifier) {\n  if (node.importKind === \"type\" || node.importKind === \"typeof\") {\n    this.word(node.importKind);\n    this.space();\n  }\n\n  this.print(node.imported);\n  // @ts-expect-error todo(flow-ts) maybe check node type instead of relying on name to be undefined on t.StringLiteral\n  if (node.local && node.local.name !== node.imported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.local);\n  }\n}\n\nexport function ImportDefaultSpecifier(\n  this: Printer,\n  node: t.ImportDefaultSpecifier,\n) {\n  this.print(node.local);\n}\n\nexport function ExportDefaultSpecifier(\n  this: Printer,\n  node: t.ExportDefaultSpecifier,\n) {\n  this.print(node.exported);\n}\n\nexport function ExportSpecifier(this: Printer, node: t.ExportSpecifier) {\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n\n  this.print(node.local);\n  // @ts-expect-error todo(flow-ts) maybe check node type instead of relying on name to be undefined on t.StringLiteral\n  if (node.exported && node.local.name !== node.exported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.exported);\n  }\n}\n\nexport function ExportNamespaceSpecifier(\n  this: Printer,\n  node: t.ExportNamespaceSpecifier,\n) {\n  this.token(\"*\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.exported);\n}\n\nexport function _printAttributes(\n  this: Printer,\n  node: Extract<t.Node, { attributes?: t.ImportAttribute[] | null }>,\n  hasPreviousBrace: boolean,\n) {\n  const { attributes } = node;\n\n  this.word(\"with\");\n  this.space();\n\n  const occurrenceCount = hasPreviousBrace ? 1 : 0;\n\n  this.token(\"{\", undefined, occurrenceCount);\n  this.space();\n  this.printList(attributes, this.shouldPrintTrailingComma(\"}\"));\n  this.space();\n  this.token(\"}\", undefined, occurrenceCount);\n}\n\nexport function ExportAllDeclaration(\n  this: Printer,\n  node: t.ExportAllDeclaration | t.DeclareExportAllDeclaration,\n) {\n  this.word(\"export\");\n  this.space();\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n  this.token(\"*\");\n  this.space();\n  this.word(\"from\");\n  this.space();\n  if (node.attributes?.length) {\n    this.print(node.source, true);\n    this.space();\n    _printAttributes.call(this, node, false);\n  } else {\n    this.print(node.source);\n  }\n\n  this.semicolon();\n}\n\nfunction maybePrintDecoratorsBeforeExport(\n  printer: Printer,\n  node: t.ExportNamedDeclaration | t.ExportDefaultDeclaration,\n) {\n  if (\n    isClassDeclaration(node.declaration) &&\n    _shouldPrintDecoratorsBeforeExport.call(\n      printer,\n      node as t.ExportNamedDeclaration & { declaration: t.ClassDeclaration },\n    )\n  ) {\n    printer.printJoin(node.declaration.decorators);\n  }\n}\n\nexport function ExportNamedDeclaration(\n  this: Printer,\n  node: t.ExportNamedDeclaration,\n) {\n  maybePrintDecoratorsBeforeExport(this, node);\n\n  this.word(\"export\");\n  this.space();\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    if (node.exportKind === \"type\") {\n      this.word(\"type\");\n      this.space();\n    }\n\n    const specifiers = node.specifiers.slice(0);\n\n    // print \"special\" specifiers first\n    let hasSpecial = false;\n    for (;;) {\n      const first = specifiers[0];\n      if (\n        isExportDefaultSpecifier(first) ||\n        isExportNamespaceSpecifier(first)\n      ) {\n        hasSpecial = true;\n        this.print(specifiers.shift());\n        if (specifiers.length) {\n          this.token(\",\");\n          this.space();\n        }\n      } else {\n        break;\n      }\n    }\n\n    let hasBrace = false;\n    if (specifiers.length || (!specifiers.length && !hasSpecial)) {\n      hasBrace = true;\n      this.token(\"{\");\n      if (specifiers.length) {\n        this.space();\n        this.printList(specifiers, this.shouldPrintTrailingComma(\"}\"));\n        this.space();\n      }\n      this.token(\"}\");\n    }\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      if (node.attributes?.length) {\n        this.print(node.source, true);\n        this.space();\n        _printAttributes.call(this, node, hasBrace);\n      } else {\n        this.print(node.source);\n      }\n    }\n\n    this.semicolon();\n  }\n}\n\nexport function ExportDefaultDeclaration(\n  this: Printer,\n  node: t.ExportDefaultDeclaration,\n) {\n  maybePrintDecoratorsBeforeExport(this, node);\n\n  this.word(\"export\");\n  this.noIndentInnerCommentsHere();\n  this.space();\n  this.word(\"default\");\n  this.space();\n  this.tokenContext |= TokenContext.exportDefault;\n  const declar = node.declaration;\n  this.print(declar);\n  if (!isStatement(declar)) this.semicolon();\n}\n\nexport function ImportDeclaration(this: Printer, node: t.ImportDeclaration) {\n  this.word(\"import\");\n  this.space();\n\n  const isTypeKind = node.importKind === \"type\" || node.importKind === \"typeof\";\n  if (isTypeKind) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.importKind!);\n    this.space();\n  } else if (node.module) {\n    this.noIndentInnerCommentsHere();\n    this.word(\"module\");\n    this.space();\n  } else if (node.phase) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.phase);\n    this.space();\n  }\n\n  const specifiers = node.specifiers.slice(0);\n  const hasSpecifiers = !!specifiers.length;\n  // print \"special\" specifiers first. The loop condition is constant,\n  // but there is a \"break\" in the body.\n  while (hasSpecifiers) {\n    const first = specifiers[0];\n    if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {\n      this.print(specifiers.shift());\n      if (specifiers.length) {\n        this.token(\",\");\n        this.space();\n      }\n    } else {\n      break;\n    }\n  }\n\n  let hasBrace = false;\n  if (specifiers.length) {\n    hasBrace = true;\n    this.token(\"{\");\n    this.space();\n    this.printList(specifiers, this.shouldPrintTrailingComma(\"}\"));\n    this.space();\n    this.token(\"}\");\n  } else if (isTypeKind && !hasSpecifiers) {\n    hasBrace = true;\n    this.token(\"{\");\n    this.token(\"}\");\n  }\n\n  if (hasSpecifiers || isTypeKind) {\n    this.space();\n    this.word(\"from\");\n    this.space();\n  }\n\n  if (node.attributes?.length) {\n    this.print(node.source, true);\n    this.space();\n    _printAttributes.call(this, node, hasBrace);\n  } else {\n    this.print(node.source);\n  }\n\n  this.semicolon();\n}\n\nexport function ImportAttribute(this: Printer, node: t.ImportAttribute) {\n  this.print(node.key);\n  this.token(\":\");\n  this.space();\n  this.print(node.value);\n}\n\nexport function ImportNamespaceSpecifier(\n  this: Printer,\n  node: t.ImportNamespaceSpecifier,\n) {\n  this.token(\"*\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.local);\n}\n\nexport function ImportExpression(this: Printer, node: t.ImportExpression) {\n  this.word(\"import\");\n  if (node.phase) {\n    this.token(\".\");\n    this.word(node.phase);\n  }\n  this.token(\"(\");\n  const shouldPrintTrailingComma = this.shouldPrintTrailingComma(\")\");\n  this.print(node.source);\n  if (node.options != null) {\n    this.token(\",\");\n    this.space();\n    this.print(node.options);\n  }\n  if (shouldPrintTrailingComma) {\n    this.token(\",\");\n  }\n  this.rightParens(node);\n}\n","import type Printer from \"../printer.ts\";\nimport { isAssignmentPattern, isIdentifier } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport jsesc from \"jsesc\";\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\nimport { _methodHead } from \"./methods.ts\";\n\nlet lastRawIdentResult: string = \"\";\nexport function _getRawIdentifier(this: Printer, node: t.Identifier) {\n  const { name } = node;\n  const token = this.tokenMap!.find(node, tok => tok.value === name);\n  if (token) {\n    lastRawIdentResult = this._originalCode!.slice(token.start, token.end);\n    return lastRawIdentResult;\n  }\n  return (lastRawIdentResult = node.name);\n}\n\nexport function Identifier(this: Printer, node: t.Identifier) {\n  if (this._buf._map) {\n    this.sourceIdentifierName(node.loc?.identifierName || node.name);\n  }\n\n  this.word(this.tokenMap ? lastRawIdentResult : node.name);\n}\n\nexport function ArgumentPlaceholder(this: Printer) {\n  this.token(\"?\");\n}\n\nexport function RestElement(this: Printer, node: t.RestElement) {\n  this.token(\"...\");\n  this.print(node.argument);\n}\n\nexport { RestElement as SpreadElement };\n\nexport function ObjectExpression(this: Printer, node: t.ObjectExpression) {\n  const props = node.properties;\n\n  this.token(\"{\");\n\n  if (props.length) {\n    const oldNoLineTerminatorAfterNode = this.enterDelimited();\n    this.space();\n    this.printList(\n      props,\n      this.shouldPrintTrailingComma(\"}\"),\n      true,\n      true,\n      undefined,\n      true,\n    );\n    this.space();\n    this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n  }\n\n  this.rightBrace(node);\n}\n\nexport { ObjectExpression as ObjectPattern };\n\nexport function ObjectMethod(this: Printer, node: t.ObjectMethod) {\n  this.printJoin(node.decorators);\n  _methodHead.call(this, node);\n  this.space();\n  this.print(node.body);\n}\n\nexport function ObjectProperty(this: Printer, node: t.ObjectProperty) {\n  this.printJoin(node.decorators);\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key);\n    this.token(\"]\");\n  } else {\n    // print `({ foo: foo = 5 } = {})` as `({ foo = 5 } = {});`\n    if (\n      isAssignmentPattern(node.value) &&\n      isIdentifier(node.key) &&\n      // @ts-expect-error todo(flow->ts) `.name` does not exist on some types in union\n      node.key.name === node.value.left.name\n    ) {\n      this.print(node.value);\n      return;\n    }\n\n    this.print(node.key);\n\n    // shorthand!\n    if (\n      node.shorthand &&\n      isIdentifier(node.key) &&\n      isIdentifier(node.value) &&\n      node.key.name === node.value.name\n    ) {\n      return;\n    }\n  }\n\n  this.token(\":\");\n  this.space();\n  this.print(node.value);\n}\n\nexport function ArrayExpression(this: Printer, node: t.ArrayExpression) {\n  const elems = node.elements;\n  const len = elems.length;\n\n  this.token(\"[\");\n\n  const oldNoLineTerminatorAfterNode = this.enterDelimited();\n\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem, undefined, true);\n      if (i < len - 1 || this.shouldPrintTrailingComma(\"]\")) {\n        this.tokenChar(charCodes.comma, i);\n      }\n    } else {\n      // If the array expression ends with a hole, that hole\n      // will be ignored by the interpreter, but if it ends with\n      // two (or more) holes, we need to write out two (or more)\n      // commas so that the resulting code is interpreted with\n      // both (all) of the holes.\n      this.tokenChar(charCodes.comma, i);\n    }\n  }\n\n  this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n\n  this.token(\"]\");\n}\n\nexport { ArrayExpression as ArrayPattern };\n\nexport function RegExpLiteral(this: Printer, node: t.RegExpLiteral) {\n  this.word(`/${node.pattern}/${node.flags}`, false);\n}\n\nexport function BooleanLiteral(this: Printer, node: t.BooleanLiteral) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nexport function NullLiteral(this: Printer) {\n  this.word(\"null\");\n}\n\nexport function NumericLiteral(this: Printer, node: t.NumericLiteral) {\n  const raw = this.getPossibleRaw(node);\n  const opts = this.format.jsescOption;\n  const value = node.value;\n  const str = value + \"\";\n  if (opts.numbers) {\n    this.number(jsesc(value, opts), value);\n  } else if (raw == null) {\n    this.number(str, value); // normalize\n  } else if (this.format.minified) {\n    this.number(raw.length < str.length ? raw : str, value);\n  } else {\n    this.number(raw, value);\n  }\n}\n\nexport function StringLiteral(this: Printer, node: t.StringLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n\n  const val = jsesc(node.value, this.format.jsescOption);\n\n  this.token(val);\n}\n\nexport function BigIntLiteral(this: Printer, node: t.BigIntLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n  this.word(node.value + \"n\");\n}\n\n// Hack pipe operator\nconst validTopicTokenSet = new Set<string | undefined>([\n  \"^^\",\n  \"@@\",\n  \"^\",\n  \"%\",\n  \"#\",\n]);\nexport function TopicReference(this: Printer) {\n  const { topicToken } = this.format;\n\n  if (validTopicTokenSet.has(topicToken)) {\n    this.token(topicToken!);\n  } else {\n    const givenTopicTokenJSON = JSON.stringify(topicToken);\n    const validTopics = Array.from(validTopicTokenSet, v => JSON.stringify(v));\n    throw new Error(\n      `The \"topicToken\" generator option must be one of ` +\n        `${validTopics.join(\", \")} (${givenTopicTokenJSON} received instead).`,\n    );\n  }\n}\n\n// discard binding\nexport function VoidPattern(this: Printer) {\n  this.word(\"void\");\n}\n","import type Printer from \"../printer.ts\";\nimport { isDeclareExportDeclaration, isStatement } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { ExportAllDeclaration } from \"./modules.ts\";\nimport { TokenContext } from \"../node/index.ts\";\n\nexport function AnyTypeAnnotation(this: Printer) {\n  this.word(\"any\");\n}\n\nexport function ArrayTypeAnnotation(\n  this: Printer,\n  node: t.ArrayTypeAnnotation,\n) {\n  this.print(node.elementType, true);\n  this.token(\"[\");\n  this.token(\"]\");\n}\n\nexport function BooleanTypeAnnotation(this: Printer) {\n  this.word(\"boolean\");\n}\n\nexport function BooleanLiteralTypeAnnotation(\n  this: Printer,\n  node: t.BooleanLiteralTypeAnnotation,\n) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nexport function NullLiteralTypeAnnotation(this: Printer) {\n  this.word(\"null\");\n}\n\nexport function DeclareClass(\n  this: Printer,\n  node: t.DeclareClass,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"class\");\n  this.space();\n  _interfaceish.call(this, node);\n}\n\nexport function DeclareFunction(\n  this: Printer,\n  node: t.DeclareFunction,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"function\");\n  this.space();\n  this.print(node.id);\n\n  // Skip TypeAnnotation printing method as the FunctionTypeAnnotation will print `(): `\n  this.print(node.id.typeAnnotation?.typeAnnotation);\n\n  if (node.predicate) {\n    this.space();\n    this.print(node.predicate);\n  }\n\n  this.semicolon();\n}\n\nexport function InferredPredicate(this: Printer) {\n  this.token(\"%\");\n  this.word(\"checks\");\n}\n\nexport function DeclaredPredicate(this: Printer, node: t.DeclaredPredicate) {\n  this.token(\"%\");\n  this.word(\"checks\");\n  this.token(\"(\");\n  this.print(node.value);\n  this.token(\")\");\n}\n\nexport function DeclareInterface(this: Printer, node: t.DeclareInterface) {\n  this.word(\"declare\");\n  this.space();\n  InterfaceDeclaration.call(this, node);\n}\n\nexport function DeclareModule(this: Printer, node: t.DeclareModule) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.space();\n  this.print(node.id);\n  this.space();\n  this.print(node.body);\n}\n\nexport function DeclareModuleExports(\n  this: Printer,\n  node: t.DeclareModuleExports,\n) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.token(\".\");\n  this.word(\"exports\");\n  this.print(node.typeAnnotation);\n}\n\nexport function DeclareTypeAlias(this: Printer, node: t.DeclareTypeAlias) {\n  this.word(\"declare\");\n  this.space();\n  TypeAlias.call(this, node);\n}\n\nexport function DeclareOpaqueType(\n  this: Printer,\n  node: t.DeclareOpaqueType,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  OpaqueType.call(this, node);\n}\n\nexport function DeclareVariable(\n  this: Printer,\n  node: t.DeclareVariable,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"var\");\n  this.space();\n  this.print(node.id);\n  this.print(node.id.typeAnnotation);\n  this.semicolon();\n}\n\nexport function DeclareExportDeclaration(\n  this: Printer,\n  node: t.DeclareExportDeclaration,\n) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"export\");\n  this.space();\n  if (node.default) {\n    this.word(\"default\");\n    this.space();\n  }\n\n  FlowExportDeclaration.call(this, node);\n}\n\nexport function DeclareExportAllDeclaration(\n  this: Printer,\n  node: t.DeclareExportAllDeclaration,\n) {\n  this.word(\"declare\");\n  this.space();\n  ExportAllDeclaration.call(this, node);\n}\n\nexport function EnumDeclaration(this: Printer, node: t.EnumDeclaration) {\n  const { id, body } = node;\n  this.word(\"enum\");\n  this.space();\n  this.print(id);\n  this.print(body);\n}\n\nfunction enumExplicitType(\n  context: Printer,\n  name: string,\n  hasExplicitType: boolean,\n) {\n  if (hasExplicitType) {\n    context.space();\n    context.word(\"of\");\n    context.space();\n    context.word(name);\n  }\n  context.space();\n}\n\nfunction enumBody(context: Printer, node: t.EnumBody) {\n  const { members } = node;\n  context.token(\"{\");\n  context.indent();\n  context.newline();\n  for (const member of members) {\n    context.print(member);\n    context.newline();\n  }\n  if (node.hasUnknownMembers) {\n    context.token(\"...\");\n    context.newline();\n  }\n  context.dedent();\n  context.token(\"}\");\n}\n\nexport function EnumBooleanBody(this: Printer, node: t.EnumBooleanBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"boolean\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumNumberBody(this: Printer, node: t.EnumNumberBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"number\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumStringBody(this: Printer, node: t.EnumStringBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"string\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumSymbolBody(this: Printer, node: t.EnumSymbolBody) {\n  enumExplicitType(this, \"symbol\", true);\n  enumBody(this, node);\n}\n\nexport function EnumDefaultedMember(\n  this: Printer,\n  node: t.EnumDefaultedMember,\n) {\n  const { id } = node;\n  this.print(id);\n  this.token(\",\");\n}\n\nfunction enumInitializedMember(\n  context: Printer,\n  node: t.EnumBooleanMember | t.EnumNumberMember | t.EnumStringMember,\n) {\n  context.print(node.id);\n  context.space();\n  context.token(\"=\");\n  context.space();\n  context.print(node.init);\n  context.token(\",\");\n}\n\nexport function EnumBooleanMember(this: Printer, node: t.EnumBooleanMember) {\n  enumInitializedMember(this, node);\n}\n\nexport function EnumNumberMember(this: Printer, node: t.EnumNumberMember) {\n  enumInitializedMember(this, node);\n}\n\nexport function EnumStringMember(this: Printer, node: t.EnumStringMember) {\n  enumInitializedMember(this, node);\n}\n\nfunction FlowExportDeclaration(\n  this: Printer,\n  node: t.DeclareExportDeclaration,\n) {\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    this.token(\"{\");\n    if (node.specifiers!.length) {\n      this.space();\n      this.printList(node.specifiers);\n      this.space();\n    }\n    this.token(\"}\");\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      this.print(node.source);\n    }\n\n    this.semicolon();\n  }\n}\n\nexport function ExistsTypeAnnotation(this: Printer) {\n  this.token(\"*\");\n}\n\nexport function FunctionTypeAnnotation(\n  this: Printer,\n  node: t.FunctionTypeAnnotation,\n  parent?: t.Node,\n) {\n  this.print(node.typeParameters);\n  this.token(\"(\");\n\n  if (node.this) {\n    this.word(\"this\");\n    this.token(\":\");\n    this.space();\n    this.print(node.this.typeAnnotation);\n    if (node.params.length || node.rest) {\n      this.token(\",\");\n      this.space();\n    }\n  }\n\n  this.printList(node.params);\n\n  if (node.rest) {\n    if (node.params.length) {\n      this.token(\",\");\n      this.space();\n    }\n    this.token(\"...\");\n    this.print(node.rest);\n  }\n\n  this.token(\")\");\n\n  // this node type is overloaded, not sure why but it makes it EXTREMELY annoying\n\n  const type = parent?.type;\n  if (\n    type != null &&\n    (type === \"ObjectTypeCallProperty\" ||\n      type === \"ObjectTypeInternalSlot\" ||\n      type === \"DeclareFunction\" ||\n      (type === \"ObjectTypeProperty\" && parent.method))\n  ) {\n    this.token(\":\");\n  } else {\n    this.space();\n    this.token(\"=>\");\n  }\n\n  this.space();\n  this.print(node.returnType);\n}\n\nexport function FunctionTypeParam(this: Printer, node: t.FunctionTypeParam) {\n  this.print(node.name);\n  if (node.optional) this.token(\"?\");\n  if (node.name) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.typeAnnotation);\n}\n\nexport function InterfaceExtends(this: Printer, node: t.InterfaceExtends) {\n  this.print(node.id);\n  this.print(node.typeParameters, true);\n}\n\nexport {\n  InterfaceExtends as ClassImplements,\n  InterfaceExtends as GenericTypeAnnotation,\n};\n\nexport function _interfaceish(\n  this: Printer,\n  node: t.InterfaceDeclaration | t.DeclareInterface | t.DeclareClass,\n) {\n  this.print(node.id);\n  this.print(node.typeParameters);\n  if (node.extends?.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends);\n  }\n  if (node.type === \"DeclareClass\") {\n    if (node.mixins?.length) {\n      this.space();\n      this.word(\"mixins\");\n      this.space();\n      this.printList(node.mixins);\n    }\n    if (node.implements?.length) {\n      this.space();\n      this.word(\"implements\");\n      this.space();\n      this.printList(node.implements);\n    }\n  }\n  this.space();\n  this.print(node.body);\n}\n\nexport function _variance(\n  this: Printer,\n  node:\n    | t.TypeParameter\n    | t.ObjectTypeIndexer\n    | t.ObjectTypeProperty\n    | t.ClassProperty\n    | t.ClassPrivateProperty\n    | t.ClassAccessorProperty,\n) {\n  const kind = node.variance?.kind;\n  if (kind != null) {\n    if (kind === \"plus\") {\n      this.token(\"+\");\n    } else if (kind === \"minus\") {\n      this.token(\"-\");\n    }\n  }\n}\n\nexport function InterfaceDeclaration(\n  this: Printer,\n  node: t.InterfaceDeclaration | t.DeclareInterface,\n) {\n  this.word(\"interface\");\n  this.space();\n  _interfaceish.call(this, node);\n}\n\nfunction andSeparator(this: Printer, occurrenceCount: number) {\n  this.space();\n  this.token(\"&\", false, occurrenceCount);\n  this.space();\n}\n\nexport function InterfaceTypeAnnotation(\n  this: Printer,\n  node: t.InterfaceTypeAnnotation,\n) {\n  this.word(\"interface\");\n  if (node.extends?.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends);\n  }\n  this.space();\n  this.print(node.body);\n}\n\nexport function IntersectionTypeAnnotation(\n  this: Printer,\n  node: t.IntersectionTypeAnnotation,\n) {\n  this.printJoin(node.types, undefined, undefined, andSeparator);\n}\n\nexport function MixedTypeAnnotation(this: Printer) {\n  this.word(\"mixed\");\n}\n\nexport function EmptyTypeAnnotation(this: Printer) {\n  this.word(\"empty\");\n}\n\nexport function NullableTypeAnnotation(\n  this: Printer,\n  node: t.NullableTypeAnnotation,\n) {\n  this.token(\"?\");\n  this.print(node.typeAnnotation);\n}\n\nexport {\n  NumericLiteral as NumberLiteralTypeAnnotation,\n  StringLiteral as StringLiteralTypeAnnotation,\n} from \"./types.ts\";\n\nexport function NumberTypeAnnotation(this: Printer) {\n  this.word(\"number\");\n}\n\nexport function StringTypeAnnotation(this: Printer) {\n  this.word(\"string\");\n}\n\nexport function ThisTypeAnnotation(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function TupleTypeAnnotation(\n  this: Printer,\n  node: t.TupleTypeAnnotation,\n) {\n  this.token(\"[\");\n  this.printList(node.types);\n  this.token(\"]\");\n}\n\nexport function TypeofTypeAnnotation(\n  this: Printer,\n  node: t.TypeofTypeAnnotation,\n) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.argument);\n}\n\nexport function TypeAlias(\n  this: Printer,\n  node: t.TypeAlias | t.DeclareTypeAlias,\n) {\n  this.word(\"type\");\n  this.space();\n  this.print(node.id);\n  this.print(node.typeParameters);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right);\n  this.semicolon();\n}\n\nexport function TypeAnnotation(\n  this: Printer,\n  node: t.TypeAnnotation,\n  parent: t.Node,\n) {\n  this.token(\":\");\n  this.space();\n  if (parent.type === \"ArrowFunctionExpression\") {\n    this.tokenContext |= TokenContext.arrowFlowReturnType;\n  } else if (\n    // @ts-expect-error todo(flow->ts) can this be removed? `.optional` looks to be not existing property\n    node.optional\n  ) {\n    this.token(\"?\");\n  }\n  this.print(node.typeAnnotation);\n}\n\nexport function TypeParameterInstantiation(\n  this: Printer,\n  node: t.TypeParameterInstantiation,\n): void {\n  this.token(\"<\");\n  this.printList(node.params);\n  this.token(\">\");\n}\n\nexport { TypeParameterInstantiation as TypeParameterDeclaration };\n\nexport function TypeParameter(this: Printer, node: t.TypeParameter) {\n  _variance.call(this, node);\n\n  this.word(node.name);\n\n  if (node.bound) {\n    this.print(node.bound);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default);\n  }\n}\n\nexport function OpaqueType(\n  this: Printer,\n  node: t.OpaqueType | t.DeclareOpaqueType,\n) {\n  this.word(\"opaque\");\n  this.space();\n  this.word(\"type\");\n  this.space();\n  this.print(node.id);\n  this.print(node.typeParameters);\n  if (node.supertype) {\n    this.token(\":\");\n    this.space();\n    this.print(node.supertype);\n  }\n\n  if (node.impltype) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.impltype);\n  }\n  this.semicolon();\n}\n\nexport function ObjectTypeAnnotation(\n  this: Printer,\n  node: t.ObjectTypeAnnotation,\n) {\n  if (node.exact) {\n    this.token(\"{|\");\n  } else {\n    this.token(\"{\");\n  }\n\n  // TODO: remove the array fallbacks and instead enforce the types to require an array\n  const props = [\n    ...node.properties,\n    ...(node.callProperties || []),\n    ...(node.indexers || []),\n    ...(node.internalSlots || []),\n  ];\n\n  if (props.length) {\n    this.newline();\n\n    this.space();\n\n    this.printJoin(\n      props,\n      true,\n      true,\n      () => {\n        if (props.length !== 1 || node.inexact) {\n          this.token(\",\");\n          this.space();\n        }\n      },\n      true,\n    );\n\n    this.space();\n  }\n\n  if (node.inexact) {\n    this.indent();\n    this.token(\"...\");\n    if (props.length) {\n      this.newline();\n    }\n    this.dedent();\n  }\n\n  if (node.exact) {\n    this.token(\"|}\");\n  } else {\n    this.token(\"}\");\n  }\n}\n\nexport function ObjectTypeInternalSlot(\n  this: Printer,\n  node: t.ObjectTypeInternalSlot,\n) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.token(\"[\");\n  this.token(\"[\");\n  this.print(node.id);\n  this.token(\"]\");\n  this.token(\"]\");\n  if (node.optional) this.token(\"?\");\n  if (!node.method) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.value);\n}\n\nexport function ObjectTypeCallProperty(\n  this: Printer,\n  node: t.ObjectTypeCallProperty,\n) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.print(node.value);\n}\n\nexport function ObjectTypeIndexer(this: Printer, node: t.ObjectTypeIndexer) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  _variance.call(this, node);\n  this.token(\"[\");\n  if (node.id) {\n    this.print(node.id);\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.key);\n  this.token(\"]\");\n  this.token(\":\");\n  this.space();\n  this.print(node.value);\n}\n\nexport function ObjectTypeProperty(this: Printer, node: t.ObjectTypeProperty) {\n  if (node.proto) {\n    this.word(\"proto\");\n    this.space();\n  }\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (node.kind === \"get\" || node.kind === \"set\") {\n    this.word(node.kind);\n    this.space();\n  }\n  _variance.call(this, node);\n  this.print(node.key);\n  if (node.optional) this.token(\"?\");\n  if (!node.method) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.value);\n}\n\nexport function ObjectTypeSpreadProperty(\n  this: Printer,\n  node: t.ObjectTypeSpreadProperty,\n) {\n  this.token(\"...\");\n  this.print(node.argument);\n}\n\nexport function QualifiedTypeIdentifier(\n  this: Printer,\n  node: t.QualifiedTypeIdentifier,\n) {\n  this.print(node.qualification);\n  this.token(\".\");\n  this.print(node.id);\n}\n\nexport function SymbolTypeAnnotation(this: Printer) {\n  this.word(\"symbol\");\n}\n\nfunction orSeparator(this: Printer, occurrenceCount: number) {\n  this.space();\n  this.token(\"|\", false, occurrenceCount);\n  this.space();\n}\n\nexport function UnionTypeAnnotation(\n  this: Printer,\n  node: t.UnionTypeAnnotation,\n) {\n  this.printJoin(node.types, undefined, undefined, orSeparator);\n}\n\nexport function TypeCastExpression(this: Printer, node: t.TypeCastExpression) {\n  this.token(\"(\");\n  this.print(node.expression);\n  this.print(node.typeAnnotation);\n  this.token(\")\");\n}\n\nexport function Variance(this: Printer, node: t.Variance) {\n  if (node.kind === \"plus\") {\n    this.token(\"+\");\n  } else {\n    this.token(\"-\");\n  }\n}\n\nexport function VoidTypeAnnotation(this: Printer) {\n  this.word(\"void\");\n}\n\nexport function IndexedAccessType(this: Printer, node: t.IndexedAccessType) {\n  this.print(node.objectType, true);\n  this.token(\"[\");\n  this.print(node.indexType);\n  this.token(\"]\");\n}\n\nexport function OptionalIndexedAccessType(\n  this: Printer,\n  node: t.OptionalIndexedAccessType,\n) {\n  this.print(node.objectType);\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n  this.token(\"[\");\n  this.print(node.indexType);\n  this.token(\"]\");\n}\n","import type Printer from \"../printer.ts\";\nimport {\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\nimport { _shouldPrintDecoratorsBeforeExport } from \"./expressions.ts\";\nimport { _tsPrintClassMemberModifiers } from \"./typescript.ts\";\nimport { _variance } from \"./flow.ts\";\nimport { _methodHead } from \"./methods.ts\";\n\nexport function ClassDeclaration(\n  this: Printer,\n  node: t.ClassDeclaration,\n  parent: t.Node,\n) {\n  const inExport =\n    isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);\n\n  if (\n    !inExport ||\n    !_shouldPrintDecoratorsBeforeExport.call(\n      this,\n      parent as t.ExportDeclaration & { declaration: t.ClassDeclaration },\n    )\n  ) {\n    this.printJoin(node.decorators);\n  }\n\n  if (node.declare) {\n    // TS\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (node.abstract) {\n    // TS\n    this.word(\"abstract\");\n    this.space();\n  }\n\n  this.word(\"class\");\n\n  if (node.id) {\n    this.space();\n    this.print(node.id);\n  }\n\n  this.print(node.typeParameters);\n\n  if (node.superClass) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.superClass);\n    this.print(node.superTypeArguments);\n  }\n\n  if (node.implements) {\n    this.space();\n    this.word(\"implements\");\n    this.space();\n    this.printList(node.implements);\n  }\n\n  this.space();\n  this.print(node.body);\n}\n\nexport { ClassDeclaration as ClassExpression };\n\nexport function ClassBody(this: Printer, node: t.ClassBody) {\n  this.token(\"{\");\n  if (node.body.length === 0) {\n    this.token(\"}\");\n  } else {\n    const separator = classBodyEmptySemicolonsPrinter(this, node);\n    separator?.(-1); // print leading semicolons in preserveFormat mode\n\n    const oldNoLineTerminatorAfterNode = this.enterDelimited();\n    this.printJoin(node.body, true, true, separator, true, true);\n    this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n\n    if (!this.endsWith(charCodes.lineFeed)) this.newline();\n\n    this.rightBrace(node);\n  }\n}\n\nfunction classBodyEmptySemicolonsPrinter(printer: Printer, node: t.ClassBody) {\n  if (!printer.tokenMap || node.start == null || node.end == null) {\n    return null;\n  }\n\n  // \"empty statements\" in class bodies are not represented in the AST.\n  // Print them by checking if there are any ; tokens between the current AST\n  // member and the next one.\n\n  const indexes = printer.tokenMap.getIndexes(node);\n  if (!indexes) return null;\n\n  let k = 1; // start from 1 to skip '{'\n\n  let occurrenceCount = 0;\n\n  let nextLocIndex = 0;\n  const advanceNextLocIndex = () => {\n    while (\n      nextLocIndex < node.body.length &&\n      node.body[nextLocIndex].start == null\n    ) {\n      nextLocIndex++;\n    }\n  };\n  advanceNextLocIndex();\n\n  return (i: number) => {\n    if (nextLocIndex <= i) {\n      nextLocIndex = i + 1;\n      advanceNextLocIndex();\n    }\n\n    const end =\n      nextLocIndex === node.body.length\n        ? node.end\n        : node.body[nextLocIndex].start;\n\n    let tok;\n    while (\n      k < indexes.length &&\n      printer.tokenMap!.matchesOriginal(\n        (tok = printer._tokens![indexes[k]]),\n        \";\",\n      ) &&\n      tok.start < end!\n    ) {\n      printer.tokenChar(charCodes.semicolon, occurrenceCount++);\n      k++;\n    }\n  };\n}\n\nexport function ClassProperty(this: Printer, node: t.ClassProperty) {\n  this.printJoin(node.decorators);\n\n  if (!node.static && !this.format.preserveFormat) {\n    // catch up to property key, avoid line break\n    // between member TS modifiers and the property key.\n    const endLine = node.key.loc?.end?.line;\n    if (endLine) this.catchUp(endLine);\n  }\n\n  _tsPrintClassMemberModifiers.call(this, node);\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key);\n    this.token(\"]\");\n  } else {\n    _variance.call(this, node);\n    this.print(node.key);\n  }\n\n  // TS\n  if (node.optional) {\n    this.token(\"?\");\n  }\n  if (node.definite) {\n    this.token(\"!\");\n  }\n\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\n\nexport function ClassAccessorProperty(\n  this: Printer,\n  node: t.ClassAccessorProperty,\n) {\n  this.printJoin(node.decorators);\n\n  // catch up to property key, avoid line break\n  // between member modifiers and the property key.\n  const endLine = node.key.loc?.end?.line;\n  if (endLine) this.catchUp(endLine);\n\n  // TS does not support class accessor property yet\n  _tsPrintClassMemberModifiers.call(this, node);\n\n  this.word(\"accessor\", true);\n  this.space();\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key);\n    this.token(\"]\");\n  } else {\n    // Todo: Flow does not support class accessor property yet.\n    _variance.call(this, node);\n    this.print(node.key);\n  }\n\n  // TS\n  if (node.optional) {\n    this.token(\"?\");\n  }\n  if (node.definite) {\n    this.token(\"!\");\n  }\n\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\n\nexport function ClassPrivateProperty(\n  this: Printer,\n  node: t.ClassPrivateProperty,\n) {\n  this.printJoin(node.decorators);\n  _tsPrintClassMemberModifiers.call(this, node);\n  this.print(node.key);\n  // TS\n  if (node.optional) {\n    this.token(\"?\");\n  }\n  if (node.definite) {\n    this.token(\"!\");\n  }\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\n\nexport function ClassMethod(this: Printer, node: t.ClassMethod) {\n  _classMethodHead.call(this, node);\n  this.space();\n  this.print(node.body);\n}\n\nexport function ClassPrivateMethod(this: Printer, node: t.ClassPrivateMethod) {\n  _classMethodHead.call(this, node);\n  this.space();\n  this.print(node.body);\n}\n\nexport function _classMethodHead(\n  this: Printer,\n  node: t.ClassMethod | t.ClassPrivateMethod | t.TSDeclareMethod,\n) {\n  this.printJoin(node.decorators);\n\n  if (!this.format.preserveFormat) {\n    // catch up to method key, avoid line break\n    // between member modifiers/method heads and the method key.\n    const endLine = node.key.loc?.end?.line;\n    if (endLine) this.catchUp(endLine);\n  }\n\n  _tsPrintClassMemberModifiers.call(this, node);\n  _methodHead.call(this, node);\n}\n\nexport function StaticBlock(this: Printer, node: t.StaticBlock) {\n  this.word(\"static\");\n  this.space();\n  this.token(\"{\");\n  if (node.body.length === 0) {\n    this.token(\"}\");\n  } else {\n    this.newline();\n    this.printSequence(node.body, true);\n    this.rightBrace(node);\n  }\n}\n","import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function File(this: Printer, node: t.File) {\n  if (node.program) {\n    // Print this here to ensure that Program node 'leadingComments' still\n    // get printed after the hashbang.\n    this.print(node.program.interpreter);\n  }\n\n  this.print(node.program);\n}\n\nexport function Program(this: Printer, node: t.Program) {\n  // An empty Program doesn't have any inner tokens, so\n  // we must explicitly print its inner comments.\n  this.printInnerComments(false);\n\n  const directivesLen = node.directives?.length;\n  if (directivesLen) {\n    const newline = node.body.length ? 2 : 1;\n    this.printSequence(node.directives, undefined, undefined, newline);\n    if (!node.directives[directivesLen - 1].trailingComments?.length) {\n      this.newline(newline);\n    }\n  }\n\n  this.printSequence(node.body);\n}\n\nexport function BlockStatement(this: Printer, node: t.BlockStatement) {\n  this.token(\"{\");\n  const oldNoLineTerminatorAfterNode = this.enterDelimited();\n\n  const directivesLen = node.directives?.length;\n  if (directivesLen) {\n    const newline = node.body.length ? 2 : 1;\n    this.printSequence(node.directives, true, true, newline);\n    if (!node.directives[directivesLen - 1].trailingComments?.length) {\n      this.newline(newline);\n    }\n  }\n\n  this.printSequence(node.body, true, true);\n\n  this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n  this.rightBrace(node);\n}\n\nexport function Directive(this: Printer, node: t.Directive) {\n  this.print(node.value);\n  this.semicolon();\n}\n\n// These regexes match an even number of \\ followed by a quote\nconst unescapedSingleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*'/;\nconst unescapedDoubleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*\"/;\n\nexport function DirectiveLiteral(this: Printer, node: t.DirectiveLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n\n  const { value } = node;\n\n  // NOTE: In directives we can't change escapings,\n  // because they change the behavior.\n  // e.g. \"us\\x65 strict\" (\\x65 is e) is not a \"use strict\" directive.\n\n  if (!unescapedDoubleQuoteRE.test(value)) {\n    this.token(`\"${value}\"`);\n  } else if (!unescapedSingleQuoteRE.test(value)) {\n    this.token(`'${value}'`);\n  } else {\n    throw new Error(\n      \"Malformed AST: it is not possible to print a directive containing\" +\n        \" both unescaped single and double quotes.\",\n    );\n  }\n}\n\nexport function InterpreterDirective(\n  this: Printer,\n  node: t.InterpreterDirective,\n) {\n  this.token(`#!${node.value}`);\n  this._newline();\n}\n\nexport function Placeholder(this: Printer, node: t.Placeholder) {\n  this.token(\"%%\");\n  this.print(node.name);\n  this.token(\"%%\");\n\n  if (node.expectedNode === \"Statement\") {\n    this.semicolon();\n  }\n}\n","import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function JSXAttribute(this: Printer, node: t.JSXAttribute) {\n  this.print(node.name);\n  if (node.value) {\n    this.token(\"=\");\n    this.print(node.value);\n  }\n}\n\nexport function JSXIdentifier(this: Printer, node: t.JSXIdentifier) {\n  this.word(node.name);\n}\n\nexport function JSXNamespacedName(this: Printer, node: t.JSXNamespacedName) {\n  this.print(node.namespace);\n  this.token(\":\");\n  this.print(node.name);\n}\n\nexport function JSXMemberExpression(\n  this: Printer,\n  node: t.JSXMemberExpression,\n) {\n  this.print(node.object);\n  this.token(\".\");\n  this.print(node.property);\n}\n\nexport function JSXSpreadAttribute(this: Printer, node: t.JSXSpreadAttribute) {\n  this.token(\"{\");\n  this.token(\"...\");\n  this.print(node.argument);\n  this.rightBrace(node);\n}\n\nexport function JSXExpressionContainer(\n  this: Printer,\n  node: t.JSXExpressionContainer,\n) {\n  this.token(\"{\");\n  this.print(node.expression);\n  this.rightBrace(node);\n}\n\nexport function JSXSpreadChild(this: Printer, node: t.JSXSpreadChild) {\n  this.token(\"{\");\n  this.token(\"...\");\n  this.print(node.expression);\n  this.rightBrace(node);\n}\n\nexport function JSXText(this: Printer, node: t.JSXText) {\n  const raw = this.getPossibleRaw(node);\n\n  if (raw !== undefined) {\n    this.token(raw, true);\n  } else {\n    this.token(node.value, true);\n  }\n}\n\nexport function JSXElement(this: Printer, node: t.JSXElement) {\n  const open = node.openingElement;\n  this.print(open);\n  if (open.selfClosing) return;\n\n  this.indent();\n  for (const child of node.children) {\n    this.print(child);\n  }\n  this.dedent();\n\n  this.print(node.closingElement);\n}\n\nfunction spaceSeparator(this: Printer) {\n  this.space();\n}\n\nexport function JSXOpeningElement(this: Printer, node: t.JSXOpeningElement) {\n  this.token(\"<\");\n  this.print(node.name);\n\n  this.print(node.typeArguments);\n\n  if (node.attributes.length > 0) {\n    this.space();\n    this.printJoin(node.attributes, undefined, undefined, spaceSeparator);\n  }\n  if (node.selfClosing) {\n    this.space();\n    this.token(\"/\");\n  }\n  this.token(\">\");\n}\n\nexport function JSXClosingElement(this: Printer, node: t.JSXClosingElement) {\n  this.token(\"<\");\n  this.token(\"/\");\n  this.print(node.name);\n  this.token(\">\");\n}\n\nexport function JSXEmptyExpression(this: Printer) {\n  // This node is empty, so forcefully print its inner comments.\n  this.printInnerComments();\n}\n\nexport function JSXFragment(this: Printer, node: t.JSXFragment) {\n  this.print(node.openingFragment);\n\n  this.indent();\n  for (const child of node.children) {\n    this.print(child);\n  }\n  this.dedent();\n\n  this.print(node.closingFragment);\n}\n\nexport function JSXOpeningFragment(this: Printer) {\n  this.token(\"<\");\n  this.token(\">\");\n}\n\nexport function JSXClosingFragment(this: Printer) {\n  this.token(\"</\");\n  this.token(\">\");\n}\n","import type * as t from \"@babel/types\";\n\nimport * as generatorFunctions from \"./generators/index.ts\";\nimport type { NodeHandler } from \"./node/index.ts\";\nimport type Printer from \"./printer.ts\";\n\ndeclare global {\n  function __node(type: t.Node[\"type\"]): number;\n}\n\nconst generatorInfosMap = new Map<\n  string,\n  [\n    (this: Printer, node: t.Node, parent?: t.Node | null) => void,\n    number,\n    NodeHandler<boolean> | undefined,\n  ]\n>();\nlet index = 0;\n\nfor (const key of Object.keys(generatorFunctions).sort() as Exclude<\n  keyof typeof generatorFunctions,\n  `_${string}`\n>[]) {\n  if (key.startsWith(\"_\")) continue;\n  generatorInfosMap.set(key, [generatorFunctions[key], index++, undefined]);\n}\n\nexport { generatorInfosMap };\n","import * as parens from \"./parentheses.ts\";\nimport { VISITOR_KEYS } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nimport { generatorInfosMap } from \"../nodes.ts\";\n\nexport const enum TokenContext {\n  normal = 0,\n  expressionStatement = 1 << 0,\n  arrowBody = 1 << 1,\n  exportDefault = 1 << 2,\n  arrowFlowReturnType = 1 << 3,\n  forInitHead = 1 << 4,\n  forInHead = 1 << 5,\n  forOfHead = 1 << 6,\n  // This flag lives across the token boundary, and will\n  // be reset after forIn or forInit head is printed\n  forInOrInitHeadAccumulate = 1 << 7,\n  forInOrInitHeadAccumulatePassThroughMask = 0b10000000,\n}\n\nexport type NodeHandler<R> = (\n  node: t.Node,\n  // todo:\n  // node: K extends keyof typeof t\n  //   ? Extract<typeof t[K], { type: \"string\" }>\n  //   : t.Node,\n  parent: t.Node,\n  parentId: number,\n  tokenContext?: number,\n  getRawIdentifier?: (node: t.Identifier) => string,\n) => R | undefined;\n\nfor (const type of Object.keys(parens) as (keyof typeof parens)[]) {\n  const func = parens[type];\n  if (generatorInfosMap.has(type)) {\n    generatorInfosMap.get(type)![2] = func;\n  }\n}\n\nfunction isOrHasCallExpression(node: t.Node): boolean {\n  switch (node.type) {\n    case \"CallExpression\":\n      return true;\n    case \"MemberExpression\":\n      return isOrHasCallExpression(node.object);\n  }\n  return false;\n}\n\nexport function parentNeedsParens(\n  node: t.Node,\n  parent: any,\n  parentId: number,\n): boolean {\n  switch (parentId) {\n    case __node(\"NewExpression\"):\n      if (parent.callee === node) {\n        if (isOrHasCallExpression(node)) return true;\n      }\n      break;\n    case __node(\"Decorator\"):\n      return (\n        !isDecoratorMemberExpression(node) &&\n        !(\n          node.type === \"CallExpression\" &&\n          isDecoratorMemberExpression(node.callee)\n        ) &&\n        node.type !== \"ParenthesizedExpression\"\n      );\n  }\n  return false;\n}\n\nfunction isDecoratorMemberExpression(node: t.Node): boolean {\n  switch (node.type) {\n    case \"Identifier\":\n      return true;\n    case \"MemberExpression\":\n      return (\n        !node.computed &&\n        node.property.type === \"Identifier\" &&\n        isDecoratorMemberExpression(node.object)\n      );\n    default:\n      return false;\n  }\n}\n\nexport function isLastChild(parent: t.Node, child: t.Node) {\n  const visitorKeys = VISITOR_KEYS[parent.type];\n  for (let i = visitorKeys.length - 1; i >= 0; i--) {\n    const val = (parent as any)[visitorKeys[i]] as t.Node | t.Node[] | null;\n    if (val === child) {\n      return true;\n    } else if (Array.isArray(val)) {\n      let j = val.length - 1;\n      while (j >= 0 && val[j] === null) j--;\n      return j >= 0 && val[j] === child;\n    } else if (val) {\n      return false;\n    }\n  }\n  return false;\n}\n","import type * as t from \"@babel/types\";\nimport type { Token } from \"@babel/parser\";\n\nimport { traverseFast, VISITOR_KEYS } from \"@babel/types\";\n\nexport class TokenMap {\n  _tokens: Token[];\n  _source: string;\n\n  _nodesToTokenIndexes = new Map<t.Node, number[]>();\n  _nodesOccurrencesCountCache = new Map<\n    t.Node,\n    { test: string; count: number; i: number }\n  >();\n\n  _tokensCache = new Map<t.Node, { first: number; last: number }>();\n\n  constructor(ast: t.Node, tokens: Token[], source: string) {\n    this._tokens = tokens;\n    this._source = source;\n\n    traverseFast(ast, node => {\n      const indexes = this._getTokensIndexesOfNode(node);\n      if (indexes.length > 0) this._nodesToTokenIndexes.set(node, indexes);\n    });\n\n    this._tokensCache.clear();\n  }\n\n  has(node: t.Node): boolean {\n    return this._nodesToTokenIndexes.has(node);\n  }\n\n  getIndexes(node: t.Node): readonly number[] | undefined {\n    return this._nodesToTokenIndexes.get(node);\n  }\n\n  find(\n    node: t.Node,\n    condition: (token: Token, index: number) => boolean,\n  ): Token | null {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      for (let k = 0; k < indexes.length; k++) {\n        const index = indexes[k];\n        const tok = this._tokens[index];\n        if (condition(tok, index)) return tok;\n      }\n    }\n    return null;\n  }\n\n  findLastIndex(\n    node: t.Node,\n    condition: (token: Token, index: number) => boolean,\n  ): number {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      for (let k = indexes.length - 1; k >= 0; k--) {\n        const index = indexes[k];\n        const tok = this._tokens[index];\n        if (condition(tok, index)) return index;\n      }\n    }\n    return -1;\n  }\n\n  findMatching(\n    node: t.Node,\n    test: string | number,\n    occurrenceCount: number = 0,\n  ): Token | null {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      if (typeof test === \"number\") {\n        test = String.fromCharCode(test);\n      }\n      let i = 0;\n      const count = occurrenceCount;\n\n      // To avoid O(n^2) search when printing lists (such as arrays), we\n      // cache the last index of a given token for a given occurrence count.\n      // If then we are asked to find the next occurrence of the same token,\n      // we start from the index of the previously found token.\n      // This cache only kicks in after 2 tokens of the same type, to avoid\n      // overhead in the simple case of having unique tokens per node.\n      if (count > 1) {\n        const cache = this._nodesOccurrencesCountCache.get(node);\n        if (cache?.test === test && cache.count < count) {\n          i = cache.i + 1;\n          occurrenceCount -= cache.count + 1;\n        }\n      }\n\n      for (; i < indexes.length; i++) {\n        const tok = this._tokens[indexes[i]];\n        if (this.matchesOriginal(tok, test)) {\n          if (occurrenceCount === 0) {\n            if (count > 0) {\n              this._nodesOccurrencesCountCache.set(node, { test, count, i });\n            }\n            return tok;\n          }\n          occurrenceCount--;\n        }\n      }\n    }\n    return null;\n  }\n\n  matchesOriginal(token: Token, test: string) {\n    if (token.end - token.start !== test.length) return false;\n    if (token.value != null) return token.value === test;\n    return this._source.startsWith(test, token.start);\n  }\n\n  startMatches(node: t.Node, test: string): boolean {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (!indexes) return false;\n    const tok = this._tokens[indexes[0]];\n    if (tok.start !== node.start) return false;\n    return this.matchesOriginal(tok, test);\n  }\n\n  endMatches(node: t.Node, test: string): boolean {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (!indexes) return false;\n    const tok = this._tokens[indexes[indexes.length - 1]];\n    if (tok.end !== node.end) return false;\n    return this.matchesOriginal(tok, test);\n  }\n\n  _getTokensIndexesOfNode(node: t.Node): number[] {\n    if (node.start == null || node.end == null) return [];\n\n    const { first, last } = this._findTokensOfNode(\n      node,\n      0,\n      this._tokens.length - 1,\n    );\n\n    let low = first;\n\n    const children = childrenIterator(node);\n\n    if (\n      (node.type === \"ExportNamedDeclaration\" ||\n        node.type === \"ExportDefaultDeclaration\") &&\n      node.declaration?.type === \"ClassDeclaration\"\n    ) {\n      // Exported class declarations can be not properly nested inside\n      // the export declaration that contains them. For example, in\n      // `@dec export class Foo {}` the `export` is covered by the\n      // ClassDeclaration range. Skip the class declaration from the list\n      // of children to skip, so that when looking for `export` we also\n      // traverse its tokens.\n      children.next();\n    }\n\n    const indexes = [];\n\n    for (const child of children) {\n      if (child == null) continue;\n      if (child.start == null || child.end == null) continue;\n\n      const childTok = this._findTokensOfNode(child, low, last);\n\n      const high = childTok.first;\n      for (let k = low; k < high; k++) indexes.push(k);\n\n      low = childTok.last + 1;\n    }\n\n    for (let k = low; k <= last; k++) indexes.push(k);\n\n    return indexes;\n  }\n\n  _findTokensOfNode(node: t.Node, low: number, high: number) {\n    const cached = this._tokensCache.get(node);\n    if (cached) return cached;\n\n    const first = this._findFirstTokenOfNode(node.start!, low, high);\n    const last = this._findLastTokenOfNode(node.end!, first, high);\n\n    this._tokensCache.set(node, { first, last });\n    return { first, last };\n  }\n\n  _findFirstTokenOfNode(start: number, low: number, high: number): number {\n    while (low <= high) {\n      const mid = (high + low) >> 1;\n      if (start < this._tokens[mid].start) {\n        high = mid - 1;\n      } else if (start > this._tokens[mid].start) {\n        low = mid + 1;\n      } else {\n        return mid;\n      }\n    }\n    return low;\n  }\n\n  _findLastTokenOfNode(end: number, low: number, high: number): number {\n    while (low <= high) {\n      const mid = (high + low) >> 1;\n      if (end < this._tokens[mid].end) {\n        high = mid - 1;\n      } else if (end > this._tokens[mid].end) {\n        low = mid + 1;\n      } else {\n        return mid;\n      }\n    }\n    return high;\n  }\n}\n\nfunction* childrenIterator(node: t.Node) {\n  // We need special handling to iterate TemplateLiteral\n  // children in order, since the two lists are interleaved.\n  if (node.type === \"TemplateLiteral\") {\n    yield node.quasis[0];\n    for (let i = 1; i < node.quasis.length; i++) {\n      yield node.expressions[i - 1];\n      yield node.quasis[i];\n    }\n    return;\n  }\n\n  const keys = VISITOR_KEYS[node.type];\n  for (const key of keys) {\n    const child = (node as any)[key];\n    if (!child) continue;\n    if (Array.isArray(child)) {\n      yield* child;\n    } else {\n      yield child;\n    }\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n\nimport Buffer from \"./buffer.ts\";\nimport type { Loc, Pos } from \"./buffer.ts\";\nimport { isLastChild, parentNeedsParens } from \"./node/index.ts\";\nimport { generatorInfosMap } from \"./nodes.ts\";\nimport type * as t from \"@babel/types\";\nimport {\n  isExpression,\n  isFunction,\n  isStatement,\n  isClassBody,\n  isTSInterfaceBody,\n  isTSEnumMember,\n} from \"@babel/types\";\nimport type { Opts as jsescOptions } from \"jsesc\";\n\nimport { TokenMap } from \"./token-map.ts\";\n\nimport type { GeneratorOptions } from \"./index.ts\";\nimport type SourceMap from \"./source-map.ts\";\nimport type { TraceMap } from \"@jridgewell/trace-mapping\";\nimport type { Token } from \"@babel/parser\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst HAS_NEWLINE = /[\\n\\r\\u2028\\u2029]/;\nconst HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\\n\\r\\u2028\\u2029]|\\*\\//;\n\nfunction commentIsNewline(c: t.Comment) {\n  return c.type === \"CommentLine\" || HAS_NEWLINE.test(c.value);\n}\n\nimport { TokenContext } from \"./node/index.ts\";\nimport { _getRawIdentifier } from \"./generators/types.ts\";\n\nconst enum COMMENT_TYPE {\n  LEADING,\n  INNER,\n  TRAILING,\n}\n\nconst enum COMMENT_SKIP_NEWLINE {\n  DEFAULT,\n  ALL,\n  LEADING,\n  TRAILING,\n}\n\nconst enum PRINT_COMMENT_HINT {\n  SKIP,\n  ALLOW,\n  DEFER,\n}\n\nconst enum PRINTER_FLAGS {\n  EMPTY = 0,\n  PRESERVE_FORMAT = 1 << 0,\n  COMPACT = 1 << 1,\n  CONCISE = 1 << 2,\n  RETAIN_LINES = 1 << 3,\n  RETAIN_FUNCTION_PARENS = 1 << 4,\n  AUX_COMMENTS = 1 << 5,\n}\n\nconst enum LAST_CHAR_KINDS {\n  EMPTY = 0,\n  NORMAL = -1,\n  INTEGER = -2,\n  WORD = -3,\n}\n\nconst enum INNER_COMMENTS_STATE {\n  DISALLOWED = 0,\n  ALLOWED = 1,\n  PRINTED = 2,\n\n  WITH_INDENT = 4,\n  MASK = 3,\n}\n\nconst enum PRINT_COMMENTS_RESULT {\n  PRINTED_NONE = 0,\n  PRINTED_SOME = 1,\n  PRINTED_ALL = 2,\n}\n\nexport type Format = {\n  shouldPrintComment: (comment: string) => boolean;\n  preserveFormat: boolean | undefined;\n  retainLines: boolean | undefined;\n  retainFunctionParens: boolean | undefined;\n  comments: boolean | undefined;\n  auxiliaryCommentBefore: string | undefined;\n  auxiliaryCommentAfter: string | undefined;\n  compact: boolean | \"auto\" | undefined;\n  minified: boolean | undefined;\n  concise: boolean | undefined;\n  indent: {\n    adjustMultilineComment: boolean;\n    style: string;\n  };\n  jsescOption: jsescOptions;\n  /**\n   * For use with the Hack-style pipe operator.\n   * Changes what token is used for pipe bodies topic references.\n   */\n  topicToken?: GeneratorOptions[\"topicToken\"];\n};\n\ninterface PrintSequenceOptions {\n  statement?: boolean;\n  indent?: boolean;\n  trailingCommentsLineOffset?: number;\n}\n\ninterface PrintListOptions {\n  separator?: (this: Printer, occurrenceCount: number, last: boolean) => void;\n  statement?: boolean;\n  indent?: boolean;\n  printTrailingSeparator?: boolean;\n}\n\nexport type PrintJoinOptions = PrintListOptions & PrintSequenceOptions;\nclass Printer {\n  constructor(\n    format: Format,\n    map: SourceMap | null,\n    tokens: Token[] | null = null,\n    originalCode: string | null = null,\n  ) {\n    this.format = format;\n\n    this._tokens = tokens;\n    this._originalCode = originalCode;\n\n    this._indentRepeat = format.indent.style.length;\n\n    this._inputMap = map?._inputMap || null;\n\n    this._buf = new Buffer(map, format.indent.style[0]);\n\n    const {\n      preserveFormat,\n      compact,\n      concise,\n      retainLines,\n      retainFunctionParens,\n    } = format;\n    if (preserveFormat) {\n      this._flags |= PRINTER_FLAGS.PRESERVE_FORMAT;\n    }\n    if (compact) {\n      this._flags |= PRINTER_FLAGS.COMPACT;\n    }\n    if (concise) {\n      this._flags |= PRINTER_FLAGS.CONCISE;\n    }\n    if (retainLines) {\n      this._flags |= PRINTER_FLAGS.RETAIN_LINES;\n    }\n    if (retainFunctionParens) {\n      this._flags |= PRINTER_FLAGS.RETAIN_FUNCTION_PARENS;\n    }\n    if (format.auxiliaryCommentBefore || format.auxiliaryCommentAfter) {\n      this._flags |= PRINTER_FLAGS.AUX_COMMENTS;\n    }\n  }\n  declare _inputMap: TraceMap | null;\n\n  declare format: Format;\n\n  enterDelimited() {\n    const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n    if (oldNoLineTerminatorAfterNode !== null) {\n      this._noLineTerminatorAfterNode = null;\n    }\n    return oldNoLineTerminatorAfterNode;\n  }\n\n  tokenContext: number = TokenContext.normal;\n\n  _tokens: Token[] | null = null;\n  _originalCode: string | null = null;\n\n  declare _buf: Buffer;\n  _currentNode: t.Node | null = null;\n  _currentTypeId: number | null = null;\n  _indent: number = 0;\n  _indentRepeat: number = 0;\n  _insideAux: boolean = false;\n  _noLineTerminator: boolean = false;\n  _noLineTerminatorAfterNode: t.Node | null = null;\n  _printAuxAfterOnNextUserNode: boolean = false;\n  _printedComments = new Set<t.Comment>();\n  _lastCommentLine = 0;\n  _innerCommentsState = INNER_COMMENTS_STATE.DISALLOWED;\n  _flags = PRINTER_FLAGS.EMPTY;\n\n  tokenMap: TokenMap | null = null;\n\n  _boundGetRawIdentifier: ((node: t.Identifier) => string) | null = null;\n\n  generate(ast: t.Node) {\n    if (this.format.preserveFormat) {\n      this.tokenMap = new TokenMap(ast, this._tokens!, this._originalCode!);\n      this._boundGetRawIdentifier = _getRawIdentifier.bind(this);\n    }\n    this.print(ast);\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  /**\n   * Increment indent size.\n   */\n\n  indent(flags = this._flags): void {\n    if (\n      flags &\n      (PRINTER_FLAGS.PRESERVE_FORMAT |\n        PRINTER_FLAGS.COMPACT |\n        PRINTER_FLAGS.CONCISE)\n    ) {\n      return;\n    }\n\n    this._indent += this._indentRepeat;\n  }\n\n  /**\n   * Decrement indent size.\n   */\n\n  dedent(flags = this._flags): void {\n    if (\n      flags &\n      (PRINTER_FLAGS.PRESERVE_FORMAT |\n        PRINTER_FLAGS.COMPACT |\n        PRINTER_FLAGS.CONCISE)\n    ) {\n      return;\n    }\n\n    this._indent -= this._indentRepeat;\n  }\n\n  /**\n   * If the next token is on the same line, we must first print a semicolon.\n   * This option is only used in `preserveFormat` node, for semicolons that\n   * might have omitted due to them being absent in the original code (thanks\n   * to ASI).\n   *\n   * We need both *NextToken and *NextNode because we only want to insert the\n   * semicolon when the next token starts a new node, and not in cases like\n   * foo} (where } is not starting a new node). So we first set *NextNode, and\n   * then the print() method will move it to *NextToken.\n   */\n  _printSemicolonBeforeNextNode: number = -1;\n  _printSemicolonBeforeNextToken: number = -1;\n\n  /**\n   * Add a semicolon to the buffer.\n   */\n  semicolon(force: boolean = false): void {\n    const flags = this._flags;\n    if (flags & PRINTER_FLAGS.AUX_COMMENTS) {\n      this._maybeAddAuxComment();\n    }\n    if (flags & PRINTER_FLAGS.PRESERVE_FORMAT) {\n      const node = this._currentNode!;\n      if (node.start != null && node.end != null) {\n        if (!this.tokenMap!.endMatches(node, \";\")) {\n          // no semicolon\n          this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();\n          return;\n        }\n        const indexes = this.tokenMap!.getIndexes(this._currentNode!)!;\n        this._catchUpTo(this._tokens![indexes[indexes.length - 1]].loc.start);\n      }\n    }\n    if (force) {\n      this._appendChar(charCodes.semicolon);\n    } else {\n      this._queue(charCodes.semicolon);\n    }\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a right brace to the buffer.\n   */\n\n  rightBrace(node: t.Node): void {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.token(\"}\");\n  }\n\n  rightParens(node: t.Node): void {\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.token(\")\");\n  }\n\n  /**\n   * Add a space to the buffer unless it is compact.\n   */\n\n  space(force: boolean = false): void {\n    if (this._flags & (PRINTER_FLAGS.PRESERVE_FORMAT | PRINTER_FLAGS.COMPACT)) {\n      return;\n    }\n\n    if (force) {\n      this._space();\n    } else {\n      const lastCp = this.getLastChar(true);\n      if (\n        lastCp !== 0 &&\n        lastCp !== charCodes.space &&\n        lastCp !== charCodes.lineFeed\n      ) {\n        this._space();\n      }\n    }\n  }\n\n  /**\n   * Writes a token that can't be safely parsed without taking whitespace into account.\n   */\n\n  word(str: string, noLineTerminatorAfter: boolean = false): void {\n    this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n\n    this._maybePrintInnerComments(str);\n\n    const flags = this._flags;\n    if (flags & PRINTER_FLAGS.AUX_COMMENTS) {\n      this._maybeAddAuxComment();\n    }\n\n    if (flags & PRINTER_FLAGS.PRESERVE_FORMAT) this._catchUpToCurrentToken(str);\n\n    const lastChar = this.getLastChar();\n\n    if (\n      lastChar === LAST_CHAR_KINDS.INTEGER ||\n      lastChar === LAST_CHAR_KINDS.WORD ||\n      // prevent concatenating words and creating // comment out of division and regex\n      (lastChar === charCodes.slash && str.charCodeAt(0) === charCodes.slash)\n    ) {\n      this._space();\n    }\n    this._append(str, false);\n\n    this.setLastChar(-3);\n    this._noLineTerminator = noLineTerminatorAfter;\n  }\n\n  /**\n   * Writes a number token so that we can validate if it is an integer.\n   */\n\n  number(str: string, number?: number): void {\n    // const NON_DECIMAL_LITERAL = /^0[box]/;\n    function isNonDecimalLiteral(str: string) {\n      if (str.length > 2 && str.charCodeAt(0) === charCodes.digit0) {\n        const secondChar = str.charCodeAt(1);\n        return (\n          secondChar === charCodes.lowercaseB ||\n          secondChar === charCodes.lowercaseO ||\n          secondChar === charCodes.lowercaseX\n        );\n      }\n      return false;\n    }\n    this.word(str);\n\n    // Integer tokens need special handling because they cannot have '.'s inserted immediately after them.\n    if (\n      Number.isInteger(number) &&\n      !isNonDecimalLiteral(str) &&\n      !SCIENTIFIC_NOTATION.test(str) &&\n      !ZERO_DECIMAL_INTEGER.test(str) &&\n      str.charCodeAt(str.length - 1) !== charCodes.dot\n    ) {\n      this.setLastChar(LAST_CHAR_KINDS.INTEGER);\n    }\n  }\n\n  /**\n   * Writes a simple token.\n   *\n   * @param {string} str The string to append.\n   * @param {boolean} [maybeNewline=false] Wether `str` might potentially\n   *    contain a line terminator or not.\n   * @param {number} [occurrenceCount=0] The occurrence count of this token in\n   *    the current node. This is used when printing in `preserveFormat` mode,\n   *    to know which token we should map to (for example, to disambiguate the\n   *    commas in an array literal).\n   */\n  token(\n    str: string,\n    maybeNewline = false,\n    occurrenceCount = 0,\n    mayNeedSpace: boolean = false,\n  ): void {\n    this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n\n    this._maybePrintInnerComments(str, occurrenceCount);\n\n    const flags = this._flags;\n\n    if (flags & PRINTER_FLAGS.AUX_COMMENTS) {\n      this._maybeAddAuxComment();\n    }\n\n    if (flags & PRINTER_FLAGS.PRESERVE_FORMAT) {\n      this._catchUpToCurrentToken(str, occurrenceCount);\n    }\n\n    if (mayNeedSpace) {\n      const strFirst = str.charCodeAt(0);\n      if (\n        // space is mandatory to avoid outputting <!--\n        // http://javascript.spec.whatwg.org/#comment-syntax\n        (((strFirst === charCodes.dash && str === \"--\") ||\n          // Needs spaces to avoid changing a! == 0 to a!== 0\n          strFirst === charCodes.equalsTo) &&\n          this.getLastChar() === charCodes.exclamationMark) ||\n        // Need spaces for operators of the same kind to avoid: `a+++b`\n        (strFirst === charCodes.plusSign &&\n          this.getLastChar() === charCodes.plusSign) ||\n        (strFirst === charCodes.dash &&\n          this.getLastChar() === charCodes.dash) ||\n        // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n        (strFirst === charCodes.dot &&\n          this.getLastChar() === LAST_CHAR_KINDS.INTEGER)\n      ) {\n        this._space();\n      }\n    }\n    this._append(str, maybeNewline);\n    this._noLineTerminator = false;\n  }\n\n  tokenChar(char: number, occurrenceCount = 0): void {\n    this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n\n    this._maybePrintInnerComments(char, occurrenceCount);\n\n    const flags = this._flags;\n\n    if (flags & PRINTER_FLAGS.AUX_COMMENTS) {\n      this._maybeAddAuxComment();\n    }\n\n    if (flags & PRINTER_FLAGS.PRESERVE_FORMAT) {\n      this._catchUpToCurrentToken(char, occurrenceCount);\n    }\n\n    if (\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (char === charCodes.plusSign &&\n        this.getLastChar() === charCodes.plusSign) ||\n      (char === charCodes.dash && this.getLastChar() === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (char === charCodes.dot && this.getLastChar() === LAST_CHAR_KINDS.INTEGER)\n    ) {\n      this._space();\n    }\n    this._appendChar(char);\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a newline (or many newlines), maintaining formatting.\n   * This function checks the number of newlines in the queue and subtracts them.\n   * It currently has some limitations.\n   * @see {Buffer#getNewlineCount}\n   */\n  newline(i: number = 1, flags = this._flags): void {\n    if (i <= 0) return;\n\n    if (flags & (PRINTER_FLAGS.RETAIN_LINES | PRINTER_FLAGS.COMPACT)) {\n      return;\n    }\n\n    if (flags & PRINTER_FLAGS.CONCISE) {\n      this.space();\n      return;\n    }\n\n    if (i > 2) i = 2; // Max two lines\n\n    i -= this._buf.getNewlineCount();\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n  }\n\n  endsWith(char: number): boolean {\n    return this.getLastChar(true) === char;\n  }\n\n  getLastChar(checkQueue?: boolean): number {\n    return this._buf.getLastChar(checkQueue);\n  }\n\n  setLastChar(char: number) {\n    this._buf._last = char;\n  }\n\n  exactSource(loc: Loc | null | undefined, cb: () => void) {\n    if (!loc) {\n      cb();\n      return;\n    }\n\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop: \"start\" | \"end\", loc: Loc | undefined): void {\n    if (!loc) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc | null | undefined,\n    columnOffset: number,\n  ): void {\n    if (!loc || this.format.preserveFormat) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.sourceWithOffset(prop, loc, columnOffset);\n  }\n\n  sourceIdentifierName(identifierName: string, pos?: Pos): void {\n    if (!this._buf._canMarkIdName) return;\n\n    const sourcePosition = this._buf._sourcePosition;\n    sourcePosition.identifierNamePos = pos;\n    sourcePosition.identifierName = identifierName;\n  }\n\n  _space(): void {\n    this._queue(charCodes.space);\n  }\n\n  _newline(): void {\n    // Drop trailing spaces when a newline is inserted.\n    if (this._buf._queuedChar === charCodes.space) this._buf._queuedChar = 0;\n\n    this._appendChar(charCodes.lineFeed, true);\n  }\n\n  _catchUpToCurrentToken(\n    str: string | number,\n    occurrenceCount: number = 0,\n  ): void {\n    // Assert: this.tokenMap\n\n    const token = this.tokenMap!.findMatching(\n      this._currentNode!,\n      str,\n      occurrenceCount,\n    );\n    if (token) this._catchUpTo(token.loc.start);\n\n    if (\n      this._printSemicolonBeforeNextToken !== -1 &&\n      this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()\n    ) {\n      this._appendChar(charCodes.semicolon, true);\n    }\n    this._printSemicolonBeforeNextToken = -1;\n    this._printSemicolonBeforeNextNode = -1;\n  }\n\n  _append(str: string, maybeNewline: boolean): void {\n    this._maybeIndent();\n\n    this._buf.append(str, maybeNewline);\n  }\n\n  _appendChar(char: number, noIndent?: boolean): void {\n    if (!noIndent) {\n      this._maybeIndent();\n    }\n\n    this._buf.appendChar(char);\n  }\n\n  _queue(char: typeof charCodes.space | typeof charCodes.semicolon): void {\n    this._buf.queue(char);\n\n    this.setLastChar(-1);\n  }\n\n  _maybeIndent(): void {\n    const indent = this._shouldIndent();\n    if (indent > 0) {\n      this._buf._appendChar(-1, indent, false);\n    }\n  }\n\n  _shouldIndent() {\n    // we've got a newline before us so prepend on the indentation\n    return this.endsWith(charCodes.lineFeed) ? this._indent : 0;\n  }\n\n  catchUp(line: number) {\n    if (!this.format.retainLines) return;\n\n    // catch up to this nodes newline if we're behind\n    const count = line - this._buf.getCurrentLine();\n\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n  }\n\n  _catchUp(prop: \"start\" | \"end\", loc?: Loc) {\n    const flags = this._flags;\n    if ((flags & PRINTER_FLAGS.PRESERVE_FORMAT) === 0) {\n      if (flags & PRINTER_FLAGS.RETAIN_LINES && loc?.[prop]) {\n        this.catchUp(loc[prop].line);\n      }\n      return;\n    }\n\n    // catch up to this nodes newline if we're behind\n    const pos = loc?.[prop];\n    if (pos != null) this._catchUpTo(pos);\n  }\n\n  _catchUpTo({ line, column, index }: Pos) {\n    const count = line - this._buf.getCurrentLine();\n    if (count > 0 && this._noLineTerminator) {\n      // We cannot inject new lines when _noLineTemrinator is set\n      // to `true`, or we would generate invalid code.\n      return;\n    }\n\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n\n    const spacesCount =\n      count > 0 ? column : column - this._buf.getCurrentColumn();\n    if (spacesCount > 0) {\n      const spaces = this._originalCode\n        ? this._originalCode\n            .slice(index - spacesCount, index)\n            // https://tc39.es/ecma262/#sec-white-space\n            .replace(/[^\\t\\v\\f\\uFEFF\\p{Space_Separator}]/gu, \" \")\n        : \" \".repeat(spacesCount);\n      this._append(spaces, false);\n      this.setLastChar(charCodes.space);\n    }\n  }\n\n  printTerminatorless(node: t.Node) {\n    /**\n     * Set some state that will be modified if a newline has been inserted before any\n     * non-space characters.\n     *\n     * This is to prevent breaking semantics for terminatorless separator nodes. eg:\n     *\n     *   return foo;\n     *\n     * returns `foo`. But if we do:\n     *\n     *   return\n     *   foo;\n     *\n     *  `undefined` will be returned and not `foo` due to the terminator.\n     */\n    this._noLineTerminator = true;\n    this.print(node);\n  }\n\n  print(\n    node: t.Node | null | undefined,\n    noLineTerminatorAfter: boolean = false,\n    resetTokenContext: boolean = false,\n    // trailingCommentsLineOffset also used to check if called from printJoin\n    // it will be ignored if `noLineTerminatorAfter||this._noLineTerminator`\n    trailingCommentsLineOffset?: number,\n  ) {\n    if (!node) return;\n\n    this._innerCommentsState = INNER_COMMENTS_STATE.DISALLOWED;\n\n    const { type, loc, extra } = node;\n\n    const flags = this._flags;\n    let changedFlags = false;\n    if (\n      // @ts-expect-error document _compact AST properties\n      node._compact\n    ) {\n      this._flags |= PRINTER_FLAGS.CONCISE;\n      changedFlags = true;\n    }\n\n    const nodeInfo = generatorInfosMap.get(type);\n    if (nodeInfo === undefined) {\n      throw new ReferenceError(\n        `unknown node of type ${JSON.stringify(\n          type,\n        )} with constructor ${JSON.stringify(node.constructor.name)}`,\n      );\n    }\n\n    const [printMethod, nodeId, needsParens] = nodeInfo;\n\n    const parent = this._currentNode;\n    const parentId = this._currentTypeId;\n    this._currentNode = node;\n    this._currentTypeId = nodeId;\n\n    if (flags & PRINTER_FLAGS.PRESERVE_FORMAT) {\n      this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;\n    }\n\n    let oldInAux;\n    if (flags & PRINTER_FLAGS.AUX_COMMENTS) {\n      oldInAux = this._insideAux;\n      this._insideAux = loc == null;\n      this._maybeAddAuxComment(this._insideAux && !oldInAux);\n    }\n\n    let oldTokenContext = 0;\n    if (resetTokenContext) {\n      oldTokenContext = this.tokenContext;\n      if (oldTokenContext & TokenContext.forInOrInitHeadAccumulate) {\n        this.tokenContext = 0;\n      } else {\n        oldTokenContext = 0;\n      }\n    }\n\n    const parenthesized =\n      extra != null && (extra.parenthesized as boolean | undefined);\n    let shouldPrintParens =\n      (parenthesized && flags & PRINTER_FLAGS.PRESERVE_FORMAT) ||\n      (parenthesized &&\n        flags & PRINTER_FLAGS.RETAIN_FUNCTION_PARENS &&\n        nodeId === __node(\"FunctionExpression\")) ||\n      (parent &&\n        (parentNeedsParens(node, parent, parentId!) ||\n          // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n          (needsParens != null &&\n            needsParens(\n              node,\n              parent,\n              parentId!,\n              this.tokenContext,\n              flags & PRINTER_FLAGS.PRESERVE_FORMAT\n                ? this._boundGetRawIdentifier!\n                : undefined,\n            ))));\n\n    if (\n      !shouldPrintParens &&\n      parenthesized &&\n      node.leadingComments?.length &&\n      node.leadingComments[0].type === \"CommentBlock\"\n    ) {\n      switch (parentId) {\n        case __node(\"ExpressionStatement\"):\n        case __node(\"VariableDeclarator\"):\n        case __node(\"AssignmentExpression\"):\n        case __node(\"ReturnStatement\"):\n          break;\n        case __node(\"CallExpression\"):\n        case __node(\"OptionalCallExpression\"):\n        case __node(\"NewExpression\"):\n          // @ts-expect-error checked by parentTypeId\n          if (parent.callee !== node) break;\n        // falls through\n        default:\n          shouldPrintParens = true;\n      }\n    }\n\n    let indentParenthesized = false;\n    if (\n      !shouldPrintParens &&\n      this._noLineTerminator &&\n      (node.leadingComments?.some(commentIsNewline) ||\n        (flags & PRINTER_FLAGS.RETAIN_LINES &&\n          loc &&\n          loc.start.line > this._buf.getCurrentLine()))\n    ) {\n      shouldPrintParens = true;\n      indentParenthesized = true;\n    }\n\n    let oldNoLineTerminatorAfterNode;\n    if (!shouldPrintParens) {\n      noLineTerminatorAfter ||=\n        !!parent &&\n        this._noLineTerminatorAfterNode === parent &&\n        isLastChild(parent, node);\n      if (noLineTerminatorAfter) {\n        if (node.trailingComments?.some(commentIsNewline)) {\n          if (isExpression(node)) shouldPrintParens = true;\n        } else {\n          oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n          this._noLineTerminatorAfterNode = node;\n        }\n      }\n    }\n\n    if (shouldPrintParens) {\n      this.token(\"(\");\n      if (indentParenthesized) this.indent();\n      this._innerCommentsState = INNER_COMMENTS_STATE.DISALLOWED;\n      if (!resetTokenContext) {\n        oldTokenContext = this.tokenContext;\n      }\n      if (oldTokenContext & TokenContext.forInOrInitHeadAccumulate) {\n        this.tokenContext = 0;\n      }\n      oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n      this._noLineTerminatorAfterNode = null;\n    }\n\n    this._printLeadingComments(node, parent);\n\n    this.exactSource(\n      nodeId === __node(\"Program\") || nodeId === __node(\"File\") ? null : loc,\n      printMethod.bind(this, node, parent),\n    );\n\n    if (shouldPrintParens) {\n      this._printTrailingComments(node, parent);\n      if (indentParenthesized) {\n        this.dedent();\n        this.newline();\n      }\n      this.token(\")\");\n      this._noLineTerminator = noLineTerminatorAfter;\n    } else if (noLineTerminatorAfter && !this._noLineTerminator) {\n      this._noLineTerminator = true;\n      this._printTrailingComments(node, parent);\n    } else {\n      this._printTrailingComments(node, parent, trailingCommentsLineOffset);\n    }\n    if (oldTokenContext) this.tokenContext = oldTokenContext;\n\n    // end\n    this._currentNode = parent;\n    this._currentTypeId = parentId;\n    if (changedFlags) {\n      this._flags = flags;\n    }\n    if (flags & PRINTER_FLAGS.AUX_COMMENTS) {\n      this._insideAux = oldInAux!;\n    }\n\n    if (oldNoLineTerminatorAfterNode != null) {\n      this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n    }\n\n    this._innerCommentsState = INNER_COMMENTS_STATE.DISALLOWED;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode?: boolean) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n\n    const comment = this.format.auxiliaryCommentBefore;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n\n    const comment = this.format.auxiliaryCommentAfter;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  getPossibleRaw(\n    node:\n      | t.StringLiteral\n      | t.NumericLiteral\n      | t.BigIntLiteral\n      | t.DirectiveLiteral\n      | t.JSXText,\n  ): string | undefined {\n    const extra = node.extra;\n    if (\n      extra?.raw != null &&\n      extra.rawValue != null &&\n      node.value === extra.rawValue\n    ) {\n      // @ts-expect-error: The extra.raw of these AST node types must be a string\n      return extra.raw;\n    }\n  }\n\n  printJoin(\n    nodes: t.Node[] | undefined | null,\n    statement?: boolean,\n    indent?: boolean,\n    separator?: PrintJoinOptions[\"separator\"] | null,\n    printTrailingSeparator?: boolean | null,\n    resetTokenContext?: boolean,\n    trailingCommentsLineOffset?: number,\n  ) {\n    if (!nodes?.length) return;\n\n    const flags = this._flags;\n\n    if (indent == null && flags & PRINTER_FLAGS.RETAIN_LINES) {\n      const startLine = nodes[0].loc?.start.line;\n      if (startLine != null && startLine !== this._buf.getCurrentLine()) {\n        indent = true;\n      }\n    }\n\n    if (indent) this.indent(flags);\n\n    const len = nodes.length;\n    for (let i = 0; i < len; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n\n      // don't add newlines at the beginning of the file\n      if (statement && i === 0 && this._buf.hasContent()) {\n        this.newline(1, flags);\n      }\n\n      this.print(\n        node,\n        false,\n        resetTokenContext,\n        trailingCommentsLineOffset || 0,\n      );\n\n      if (separator != null) {\n        if (i < len - 1) separator.call(this, i, false);\n        else if (printTrailingSeparator) separator.call(this, i, true);\n      }\n\n      if (statement) {\n        if (i + 1 === len) {\n          this.newline(1, flags);\n        } else {\n          const lastCommentLine = this._lastCommentLine;\n          if (lastCommentLine > 0) {\n            const offset =\n              (nodes[i + 1].loc?.start.line || 0) - lastCommentLine;\n            if (offset >= 0) {\n              this.newline(offset || 1, flags);\n              continue;\n            }\n          }\n\n          this.newline(1, flags);\n        }\n      }\n    }\n\n    if (indent) this.dedent(flags);\n  }\n\n  printAndIndentOnComments(node: t.Node) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node);\n    if (indent) this.dedent();\n  }\n\n  printBlock(body: t.Statement) {\n    if (body.type !== \"EmptyStatement\") {\n      this.space();\n    }\n\n    this.print(body);\n  }\n\n  _printTrailingComments(\n    node: t.Node,\n    parent?: t.Node | null,\n    lineOffset?: number,\n  ) {\n    const { innerComments, trailingComments } = node;\n    // We print inner comments here, so that if for some reason they couldn't\n    // be printed in earlier locations they are still printed *somewhere*,\n    // even if at the end of the node.\n    if (innerComments?.length) {\n      this._printComments(\n        COMMENT_TYPE.TRAILING,\n        innerComments,\n        node,\n        parent,\n        lineOffset,\n      );\n    }\n    if (trailingComments?.length) {\n      this._printComments(\n        COMMENT_TYPE.TRAILING,\n        trailingComments,\n        node,\n        parent,\n        lineOffset,\n      );\n    } else {\n      this._lastCommentLine = 0;\n    }\n  }\n\n  _printLeadingComments(node: t.Node, parent: t.Node | null) {\n    const comments = node.leadingComments;\n    if (!comments?.length) return;\n    this._printComments(COMMENT_TYPE.LEADING, comments, node, parent);\n  }\n\n  _maybePrintInnerComments(\n    nextTokenStr: string | number,\n    nextTokenOccurrenceCount?: number,\n  ) {\n    const state = this._innerCommentsState;\n    switch (state & INNER_COMMENTS_STATE.MASK) {\n      case INNER_COMMENTS_STATE.DISALLOWED:\n        this._innerCommentsState =\n          INNER_COMMENTS_STATE.ALLOWED | INNER_COMMENTS_STATE.WITH_INDENT;\n        return;\n      case INNER_COMMENTS_STATE.ALLOWED:\n        this.printInnerComments(\n          (state & INNER_COMMENTS_STATE.WITH_INDENT) > 0,\n          this.tokenMap?.findMatching(\n            this._currentNode!,\n            nextTokenStr,\n            nextTokenOccurrenceCount,\n          ),\n        );\n    }\n  }\n\n  printInnerComments(indent = true, nextToken?: Token | null) {\n    const node = this._currentNode!;\n    const comments = node.innerComments;\n    if (!comments?.length) {\n      this._innerCommentsState = INNER_COMMENTS_STATE.PRINTED;\n      return;\n    }\n\n    const hasSpace = this.endsWith(charCodes.space);\n    if (indent) this.indent();\n\n    switch (\n      this._printComments(\n        COMMENT_TYPE.INNER,\n        comments,\n        node,\n        undefined,\n        undefined,\n        nextToken,\n      )\n    ) {\n      case PRINT_COMMENTS_RESULT.PRINTED_ALL:\n        this._innerCommentsState = INNER_COMMENTS_STATE.PRINTED;\n      // falls through\n      case PRINT_COMMENTS_RESULT.PRINTED_SOME:\n        if (hasSpace) this.space();\n    }\n\n    if (indent) this.dedent();\n  }\n\n  noIndentInnerCommentsHere() {\n    this._innerCommentsState &= ~INNER_COMMENTS_STATE.WITH_INDENT;\n  }\n\n  printSequence(\n    nodes: t.Node[],\n    indent?: boolean,\n    resetTokenContext?: boolean,\n    trailingCommentsLineOffset?: number,\n  ) {\n    this.printJoin(\n      nodes,\n      true,\n      indent ?? false,\n      undefined,\n      undefined,\n      resetTokenContext,\n      trailingCommentsLineOffset,\n    );\n  }\n\n  printList(\n    items: t.Node[] | null | undefined,\n    printTrailingSeparator?: boolean | null,\n    statement?: boolean,\n    indent?: boolean,\n    separator?: PrintListOptions[\"separator\"],\n    resetTokenContext?: boolean,\n  ) {\n    this.printJoin(\n      items,\n      statement,\n      indent,\n      separator ?? commaSeparator,\n      printTrailingSeparator,\n      resetTokenContext,\n    );\n  }\n\n  shouldPrintTrailingComma(listEnd: string | number): boolean | null {\n    if (!this.tokenMap) return null;\n\n    const listEndIndex = this.tokenMap.findLastIndex(\n      this._currentNode!,\n      token =>\n        this.tokenMap!.matchesOriginal(\n          token,\n          typeof listEnd === \"number\" ? String.fromCharCode(listEnd) : listEnd,\n        ),\n    );\n    if (listEndIndex <= 0) return null;\n    return this.tokenMap.matchesOriginal(this._tokens![listEndIndex - 1], \",\");\n  }\n\n  // Returns `PRINT_COMMENT_HINT.DEFER` if the comment cannot be printed in this position due to\n  // line terminators, signaling that the print comments loop can stop and\n  // resume printing comments at the next possible position. This happens when\n  // printing inner comments, since if we have an inner comment with a multiline\n  // there is at least one inner position where line terminators are allowed.\n  _shouldPrintComment(\n    comment: t.Comment,\n    nextToken?: Token | null,\n  ): PRINT_COMMENT_HINT {\n    // Some plugins (such as flow-strip-types) use this to mark comments as removed using the AST-root 'comments' property,\n    // where they can't manually mutate the AST node comment lists.\n    if (comment.ignore) return PRINT_COMMENT_HINT.SKIP;\n\n    if (this._printedComments.has(comment)) return PRINT_COMMENT_HINT.SKIP;\n\n    if (\n      this._noLineTerminator &&\n      HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)\n    ) {\n      return PRINT_COMMENT_HINT.DEFER;\n    }\n\n    if (nextToken && this.tokenMap) {\n      const commentTok = this.tokenMap.find(\n        this._currentNode!,\n        token => token.value === comment.value,\n      );\n      if (commentTok && commentTok.start > nextToken.start) {\n        return PRINT_COMMENT_HINT.DEFER;\n      }\n    }\n\n    this._printedComments.add(comment);\n\n    if (!this.format.shouldPrintComment(comment.value)) {\n      return PRINT_COMMENT_HINT.SKIP;\n    }\n\n    return PRINT_COMMENT_HINT.ALLOW;\n  }\n\n  _printComment(comment: t.Comment, skipNewLines: COMMENT_SKIP_NEWLINE) {\n    const noLineTerminator = this._noLineTerminator;\n    const isBlockComment = comment.type === \"CommentBlock\";\n\n    // Add a newline before and after a block comment, unless explicitly\n    // disallowed\n    const printNewLines =\n      isBlockComment &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.ALL &&\n      !noLineTerminator;\n\n    if (\n      printNewLines &&\n      this._buf.hasContent() &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.LEADING\n    ) {\n      this.newline(1);\n    }\n\n    switch (this.getLastChar(true)) {\n      // Avoid converting a / operator into a line comment by appending /* to it\n      case charCodes.slash:\n        this._space();\n      // falls through\n      case charCodes.leftSquareBracket:\n      case charCodes.leftCurlyBrace:\n      case charCodes.leftParenthesis:\n        break;\n\n      default:\n        this.space();\n    }\n\n    let val;\n    if (isBlockComment) {\n      val = `/*${comment.value}*/`;\n      if (this.format.indent.adjustMultilineComment) {\n        const offset = comment.loc?.start.column;\n        if (offset) {\n          const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n        if (this._flags & PRINTER_FLAGS.CONCISE) {\n          val = val.replace(/\\n(?!$)/g, `\\n`);\n        } else {\n          let indentSize = this.format.retainLines\n            ? 0\n            : this._buf.getCurrentColumn();\n\n          if (this._shouldIndent() || this.format.retainLines) {\n            indentSize += this._indent;\n          }\n\n          val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n        }\n      }\n    } else if (!noLineTerminator) {\n      val = `//${comment.value}`;\n    } else {\n      // It was a single-line comment, so it's guaranteed to not\n      // contain newlines and it can be safely printed as a block\n      // comment.\n      val = `/*${comment.value}*/`;\n    }\n\n    this.source(\"start\", comment.loc);\n    this._append(val, isBlockComment);\n\n    if (!isBlockComment && !noLineTerminator) {\n      this._newline();\n    }\n\n    if (printNewLines && skipNewLines !== COMMENT_SKIP_NEWLINE.TRAILING) {\n      this.newline(1);\n    }\n  }\n\n  _printComments(\n    type: COMMENT_TYPE,\n    comments: t.Comment[],\n    node: t.Node,\n    parent?: t.Node | null,\n    lineOffset: number = 0,\n    nextToken?: Token | null,\n  ): PRINT_COMMENTS_RESULT {\n    const nodeLoc = node.loc;\n    const len = comments.length;\n    let hasLoc = !!nodeLoc;\n    const nodeStartLine = hasLoc ? nodeLoc!.start.line : 0;\n    const nodeEndLine = hasLoc ? nodeLoc!.end.line : 0;\n    let lastLine = 0;\n    let leadingCommentNewline = 0;\n\n    const { _noLineTerminator, _flags } = this;\n\n    for (let i = 0; i < len; i++) {\n      const comment = comments[i];\n\n      const shouldPrint = this._shouldPrintComment(comment, nextToken);\n      if (shouldPrint === PRINT_COMMENT_HINT.DEFER) {\n        return i === 0\n          ? PRINT_COMMENTS_RESULT.PRINTED_NONE\n          : PRINT_COMMENTS_RESULT.PRINTED_SOME;\n      }\n      if (hasLoc && comment.loc && shouldPrint === PRINT_COMMENT_HINT.ALLOW) {\n        const commentStartLine = comment.loc.start.line;\n        const commentEndLine = comment.loc.end.line;\n        if (type === COMMENT_TYPE.LEADING) {\n          let offset = 0;\n          if (i === 0) {\n            // Because currently we cannot handle blank lines before leading comments,\n            // we always wrap before and after multi-line comments.\n            if (\n              this._buf.hasContent() &&\n              (comment.type === \"CommentLine\" ||\n                commentStartLine !== commentEndLine)\n            ) {\n              offset = leadingCommentNewline = 1;\n            }\n          } else {\n            offset = commentStartLine - lastLine;\n          }\n          lastLine = commentEndLine;\n\n          if (offset > 0 && !_noLineTerminator) {\n            this.newline(offset, _flags);\n          }\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n\n          if (i + 1 === len) {\n            const count = Math.max(\n              nodeStartLine - lastLine,\n              leadingCommentNewline,\n            );\n            if (count > 0 && !_noLineTerminator) {\n              this.newline(count, _flags);\n            }\n            lastLine = nodeStartLine;\n          }\n        } else if (type === COMMENT_TYPE.INNER) {\n          const offset =\n            commentStartLine - (i === 0 ? nodeStartLine : lastLine);\n          lastLine = commentEndLine;\n\n          if (offset > 0 && !_noLineTerminator) {\n            this.newline(offset, _flags);\n          }\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n\n          if (i + 1 === len) {\n            const count = Math.min(1, nodeEndLine - lastLine);\n            if (count > 0 && !_noLineTerminator) {\n              this.newline(count, _flags);\n            }\n            lastLine = nodeEndLine;\n          }\n        } else {\n          const offset =\n            commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);\n          lastLine = commentEndLine;\n\n          if (offset > 0 && !_noLineTerminator) {\n            this.newline(offset, _flags);\n          }\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n        }\n      } else {\n        hasLoc = false;\n        if (shouldPrint !== PRINT_COMMENT_HINT.ALLOW) {\n          continue;\n        }\n\n        if (len === 1) {\n          const singleLine = comment.loc\n            ? comment.loc.start.line === comment.loc.end.line\n            : !HAS_NEWLINE.test(comment.value);\n\n          const shouldSkipNewline =\n            singleLine &&\n            !isStatement(node) &&\n            !isClassBody(parent) &&\n            !isTSInterfaceBody(parent) &&\n            !isTSEnumMember(node);\n\n          if (type === COMMENT_TYPE.LEADING) {\n            this._printComment(\n              comment,\n              (shouldSkipNewline && node.type !== \"ObjectExpression\") ||\n                (singleLine && isFunction(parent) && parent.body === node)\n                ? COMMENT_SKIP_NEWLINE.ALL\n                : COMMENT_SKIP_NEWLINE.DEFAULT,\n            );\n          } else if (shouldSkipNewline && type === COMMENT_TYPE.TRAILING) {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n          } else {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n          }\n        } else if (\n          type === COMMENT_TYPE.INNER &&\n          !(node.type === \"ObjectExpression\" && node.properties.length > 1) &&\n          node.type !== \"ClassBody\" &&\n          node.type !== \"TSInterfaceBody\"\n        ) {\n          // class X {\n          //   /*:: a: number*/\n          //   /*:: b: ?string*/\n          // }\n\n          this._printComment(\n            comment,\n            i === 0\n              ? COMMENT_SKIP_NEWLINE.LEADING\n              : i === len - 1\n                ? COMMENT_SKIP_NEWLINE.TRAILING\n                : COMMENT_SKIP_NEWLINE.DEFAULT,\n          );\n        } else {\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n        }\n      }\n    }\n\n    if (type === COMMENT_TYPE.TRAILING && hasLoc && lastLine) {\n      this._lastCommentLine = lastLine;\n    }\n    return PRINT_COMMENTS_RESULT.PRINTED_ALL;\n  }\n}\n\nexport default Printer;\n\nfunction commaSeparator(this: Printer, occurrenceCount: number, last: boolean) {\n  this.tokenChar(charCodes.comma, occurrenceCount);\n  if (!last) this.space();\n}\n","import SourceMap from \"./source-map.ts\";\nimport Printer from \"./printer.ts\";\nimport type * as t from \"@babel/types\";\nimport type { Opts as jsescOptions } from \"jsesc\";\nimport type { Format } from \"./printer.ts\";\nimport type {\n  EncodedSourceMap,\n  DecodedSourceMap,\n  Mapping,\n} from \"@jridgewell/gen-mapping\";\n\n/**\n * Normalize generator options, setting defaults.\n *\n * - Detects code indentation.\n * - If `opts.compact = \"auto\"` and the code is over 500KB, `compact` will be set to `true`.\n */\n\nfunction normalizeOptions(\n  code: string | Record<string, string> | undefined,\n  opts: GeneratorOptions,\n  ast: t.Node,\n): Format {\n  if (opts.experimental_preserveFormat) {\n    if (typeof code !== \"string\") {\n      throw new Error(\n        \"`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string\",\n      );\n    }\n    if (!opts.retainLines) {\n      throw new Error(\n        \"`experimental_preserveFormat` requires `retainLines` to be set to `true`\",\n      );\n    }\n    if (opts.compact && opts.compact !== \"auto\") {\n      throw new Error(\n        \"`experimental_preserveFormat` is not compatible with the `compact` option\",\n      );\n    }\n    if (opts.minified) {\n      throw new Error(\n        \"`experimental_preserveFormat` is not compatible with the `minified` option\",\n      );\n    }\n    if (opts.jsescOption) {\n      throw new Error(\n        \"`experimental_preserveFormat` is not compatible with the `jsescOption` option\",\n      );\n    }\n    if (!Array.isArray((ast as any).tokens)) {\n      throw new Error(\n        \"`experimental_preserveFormat` requires the AST to have attached the token of the input code. Make sure to enable the `tokens: true` parser option.\",\n      );\n    }\n  }\n\n  const format: Format = {\n    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,\n    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,\n    // @ts-expect-error define it later\n    shouldPrintComment: opts.shouldPrintComment,\n    preserveFormat: opts.experimental_preserveFormat,\n    retainLines: opts.retainLines,\n    retainFunctionParens: opts.retainFunctionParens,\n    comments: opts.comments == null || opts.comments,\n    compact: opts.compact,\n    minified: opts.minified,\n    concise: opts.concise,\n    indent: {\n      adjustMultilineComment: true,\n      style: \"  \",\n    },\n    jsescOption: {\n      quotes: \"double\",\n      wrap: true,\n      minimal: true,\n      ...opts.jsescOption,\n    },\n    topicToken: opts.topicToken,\n  };\n\n  if (format.minified) {\n    format.compact = true;\n\n    format.shouldPrintComment =\n      format.shouldPrintComment || (() => format.comments);\n  } else {\n    format.shouldPrintComment =\n      format.shouldPrintComment ||\n      (value =>\n        format.comments ||\n        value.includes(\"@license\") ||\n        value.includes(\"@preserve\"));\n  }\n\n  if (format.compact === \"auto\") {\n    format.compact = typeof code === \"string\" && code.length > 500_000; // 500KB\n\n    if (format.compact) {\n      console.error(\n        \"[BABEL] Note: The code generator has deoptimised the styling of \" +\n          `${opts.filename} as it exceeds the max of ${\"500KB\"}.`,\n      );\n    }\n  }\n\n  if (format.compact || format.preserveFormat) {\n    format.indent.adjustMultilineComment = false;\n  }\n\n  const { auxiliaryCommentBefore, auxiliaryCommentAfter, shouldPrintComment } =\n    format;\n\n  if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {\n    format.auxiliaryCommentBefore = undefined;\n  }\n  if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {\n    format.auxiliaryCommentAfter = undefined;\n  }\n\n  return format;\n}\n\nexport interface GeneratorOptions {\n  /**\n   * Optional string to add as a block comment at the start of the output file.\n   */\n  auxiliaryCommentBefore?: string;\n\n  /**\n   * Optional string to add as a block comment at the end of the output file.\n   */\n  auxiliaryCommentAfter?: string;\n\n  /**\n   * Function that takes a comment (as a string) and returns true if the comment should be included in the output.\n   * By default, comments are included if `opts.comments` is `true` or if `opts.minified` is `false` and the comment\n   * contains `@preserve` or `@license`.\n   */\n  shouldPrintComment?(comment: string): boolean;\n\n  /**\n   * Preserve the input code format while printing the transformed code.\n   * This is experimental, and may have breaking changes in future\n   * patch releases. It will be removed in a future minor release,\n   * when it will graduate to stable.\n   */\n  experimental_preserveFormat?: boolean;\n\n  /**\n   * Attempt to use the same line numbers in the output code as in the source code (helps preserve stack traces).\n   * Defaults to `false`.\n   */\n  retainLines?: boolean;\n\n  /**\n   * Retain parens around function expressions (could be used to change engine parsing behavior)\n   * Defaults to `false`.\n   */\n  retainFunctionParens?: boolean;\n\n  /**\n   * Should comments be included in output? Defaults to `true`.\n   */\n  comments?: boolean;\n\n  /**\n   * Set to true to avoid adding whitespace for formatting. Defaults to the value of `opts.minified`.\n   */\n  compact?: boolean | \"auto\";\n\n  /**\n   * Should the output be minified. Defaults to `false`.\n   */\n  minified?: boolean;\n\n  /**\n   * Set to true to reduce whitespace (but not as much as opts.compact). Defaults to `false`.\n   */\n  concise?: boolean;\n\n  /**\n   * Used in warning messages\n   */\n  filename?: string;\n\n  /**\n   * Enable generating source maps. Defaults to `false`.\n   */\n  sourceMaps?: boolean;\n\n  inputSourceMap?: any;\n\n  /**\n   * A root for all relative URLs in the source map.\n   */\n  sourceRoot?: string;\n\n  /**\n   * The filename for the source code (i.e. the code in the `code` argument).\n   * This will only be used if `code` is a string.\n   */\n  sourceFileName?: string;\n\n  /**\n   * Options for outputting jsesc representation.\n   */\n  jsescOption?: jsescOptions;\n\n  /**\n   * For use with the Hack-style pipe operator.\n   * Changes what token is used for pipe bodies topic references.\n   */\n  topicToken?: \"%\" | \"#\" | \"@@\" | \"^^\" | \"^\";\n}\n\nexport interface GeneratorResult {\n  code: string;\n  map: EncodedSourceMap | null;\n  decodedMap: DecodedSourceMap | undefined;\n  rawMappings: Mapping[] | undefined;\n}\n\n/**\n * Turns an AST into code, maintaining sourcemaps, user preferences, and valid output.\n * @param ast - the abstract syntax tree from which to generate output code.\n * @param opts - used for specifying options for code generation.\n * @param code - the original source code, used for source maps.\n * @returns - an object containing the output code and source map.\n */\nexport function generate(\n  ast: t.Node,\n  opts: GeneratorOptions = {},\n  code?: string | Record<string, string>,\n): GeneratorResult {\n  const format = normalizeOptions(code, opts, ast);\n  const map = opts.sourceMaps ? new SourceMap(opts, code) : null;\n\n  const printer = new Printer(\n    format,\n    map,\n    (ast as any).tokens,\n    typeof code === \"string\" ? code : null,\n  );\n\n  return printer.generate(ast);\n}\n\nexport default generate;\n"],"names":["SourceMap","_map","_rawMappings","_sourceFileName","_lastGenLine","_lastSourceLine","_lastSourceColumn","_inputMap","constructor","opts","code","map","GenMapping","sourceRoot","sourceFileName","replace","undefined","inputSourceMap","TraceMap","resolvedSources","length","i","setSourceContent","sourcesContent","Object","keys","get","toEncodedMap","getDecoded","toDecodedMap","getRawMappings","allMappings","mark","generated","line","column","identifierName","identifierNamePos","filename","originalMapping","originalPositionFor","name","originalIdentifierMapping","source","maybeAddMapping","original","spaceIndents","push","repeat","Buffer","indentChar","_indentChar","_buf","_str","_appendCount","_last","_canMarkIdName","_queuedChar","_position","_sourcePosition","_flush","trimRight","decodedMap","rawMappings","result","__mergedMap","resultMap","value","defineProperty","writable","mappings","append","str","maybeNewline","_append","appendChar","char","_appendChar","queue","queuedChar","useSourcePos","indent","String","fromCharCode","isSpace","position","sourcePos","len","hasMap","indexOf","last","removeLastSemicolon","getLastChar","checkQueue","getNewlineCount","hasContent","exactSource","loc","cb","prop","_normalizePosition","sourceWithOffset","columnOffset","pos","target","Math","max","getCurrentColumn","getCurrentLine","isMemberExpression","isOptionalMemberExpression","isYieldExpression","isStatement","_t","PRECEDENCE","Map","isTSTypeExpression","nodeId","isClassExtendsClause","node","parent","parentId","superClass","hasPostfixPart","object","callee","tag","NullableTypeAnnotation","FunctionTypeAnnotation","tokenContext","UpdateExpression","needsParenBeforeExpressionBrace","TokenContext","ObjectExpression","DoExpression","async","BinaryLike","nodeType","parentPos","operator","nodePos","left","right","UnionTypeAnnotation","OptionalIndexedAccessType","objectType","TSAsExpression","TSConditionalType","checkType","extendsType","TSUnionType","TSIntersectionType","TSTypeOperator","TSInferType","typeParameter","constraint","TSInstantiationExpression","typeArguments","TSFunctionType","BinaryExpression","LogicalExpression","SequenceExpression","property","YieldExpression","test","ClassExpression","UnaryLike","FunctionExpression","ConditionalExpression","OptionalMemberExpression","AssignmentExpression","type","Identifier","getRawIdentifier","extra","parenthesized","rightType","id","isFollowedByBracket","computed","optional","await","TaggedTemplateExpression","print","quasi","TemplateElement","Error","_printTemplate","substitutions","quasis","partRaw","raw","token","TemplateLiteral","call","expressions","isCallExpression","isLiteral","isNewExpression","isPattern","UnaryExpression","firstChar","charCodeAt","word","space","tokenChar","argument","body","ParenthesizedExpression","oldNoLineTerminatorAfterNode","enterDelimited","expression","_noLineTerminatorAfterNode","rightParens","prefix","consequent","alternate","NewExpression","format","minified","arguments","tokenMap","endMatches","printList","shouldPrintTrailingComma","ThisExpression","Super","_shouldPrintDecoratorsBeforeExport","start","declaration","Decorator","newline","TypeError","OptionalCallExpression","CallExpression","Import","AwaitExpression","delegate","EmptyStatement","semicolon","ExpressionStatement","AssignmentPattern","typeAnnotation","setLastChar","BindExpression","MemberExpression","MetaProperty","meta","PrivateName","V8IntrinsicIdentifier","ModuleExpression","directives","dedent","rightBrace","isFor","isIfStatement","isVoidPattern","WithStatement","printBlock","IfStatement","needsBlock","getLastStatement","printAndIndentOnComments","endsWith","statement","ForStatement","init","update","WhileStatement","ForInStatement","noIndentInnerCommentsHere","ForOfStatement","DoWhileStatement","printStatementAfterKeyword","printer","printTerminatorless","BreakStatement","label","ContinueStatement","ReturnStatement","ThrowStatement","LabeledStatement","TryStatement","block","handlers","handler","finalizer","CatchClause","param","SwitchStatement","discriminant","printSequence","cases","SwitchCase","DebuggerStatement","commaSeparatorWithNewline","occurrenceCount","VariableDeclaration","declare","kind","hasInits","declar","declarations","VariableDeclarator","definite","isIdentifier","_params","noLineTerminator","idNode","parentNode","typeParameters","nameInfo","_getFuncIdName","sourceIdentifierName","_parameters","params","returnType","_noLineTerminator","parameters","endToken","trailingComma","paramLength","_param","parameter","printJoin","decorators","_methodHead","key","generator","_predicate","noLineTerminatorAfter","predicate","_functionHead","hasPredicate","preserveFormat","_innerCommentsState","ArrowFunctionExpression","_shouldPrintArrowParamsParens","printInnerComments","firstParam","leadingComments","trailingComments","findMatching","arrowToken","retainLines","parentType","TSTypeAnnotation","TSTypeParameterInstantiation","printTrailingSeparator","end","find","t","matchesOriginal","TSTypeParameter","const","in","out","default","TSParameterProperty","accessibility","readonly","TSDeclareFunction","TSDeclareMethod","_classMethodHead","TSQualifiedName","TSCallSignatureDeclaration","tsPrintSignatureDeclarationBase","maybePrintTrailingCommaOrSemicolon","TSConstructSignatureDeclaration","TSPropertySignature","tsPrintPropertyOrMethodName","TSMethodSignature","TSIndexSignature","static","isStatic","TSAnyKeyword","TSBigIntKeyword","TSUnknownKeyword","TSNumberKeyword","TSObjectKeyword","TSBooleanKeyword","TSStringKeyword","TSSymbolKeyword","TSVoidKeyword","TSUndefinedKeyword","TSNullKeyword","TSNeverKeyword","TSIntrinsicKeyword","TSThisType","tsPrintFunctionOrConstructorType","TSConstructorType","abstract","TSTypeReference","typeName","TSTypePredicate","asserts","parameterName","TSTypeQuery","exprName","TSTypeLiteral","printBraced","members","TSArrayType","elementType","TSTupleType","elementTypes","TSOptionalType","TSRestType","TSNamedTupleMember","tsPrintUnionOrIntersectionType","sep","hasLeadingToken","startMatches","types","trueType","falseType","TSParenthesizedType","TSIndexedAccessType","indexType","TSMappedType","nameType","tokenIfPlusMinus","self","tok","TSTemplateLiteralType","TSLiteralType","literal","TSClassImplements","TSInterfaceDeclaration","extends","extendz","TSInterfaceBody","TSTypeAliasDeclaration","TSSatisfiesExpression","TSTypeAssertion","TSEnumDeclaration","isConst","TSEnumBody","TSEnumMember","initializer","TSModuleDeclaration","TSModuleBlock","TSImportType","qualifier","options","TSImportEqualsDeclaration","moduleReference","TSExternalModuleReference","TSNonNullExpression","TSExportAssignment","TSNamespaceExportDeclaration","_tsPrintClassMemberModifiers","isPrivateField","isPublicField","printModifiersList","override","modifiers","modifiersSet","Set","modifier","add","has","delete","size","isClassDeclaration","isExportDefaultSpecifier","isExportNamespaceSpecifier","isImportDefaultSpecifier","isImportNamespaceSpecifier","ImportSpecifier","importKind","imported","local","ImportDefaultSpecifier","ExportDefaultSpecifier","exported","ExportSpecifier","exportKind","ExportNamespaceSpecifier","_printAttributes","hasPreviousBrace","attributes","ExportAllDeclaration","maybePrintDecoratorsBeforeExport","ExportNamedDeclaration","specifiers","slice","hasSpecial","first","shift","hasBrace","ExportDefaultDeclaration","ImportDeclaration","isTypeKind","module","phase","hasSpecifiers","ImportAttribute","ImportNamespaceSpecifier","ImportExpression","isAssignmentPattern","lastRawIdentResult","_getRawIdentifier","_originalCode","ArgumentPlaceholder","RestElement","props","properties","ObjectMethod","ObjectProperty","shorthand","ArrayExpression","elems","elements","elem","RegExpLiteral","pattern","flags","BooleanLiteral","NullLiteral","NumericLiteral","getPossibleRaw","jsescOption","numbers","number","jsesc","StringLiteral","val","BigIntLiteral","validTopicTokenSet","TopicReference","topicToken","givenTopicTokenJSON","JSON","stringify","validTopics","Array","from","v","join","VoidPattern","isDeclareExportDeclaration","AnyTypeAnnotation","ArrayTypeAnnotation","BooleanTypeAnnotation","BooleanLiteralTypeAnnotation","NullLiteralTypeAnnotation","DeclareClass","_interfaceish","DeclareFunction","InferredPredicate","DeclaredPredicate","DeclareInterface","InterfaceDeclaration","DeclareModule","DeclareModuleExports","DeclareTypeAlias","TypeAlias","DeclareOpaqueType","OpaqueType","DeclareVariable","DeclareExportDeclaration","FlowExportDeclaration","DeclareExportAllDeclaration","EnumDeclaration","enumExplicitType","context","hasExplicitType","enumBody","member","hasUnknownMembers","EnumBooleanBody","explicitType","EnumNumberBody","EnumStringBody","EnumSymbolBody","EnumDefaultedMember","enumInitializedMember","EnumBooleanMember","EnumNumberMember","EnumStringMember","ExistsTypeAnnotation","this","rest","method","FunctionTypeParam","InterfaceExtends","mixins","implements","_variance","variance","andSeparator","InterfaceTypeAnnotation","IntersectionTypeAnnotation","MixedTypeAnnotation","EmptyTypeAnnotation","NumberTypeAnnotation","StringTypeAnnotation","ThisTypeAnnotation","TupleTypeAnnotation","TypeofTypeAnnotation","TypeAnnotation","TypeParameterInstantiation","TypeParameter","bound","supertype","impltype","ObjectTypeAnnotation","exact","callProperties","indexers","internalSlots","inexact","ObjectTypeInternalSlot","ObjectTypeCallProperty","ObjectTypeIndexer","ObjectTypeProperty","proto","ObjectTypeSpreadProperty","QualifiedTypeIdentifier","qualification","SymbolTypeAnnotation","orSeparator","TypeCastExpression","Variance","VoidTypeAnnotation","IndexedAccessType","isExportDefaultDeclaration","isExportNamedDeclaration","ClassDeclaration","inExport","superTypeArguments","ClassBody","separator","classBodyEmptySemicolonsPrinter","indexes","getIndexes","k","nextLocIndex","advanceNextLocIndex","_tokens","ClassProperty","endLine","catchUp","ClassAccessorProperty","ClassPrivateProperty","ClassMethod","ClassPrivateMethod","StaticBlock","File","program","interpreter","Program","directivesLen","BlockStatement","Directive","unescapedSingleQuoteRE","unescapedDoubleQuoteRE","DirectiveLiteral","InterpreterDirective","_newline","Placeholder","expectedNode","JSXAttribute","JSXIdentifier","JSXNamespacedName","namespace","JSXMemberExpression","JSXSpreadAttribute","JSXExpressionContainer","JSXSpreadChild","JSXText","JSXElement","open","openingElement","selfClosing","child","children","closingElement","spaceSeparator","JSXOpeningElement","JSXClosingElement","JSXEmptyExpression","JSXFragment","openingFragment","closingFragment","JSXOpeningFragment","JSXClosingFragment","generatorInfosMap","index","generatorFunctions","sort","startsWith","set","VISITOR_KEYS","parens","func","isOrHasCallExpression","parentNeedsParens","isDecoratorMemberExpression","isLastChild","visitorKeys","isArray","j","traverseFast","TokenMap","_source","_nodesToTokenIndexes","_nodesOccurrencesCountCache","_tokensCache","ast","tokens","_getTokensIndexesOfNode","clear","condition","findLastIndex","count","cache","_findTokensOfNode","low","childrenIterator","next","childTok","high","cached","_findFirstTokenOfNode","_findLastTokenOfNode","mid","isExpression","isFunction","isClassBody","isTSInterfaceBody","isTSEnumMember","SCIENTIFIC_NOTATION","ZERO_DECIMAL_INTEGER","HAS_NEWLINE","HAS_NEWLINE_OR_BlOCK_COMMENT_END","commentIsNewline","c","Printer","originalCode","_indentRepeat","style","compact","concise","retainFunctionParens","_flags","auxiliaryCommentBefore","auxiliaryCommentAfter","_currentNode","_currentTypeId","_indent","_insideAux","_printAuxAfterOnNextUserNode","_printedComments","_lastCommentLine","_boundGetRawIdentifier","generate","bind","_maybeAddAuxComment","_printSemicolonBeforeNextNode","_printSemicolonBeforeNextToken","force","_catchUpTo","_queue","_space","lastCp","_maybePrintInnerComments","_catchUpToCurrentToken","lastChar","isNonDecimalLiteral","secondChar","Number","isInteger","mayNeedSpace","strFirst","_catchUp","sourcePosition","_maybeIndent","noIndent","_shouldIndent","spacesCount","spaces","resetTokenContext","trailingCommentsLineOffset","changedFlags","_compact","nodeInfo","ReferenceError","printMethod","needsParens","oldInAux","oldTokenContext","shouldPrintParens","indentParenthesized","some","_printLeadingComments","_printTrailingComments","enteredPositionlessNode","_printAuxBeforeComment","_printAuxAfterComment","comment","_printComment","rawValue","nodes","startLine","lastCommentLine","offset","lineOffset","innerComments","_printComments","comments","nextTokenStr","nextTokenOccurrenceCount","state","nextToken","hasSpace","items","commaSeparator","listEnd","listEndIndex","_shouldPrintComment","ignore","commentTok","shouldPrintComment","skipNewLines","isBlockComment","printNewLines","adjustMultilineComment","newlineRegex","RegExp","indentSize","nodeLoc","hasLoc","nodeStartLine","nodeEndLine","lastLine","leadingCommentNewline","shouldPrint","commentStartLine","commentEndLine","min","singleLine","shouldSkipNewline","normalizeOptions","experimental_preserveFormat","quotes","wrap","minimal","includes","console","error","sourceMaps"],"mappings":"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"}